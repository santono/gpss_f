<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><meta name="generator" content="ABBYY FineReader 10"/><link rel="stylesheet" href="Untitled.FR10_files/Untitled.FR10.css" type="text/css"/>
</head>
<body>
<p><span class="font37" style="font-weight:bold;">PREFACE</span></p>
<p><span class="font37" style="font-weight:bold;">By contrast with other modelling methods, simulation is said to give expensive results. For the time being, this reservation is justified, but improved hardware and software are reducing many costs. Ve thus assume that the advantages of simulation will stand out more and more and its range of application broaden.</span></p>
<p><span class="font37" style="font-weight:bold;">The costs of simulation fall into three categories:</span></p>
<p><span class="font37" style="font-weight:bold;">*&nbsp;long run times,</span></p>
<p><span class="font37" style="font-weight:bold;">*&nbsp;high memory demand, and</span></p>
<p><span class="font37" style="font-weight:bold;">*&nbsp;large development costs.</span></p>
<p><span class="font37" style="font-weight:bold;">It is already certain that emerging technology will drastically trim the costs of computing power and memory capacity. Long run times and high memory demand will no longer bar simulation. Development costs will, on the contrary, probably rise.</span></p>
<p><span class="font37" style="font-weight:bold;">One way to cut development costs is to develop a simulator composed of immediately usable, tested modules. Then, to build a model, the user need only set the finished modules together. Experience shows that such a simulator reduces costs significantly, provided: 1) the number of modules is not too large and 2) they are designed to correspond to all possibly occurring elements and functions of the system being modelled. GPSS-F was designed to satisfy both criteria.</span></p>
<p><span class="font37" style="font-weight:bold;">The GPSS-F simulator is a Fortran program-package. It consists of a chassis, the main program, into which calls to the modules, GPSS-F's subroutines, are inserted. Its construction makes it superior in several respects to its grandparent, GPSS (1):</span></p>
<p><span class="font37" style="font-weight:bold;">*&nbsp;GPSS</span><span class="font37">-F</span><span class="font37" style="font-weight:bold;"> can be run on any computer with a Fortran compiler. All simulation models are virtually machine-independent.The package is already in use on a wide variety of machines, including IBM 360's and 370's, Cyber-series machines and PDP machines.</span></p>
<p><span class="font37">*&nbsp;Any Fortran programmer can change, extend or improve the simulator easily himself. He can tailor</span><span class="font37" style="font-weight:bold;"> GPSS-F</span><span class="font37"> to suit his fancy, or even add new language-features required by his problem.</span></p>
<p><span class="font37">A beginner can learn the use of</span><span class="font37" style="font-weight:bold;"> GPSS-F</span><span class="font37"> by either of two methods. The steam-roller method would be to read chapters 1 and 2, section ^.1 and chapters 7 and 9, ignoring under way any mention of preemption, multifacilities, storages and families.</span></p>
<p><span class="font37">The butterfly method browses through chapter 1 reading 1.6 carefully, then jumps to chapter 11, where it finds example models, each supplied with reading suggestions. Then it flits from examples to readings, progressing through the seven models from the 3imple to the ever more complex. The frequent cross-references in the text are navigation-aids for the butterfliers.</span></p>
<p><span class="font37">Despite the differences, GPSS and GPSS-F are close relatives.</span></p>
<p><span class="font48">They resemble one another especially In their names: GPSS-F'a and GPSS's stations are named alike and GPSS-F's subroutines are often named after GPSS's blocks. But the younger program has fea-tures beyond older one's. The following points summarize its nov~ titles:</span></p>
<p><span class="font48">•&nbsp;Events</span></p>
<p><span class="font48">Events are now as easy&quot;to handle as transactions, where GPSS res* trieted itself to transactions.</span></p>
<p><span class="font48">•&nbsp;Transaction-locking</span></p>
<p><span class="font48">In both simulators, transactions can wait at any point they choose, until the system's state satisfies certain conditions. In GPSS-F the user can test the system's state whenever he wants, to see whether a waiting transaction can now proceed. In GPSS, on the other hand«, only the simulator's flow management can test the wait conditions; they are outside the user's reach.</span></p>
<p><span class="font48">•&nbsp;Queue-processing</span></p>
<p><span class="font48">Each queue can be administered by its own policy. Furthermore, the transactions' priorities can be be assigned dynamically, as well as statically.</span></p>
<p><span class="font48">•&nbsp;Setup time at preemption</span></p>
<p><span class="font48">It is now possible to take into acoount the setup time lost in any preemption. A model that ignores that time yields false results, if the setup is not short by comparison with the service.</span></p>
<p><span class="font48">•&nbsp;Multifacilities</span></p>
<p><span class="font48">A multifacility is a new type of station. It consists of several ordinary facilities operating in parallel that take transactions from a common queue.</span></p>
<p><span class="font48">•&nbsp;Addressible storages</span></p>
<p><span class="font48">A transaction can acquire and free specific locations; the simulator keeps track of each location's contents.</span></p>
<p><span class="font48">•&nbsp;Coordinating transactions</span></p>
<p><span class="font48">A model can coordinate its transactions' movements more easily. In particular, user chains are more broadly applicable.</span></p>
<p><span class="font48">I should like to thank Prof. F. Hofmann for his generous support. I also thank Prof. G. Hiemeyer for allowing FGPSS (2) to be used as a basis for GPSS-F.</span></p>
<p><span class="font48">I received important help and support from B. Gernoth. She suggested especially valuable improvements. I thank T. Stroup for stimulating discussions that led to improvements in the system and for translating the text into English.</span></p>
<p><span class="font48">The program package GPSS-F is maintained by Dr. Staedtler Unternehmensberatung, Rother-Strasse 1, D 85 Nuernberg, Germany, from whom copies of the source deck may be ordered.</span></p>
<p><span class="font48">T</span><span class="font48" style="text-decoration:underline;">JB LE OF CONTEHTS</span></p>
<p><span class="font48"><a href="#bookmark0">1.</span><span class="font47" style="font-weight:bold;"> Modelling a</span><span class="font48"> System. ....................1</span></a></p>
<p><span class="font47" style="font-weight:bold;">1 <sub>#</sub> 1 Systems</span><span class="font48">..............•#••••.•.•1</span></p>
<p><span class="font48">K*.1 Examples..................... 1</span></p>
<p><span class="font48"><a href="#bookmark1">1.1.2&nbsp;Types of Systems..........................1</a></span></p>
<p><span class="font48">1.1.3&nbsp;</span><span class="font47" style="font-weight:bold;">Transaction-oriented and</span></p>
<p><span class="font48">Event-oriented Systems. .... .....</span><span class="font39" style="font-style:italic;"> . ... 2</span></p>
<p><span class="font48"><a href="#bookmark2">1.2&nbsp;Models. ........................3</a></span></p>
<p><span class="font48"><a href="#bookmark3">1.2.1&nbsp;Similar Structures. ...............3</a></span></p>
<p><span class="font48"><a href="#bookmark4">1.2.2&nbsp;Types of Models .................5</a></span></p>
<p><span class="font48">1.3&nbsp;Simulation Languages. . ........ ........ 7</span></p>
<p><span class="font48"><a href="#bookmark5">1.3.1&nbsp;Types of Languages................7</a></span></p>
<p><span class="font48">1.3.2&nbsp;Model Formulation and Range</span></p>
<p><span class="font48"><a href="#bookmark6">of Application..................7</a></span></p>
<p><span class="font48"><a href="#bookmark7">1.4&nbsp;The Program Package GPSS-F....................8</a></span></p>
<p><span class="font48">1.4.1&nbsp;Model Construction and Range</span></p>
<p><span class="font48"><a href="#bookmark8">of Application for GPSS-F . . . .........8</a></span></p>
<p><span class="font48"><a href="#bookmark9">1.4.2&nbsp;A System's Elements and ^unctions....... . 9</a></span></p>
<p><span class="font48"><a href="#bookmark10">1.4.3&nbsp;Application Examples. . .............10</a></span></p>
<p><span class="font48">1.5&nbsp;Developing a Model. .............. ....11</span></p>
<p><span class="font48"><a href="#bookmark11">1.5.1&nbsp;Analyzing a System................11</a></span></p>
<p><span class="font48"><a href="#bookmark12">1.5.2&nbsp;Building a Model.................12</a></span></p>
<p><span class="font48"><a href="#bookmark13">1.5.3&nbsp;Testing a Model .................14</a></span></p>
<p><span class="font48">1.5.4&nbsp;Using a Model . .................</span></p>
<p><span class="font48">1.5.5&nbsp;Analyzing Results ............. . . .15</span></p>
<p><span class="font48">1.6&nbsp;Simulating Discrete Systems ....... ...... .15</span></p>
<p><span class="font48"><a href="#bookmark14">1.6.1&nbsp;Bank-Window Model ............... .16</a></span></p>
<p><span class="font48"><a href="#bookmark15">1.6.2&nbsp;Simulation Flow.................20</a></span></p>
<p><span class="font48"><a href="#bookmark16">1.6.3&nbsp;Waiting Transactions. ..............23</a></span></p>
<p><span class="font48"><a href="#bookmark17">1.6.4&nbsp;Conditioned Activation..............26</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark18">Structure of GPSS-F....................29</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark19">2.1&nbsp;Event Management. ...................29</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark20">2.1.1&nbsp;The Event List. .................29</a></span></p>
<p><span class="font45" style="font-weight:bold;">2.1.2&nbsp;EVFNT .......... ........... .30</span></p>
<p><span class="font45" style="font-weight:bold;">2.2&nbsp;Transactions........ ... . . . . . . . . . . .32</span></p>
<p><span class="font45" style="font-weight:bold;">2.2.1&nbsp;Transactions' Data Area ............. 13</span></p>
<p><span class="font45" style="font-weight:bold;">2.2.2&nbsp;Transactions ' States...............</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark21">2.3&nbsp;Transaction Management....... . . ........37</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark22">2.3.1&nbsp;Activation List..........................38</a></span></p>
<p><span class="font45" style="font-weight:bold;">2.3.2&nbsp;ACTIV1. ......... ........... 39</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark23">2.3.3&nbsp;ACTIV2......■ * ' |&nbsp;.42</a></span></p>
<p><span class="font45" style="font-weight:bold;">2</span><span class="font48">.4</span><span class="font47" style="font-weight:bold;"> Transaction Generation and</span></p>
<p><span class="font47" style="font-weight:bold;"><a href="#bookmark24">Annihilation......................45</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark25">2</span><span class="font48">.4.1</span><span class="font45" style="font-weight:bold;">&nbsp;GENERA</span><span class="font48">......................45</span></a></p>
<p><span class="font45" style="font-weight:bold;">2</span><span class="font48">.4.2&nbsp;TERMIN........................</span></p>
<p><span class="font48"><a href="#bookmark26">2 5 Transaction-State Management. . ............49</a></span></p>
<p><span class="font48"><a href="#bookmark27">* 2.5.1 ADVANV......................49</a></span></p>
<p><span class="font45" style="font-weight:bold;">2.5.2&nbsp;BUFFER........................</span></p>
<p><span class="font48"><a href="#bookmark28">2.5.3&nbsp;UNLOCK......................51</a></span></p>
<p><span class="font48"><a href="#bookmark29">2.6 The Chassis.......................51</a></span></p>
<p><span class="font48"><a href="#bookmark30">2.6.1&nbsp;Chassis Sections.................52</a></span></p>
<p><span class="font48"><a href="#bookmark31">2.6.2&nbsp;INIT1......................55</a></span></p>
<p><span class="font48"><a href="#bookmark32">2.6.3&nbsp;INIT2......................56</a></span></p>
<p><span class="font48"><a href="#bookmark33">2.6.4&nbsp;INIT3......................57</a></span></p>
<p><span class="font48"><a href="#bookmark34">2.6.5&nbsp;RESET......................58</a></span></p>
<p><span class="font48"><a href="#bookmark35">3.&nbsp;Stations and Policies...................60</a></span></p>
<p><span class="font48"><a href="#bookmark36">3.1&nbsp;Policies...............................60</a></span></p>
<p><span class="font48">3.1.1&nbsp;Priority and Preemption ..........•.. .60</span></p>
<p><span class="font48"><a href="#bookmark37">3.1.2&nbsp;FITO (First In, First Out)............6.1</a></span></p>
<p><span class="font48"><a href="#bookmark38">3.1.3&nbsp;LIFO (Last In, First Out)............61</a></span></p>
<p><span class="font48"><a href="#bookmark39">3.1.4&nbsp;SJF (Shortest Job First).............62</a></span></p>
<p><span class="font48"><a href="#bookmark40">3.1.5&nbsp;Round-Robin (Cyclic Policy) ...........62</a></span></p>
<p><span class="font48"><a href="#bookmark41">3.1.5 LFB (Limited Feedback). . . . ..........64</a></span></p>
<p><span class="font48"><a href="#bookmark42">3.2&nbsp;Dynamic Priority Assignment..............64</a></span></p>
<p><span class="font48">3.2.1&nbsp;Types of Dynamic Priority</span></p>
<p><span class="font48"><a href="#bookmark43">Assignment. ....... ...... . .....64</a></span></p>
<p><span class="font48"><a href="#bookmark44">3.2.2&nbsp;UTL (Upper Time Limit)..............64</a></span></p>
<p><span class="font48">3.2.3&nbsp;UTLP (Upper Time Limit with</span></p>
<p><span class="font48"><a href="#bookmark45">Priorities) ...................65</a></span></p>
<p><span class="font48">3.2.4&nbsp;WTLP (Waiting Time Limit with</span></p>
<p><span class="font48"><a href="#bookmark46">Priorities) ...................66</a></span></p>
<p><span class="font48"><a href="#bookmark47">3.3&nbsp;Policies in GPSS-F...................66</a></span></p>
<p><span class="font48"><a href="#bookmark48">3.3.1&nbsp;POLICY......................67</a></span></p>
<p><span class="font48"><a href="#bookmark49">3.3.2&nbsp;PFIPO ......................69</a></span></p>
<p><span class="font48"><a href="#bookmark50">3.3.3&nbsp;FIFO.......................70</a></span></p>
<p><span class="font48">3-3.4 Dynamic Priority Assignment</span></p>
<p><span class="font48"><a href="#bookmark51">with Subroutine DYNVAL..............71</a></span></p>
<p><span class="font48"><a href="#bookmark52">3.4&nbsp;The State Vector. ...................72</a></span></p>
<p><span class="font48"><a href="#bookmark53">3.5&nbsp;The Watchdog......................73</a></span></p>
<p><span class="font48"><a href="#bookmark54">4.&nbsp;Facilities.............<sub>.</sub>...........74</a></span></p>
<p><span class="font48"><a href="#bookmark55">4.1 Acquiring and Freeing a Facility............<sup>75</sup></a></span></p>
<p><span class="font48">4.1.1&nbsp;SFIZF ...&nbsp;..... -75</span></p>
<p><span class="font48"><a href="#bookmark56">4.1.2&nbsp;WORK. . . [ ............... .. .77</a></span></p>
<p><span class="font48"><a href="#bookmark57">1 .3 CL^AR . . . ' .................80</a></span></p><div>
<p><span class="font39" style="font-style:italic;">9</span></p></div>
<p><span class="font48"><a href="#bookmark58">»2 Preemption......................</span><span class="font21" style="font-weight:bold;">..................81</span></a></p>
<p><span class="font48"><a href="#bookmark59">4.2,1 PREEMP......................81</a></span></p>
<p><span class="font48">11.2.2 Setup and Knockdown in Case of</span></p>
<p><span class="font48">preemption. .••••• ........ •«•••85</span></p>
<p><span class="font48"><a href="#bookmark60">4.2.3&nbsp;SETUP • .................... .86</a></span></p>
<p><span class="font48"><a href="#bookmark61">4.2.4&nbsp;KNOCKD.......<sub>.</sub>..............87</a></span></p>
<p><span class="font48"><a href="#bookmark62">4.3 Multiple Entries to a Facility..................90</a></span></p>
<p><span class="font48"><a href="#bookmark63">5.&nbsp;Multifacilitiea . . • . ..................91</a></span></p>
<p><span class="font48">5.1&nbsp;The Structure of Maltifacilities. ••........ .91</span></p>
<p><span class="font48">5.2&nbsp;Acquiring and Freeing a</span></p>
<p><span class="font48"><a href="#bookmark64">Hultifacility.....................95</a></span></p>
<p><span class="font48"><a href="#bookmark65">5.2.1&nbsp;MSEIZE......................95</a></span></p>
<p><span class="font48"><a href="#bookmark66">5.2.2&nbsp;«WORK.............. ....... .98</a></span></p>
<p><span class="font48"><a href="#bookmark67">5.2.3&nbsp;MCLEAR.....................100</a></span></p>
<p><span class="font48"><a href="#bookmark68">5.3&nbsp;Preemption at Multifacilities............102</a></span></p>
<p><span class="font48"><a href="#bookmark69">5.3.1 MPREEM.....................102</a></span></p>
<p><span class="font48">5*3*2 Setup and Knockdown in Case of</span></p>
<p><span class="font48">Preemption................... 106</span></p>
<p><span class="font48"><a href="#bookmark70"><a name="bookmark70"></a>5.3.3 MSETUP.....................106</a></span></p>
<p><span class="font48"><a href="#bookmark71">5.4&nbsp;The Plan: Service-Element Management.........107</a></span></p>
<p><span class="font48"><a href="#bookmark72">5.4.1&nbsp;PLANI and PLANO................107</a></span></p>
<p><span class="font48">5.4.2&nbsp;LFIRST.................. • . • 109</span></p>
<p><span class="font48"><a href="#bookmark73">5.4.3&nbsp;PRIOR.....................109</a></span></p>
<p><span class="font48"><a href="#bookmark74">6.&nbsp;Storages ....... ........... ...... 111</a></span></p>
<p><span class="font48"><a href="#bookmark75">6.1&nbsp;The Structure of Storages......................Ill</a></span></p>
<p><span class="font48"><a href="#bookmark76">6.2&nbsp;Non-Addressible Storages........................113</a></span></p>
<p><span class="font48"><a href="#bookmark77">6.2.1&nbsp;ENTER.....................113</a></span></p>
<p><span class="font48"><a href="#bookmark78">6.2.2&nbsp;LEAVE........................116</a></span></p>
<p><span class="font48"><a href="#bookmark79">6.3&nbsp;Strategies...................... 117</a></span></p>
<p><span class="font48"><a href="#bookmark80">6.3*1 Storage Acquisition .............. 117</a></span></p>
<p><span class="font48"><a href="#bookmark81">6.3-2 First-fit ........ ........... 117</a></span></p>
<p><span class="font48"><a href="#bookmark82">6.3.3&nbsp;Best-fit. ...................118</a></span></p>
<p><span class="font48"><a href="#bookmark83">6.3.4&nbsp;Conditioned Storage Assignment.........119</a></span></p>
<p><span class="font48">6.3.5&nbsp;Segmenting................. . . 119</span></p>
<p><span class="font29" style="font-weight:bold;"><a href="#bookmark84">6.3.6</span><span class="font48">&nbsp;Collecting Free Space ............. 119</span></a></p>
<p><span class="font48"><a href="#bookmark85">6.3.7&nbsp;Freeing Space.................121</a></span></p>
<p><span class="font48"><a href="#bookmark86">6.4&nbsp;Addressible Storages.................121</a></span></p>
<p><span class="font48">6.4.1&nbsp;The Structure of Addressible</span></p>
<p><span class="font48"><a href="#bookmark87">Storages..............».....121</a></span></p>
<p><span class="font48"><a href="#bookmark88">6.4.2&nbsp;ALLOC.........................«123</a></span></p>
<p><span class="font48">6.4.3&nbsp;FREE................... * • .^127</span></p>
<p><span class="font39" style="font-style:italic;">6 5</span><span class="font48"> GPSS-F strategies • • •...............</span></p>
<p><span class="font48"><a href="#bookmark89">6:5.1 STRATA and STRATF.........•.....J30</a></span></p>
<p><span class="font48">6.5-2 FFIT. . • ............* I I ! <sup>#</sup> * 1 \\</span></p>
<p><span class="font48">6.5.3 BFXT.....•...................</span></p>
<p><span class="font40" style="font-weight:bold;"><a href="#bookmark90">7.</span><span class="font47" style="font-weight:bold;"> Coordinating Transactions</span><span class="font48">................135</span></a></p>
<p><span class="font48"><a href="#bookmark91">7.1&nbsp;Branching on Condition. . ..............]35</a></span></p>
<p><span class="font48"><a href="#bookmark92">7.1.1&nbsp;</span><span class="font47" style="font-weight:bold;">Deterministic</span><span class="font48"> Bran?hing ....... ..... 135</span></a></p>
<p><span class="font48">7.1.2&nbsp;Stochastic Branching:</span></p>
<p><span class="font48"><a href="#bookmark93"><a name="bookmark93"></a>TRANSF. ....................W</a></span></p>
<p><span class="font48"><a href="#bookmark94">7.2&nbsp;Waiting on Condition.................J36</a></span></p>
<p><span class="font48"><a href="#bookmark95">7.2.1&nbsp;Trying the Gate................«37</a></span></p>
<p><span class="font48"><a href="#bookmark96">7.2.2&nbsp;Local and Global Parameters .......... 13©</a></span></p>
<p><span class="font48"><a href="#bookmark97">7.3&nbsp;Gates........................-</a></span></p>
<p><span class="font48"><a href="#bookmark98">7.3-1 ..........................J 39</a></span></p>
<p><span class="font48"><a href="#bookmark99">7.3.2&nbsp;GATE2.....................JJ3</a></span></p>
<p><span class="font48"><a href="#bookmark100">7.3.3&nbsp;The IT Mechanism................145</a></span></p>
<p><span class="font48">7.4&nbsp;Gather Stations................- • • <sup>1J|6</sup></span></p>
<p><span class="font48">7.4.1&nbsp;Coordinating Transactions in one</span></p>
<p><span class="font48"><a href="#bookmark101">Processing Path&nbsp;............. 1^6</a></span></p>
<p><span class="font48"><a href="#bookmark102">7.4.2&nbsp;GATHR2. ....................1<sup>1</sup>*<sup>6</sup></a></span></p>
<p><span class="font48"><a href="#bookmark103">7.5&nbsp;User Chains and Trigger Stations...........148</a></span></p>
<p><span class="font48">7.5.1&nbsp;Coordinating Transaction in</span></p>
<p><span class="font48"><a href="#bookmark104">Parallel Paths.................148</a></span></p>
<p><span class="font48"><a href="#bookmark105"><a name="bookmark105"></a>7.5.2&nbsp;LINK2.....................150</a></span></p>
<p><span class="font48"><a href="#bookmark106">7.5.3&nbsp;UNLTM2.....................152</a></span></p>
<p><span class="font48"><a href="#bookmark107">8.&nbsp;Families.......<sub>%</sub>..................155</a></span></p>
<p><span class="font48"><a href="#bookmark108">8.1&nbsp;Kindred Tasks ....................155</a></span></p>
<p><span class="font48"><a href="#bookmark109">8.2&nbsp;Data Areas for Families...............155</a></span></p>
<p><span class="font29" style="font-weight:bold;"><a href="#bookmark110">8</span><span class="font48">.3&nbsp;The Birth and Death of Kinsmen............156</span></a></p>
<p><span class="font48"><a href="#bookmark111">8.3.1&nbsp;SPLIT.....................156</a></span></p>
<p><span class="font48"><a href="#bookmark112">8.3.2&nbsp;ASSEMB.....................158</a></span></p>
<p><span class="font48"><a href="#bookmark113">8.H Coordinating Family Members ..........................160</a></span></p>
<p><span class="font48"><a href="#bookmark114">8.4.1 Gather Stations for Families. .........160</a></span></p>
<p><span class="font48"><a href="#bookmark115">8.11.2 GATHR1.....;.....................160</a></span></p>
<p><span class="font48">8.4.3&nbsp;User Chains and Trigger Stations</span></p>
<p><span class="font48">for Families........................... 162</span></p>
<p><span class="font48"><a href="#bookmark116">8.4.4&nbsp;LIMK1............• • •&nbsp;<sub>#</sub> 163</a></span></p>
<p><span class="font48">8.4.5&nbsp;UNLIN1. . . . ..... <sub>#</sub> \ \ \ I I I ] [ I [I <sub>#</sub> 165</span></p>
<p><span class="font48">9.&nbsp;Random Sequences............'&nbsp;..... 168</span></p>
<p><span class="font48">9.1 Random Number Generators. .............. 168</span></p>
<p><span class="font45" style="font-weight:bold;">9.2&nbsp;Uniformly Distributed Random</span></p>
<p><span class="font48">Sequences......................169</span></p>
<p><span class="font45" style="font-weight:bold;">9.3&nbsp;Arbitrarily Distributed Random</span></p>
<p><span class="font48">Sequences . ............... ••«••170</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.1&nbsp;Using the Inverse Cumulative-»</span></p>
<p><span class="font45" style="font-weight:bold;">Distribution Function ...... .......</span><span class="font29" style="font-weight:bold;"> 170</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.2&nbsp;Exponential and Erlang</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark117">Distribution. ............°.....</span><span class="font40" style="font-weight:bold;">171</span></a></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark118">9.3*3 Gauss Distribution.....• ••••««...&nbsp;174</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark119">9.3.4&nbsp;Lognormal Distribution. ......... . . .&nbsp;175</a></span></p>
<p><span class="font48">9.3.5&nbsp;Approximating Empirical</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark120">Distributions.................175</a></span></p>
<p><span class="font48"><a href="#bookmark121">9.3.6&nbsp;Truncated Distributions ............</span><span class="font40" style="font-weight:bold;"> 177</span></a></p>
<p><span class="font48"><a href="#bookmark122">9.4 Random Numbers in GPSS-F...............181</a></span></p>
<p><span class="font48"><a href="#bookmark123">9.4.1&nbsp;Function RN..................</span><span class="font40" style="font-weight:bold;">І81</span></a></p>
<p><span class="font48"><a href="#bookmark124">9.4.2&nbsp;UNIFRM......................182</a></span></p>
<p><span class="font48"><a href="#bookmark125">9.4.3&nbsp;ERLANG........... ...........183</a></span></p>
<p><span class="font48"><a href="#bookmark126">9.4.4&nbsp;GAUSS.....................184</a></span></p>
<p><span class="font48"><a href="#bookmark127">9-4.5 LOGNOR.....................185</a></span></p>
<p><span class="font48"><a href="#bookmark128">9.4.6&nbsp;BOXEXP.....................186</a></span></p>
<p><span class="font48">9.4.7&nbsp;Using the Random Number</span></p>
<p><span class="font48">Generators...................187</span></p>
<p><span class="font48"><a href="#bookmark129">10. Gathering Statistical Data . . . . . .......... 190</a></span></p>
<p><span class="font48"><a href="#bookmark130">10.1&nbsp;Bins. .......................190</a></span></p>
<p><span class="font48"><a href="#bookmark131">10.1.1&nbsp;Statistics Gathered by Bins.........190</a></span></p>
<p><span class="font48"><a href="#bookmark132">10.1.2&nbsp;ARRIVE...................193</a></span></p>
<p><span class="font48"><a href="#bookmark133">10.1.3&nbsp;DEPART . ..................194</a></span></p>
<p><span class="font48"><a href="#bookmark134">10.1.4&nbsp;ENDBIM...................196</a></span></p>
<p><span class="font48"><a href="#bookmark135">10.2&nbsp;Frequency Table ..................197</a></span></p>
<p><span class="font48"><a href="#bookmark136">10.2.1&nbsp;TABULA...................197</a></span></p>
<p><span class="font48"><a href="#bookmark137">10.2.2&nbsp;RVALUE ................... 199</a></span></p>
<p><span class="font48"><a href="#bookmark138">10.2.3&nbsp;GRAPH....................201</a></span></p>
<p><span class="font48"><a href="#bookmark139">10.3&nbsp;Report of the System's State............204</a></span></p>
<p><span class="font48"><a href="#bookmark140">10.3.1&nbsp;REPORT...................204</a></span></p>
<p><span class="font48"><a href="#bookmark141">10.3.2&nbsp;SMLIST ................... 205</a></span></p>
<p><span class="font48">10.3.3&nbsp;SELIST . • . .............. • • 206</span></p>
<p><span class="font48"><a href="#bookmark142">10.4&nbsp;Saving the System's State ............ . 207</a></span></p>
<p><span class="font48"><a href="#bookmark143">10.4.1&nbsp;SAVE.............J ..........207</a></span></p>
<p><span class="font48"><a href="#bookmark144">10.4.2&nbsp;C0NT . .................207</a></span></p>
<p><span class="font48"><a href="#bookmark145">10.5&nbsp;Ending Stochastic Simulation. . .......... 208</a></span></p>
<p><span class="font48"><a href="#bookmark146">11. Models ............................211</a></span></p>
<p><span class="font48">11.1 Flow Management ...........•..••••211</span></p>
<p><span class="font48"><a href="#bookmark147">11.1.1 Bank Window......... ........<sup>231</sup></a></span></p>
<p><span class="font45" style="font-weight:bold;">со</span></p>
<p><span class="font45" style="font-weight:bold;">et</span></p>
<p><span class="font45" style="font-weight:bold;">до ft M* ф 09 О С С</span></p>
<p><span class="font45" style="font-weight:bold;">и» Н* ♦</span></p>
<p><span class="font45" style="font-weight:bold;">Я 3 </span><span class="font39" style="font-style:italic;">ui</span><span class="font45" style="font-weight:bold;"> м •</span></p><div>
<p><span class="font48">1 </span><span class="font45" style="font-weight:bold;">U</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">н» </span><span class="font48">ff</span></p>
<p><span class="font45" style="font-weight:bold;">№ q</span></p>
<p><span class="font45" style="font-weight:bold;">ä' </span><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф </span><span class="font45" style="font-weight:bold;">ч</span></p>
<p><span class="font45" style="font-weight:bold;">о </span><span class="font48">эг tu</span></p>
<p><span class="font45" style="font-weight:bold;">H* З (A</span></p></div><div>
<p><span class="font48">SS » «</span></p>
<p><span class="font48">I I</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0<sup>і </sup>с</span></p>
<p><span class="font48">84!</span></p>
<p><span class="font48">trt*</span></p>
<p><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф ^ •</span></p>
<p><span class="font45" style="font-weight:bold;">&lt;&lt; -л</span></p>
<p><span class="font45" style="font-weight:bold;">•а</span></p>
<p><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф</span><span class="font45" style="font-weight:bold;"> о</span></p>
<p><span class="font45" style="font-weight:bold;">I 0) с*</span></p>
<p><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф </span><span class="font45" style="font-weight:bold;">0)</span></p></div><div>
<p><span class="font11">*</span></p>
<p><span class="font45" style="font-weight:bold;">H' И</span></p>
<p><span class="font45" style="font-weight:bold;">3<sup>e</sup></span></p></div><div>
<p><span class="font45" style="font-weight:bold;">I</span><span class="font39" style="font-style:italic;"> X</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font48">rv&gt;</span></p>
<p><span class="font45" style="font-weight:bold;">о</span></p>
<p><span class="font45" style="font-weight:bold;">Ш et</span></p>
<p><span class="font45" style="font-weight:bold;">о </span><span class="font34">00</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">H &lt;&lt;</span></p>
<p><span class="font39" style="font-style:italic;">TD </span><span class="font45" style="font-weight:bold;">Ф I</span></p>
<p><span class="font45" style="font-weight:bold;">ru</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">w Ф</span></p>
<p><span class="font45" style="font-weight:bold;">о </span><span class="font48">аг </span><span class="font45" style="font-weight:bold;">0) и* 3 </span><span class="font48">со</span></p></div><div>
<p><span class="font48">оч</span></p>
<p><span class="font48">U)</span></p>
<p><span class="font48">о</span></p></div>
<p><span class="font48"><a name="bookmark148"></a>I </span><span class="font11" style="font-style:italic;">to</span></p>
<p><span class="font45" style="font-weight:bold;">•о</span></p>
<p><span class="font45" style="font-weight:bold;">M</span></p>
<p><span class="font45" style="font-weight:bold;">ш ч и* 9</span></p><div>
<p><span class="font45" style="font-weight:bold;">ON</span></p>
<p><span class="font39" style="font-style:italic;">тЛ т* ш* Ці шЛ тЛ</span><span class="font45" style="font-weight:bold;"> -А -»</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;I • t ^</span></p>
<p><span class="font48">0&gt; 0N ON ON ДО</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;• • •</span><span class="font39" style="font-style:italic;"> ft </span><span class="font45" style="font-weight:bold;">£ru&gt; î\&gt; —* Ф</span></p>
<p><span class="font45" style="font-weight:bold;">oq</span></p>
<p><span class="font48">О С/) H О И' </span><span class="font45" style="font-weight:bold;">О с* 3<sup>е</sup> О ф</span></p>
<p><span class="font48">м а&gt; Ф а мп чз </span><span class="font45" style="font-weight:bold;">s с</span></p>
<p><span class="font45" style="font-weight:bold;">О с+ a </span><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф </span><span class="font45" style="font-weight:bold;">Ф п и </span><span class="font48">11</span></p>
<p><span class="font11">to</span></p>
<p><span class="font45" style="font-weight:bold;">ff! а</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">ЧЛ</span></p>
<p><span class="font45" style="font-weight:bold;">Xr</span></p>
<p><span class="font39" style="font-style:italic;">(А</span></p><img src="Untitled.FR10_files/Untitled.FR10-1.jpg" style="width:118pt;height:235pt;"/></div><div>
<p><span class="font39" style="font-style:italic;">тЛ -Л</span><span class="font45" style="font-weight:bold;"> О</span></p>
<p><span class="font39" style="font-style:italic;">шф</span><span class="font45" style="font-weight:bold;"> ^ û»</span></p>
<p><span class="font48">•&nbsp;• I ft </span><span class="font45" style="font-weight:bold;">-si -s) ф</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;• • 0) U)</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">• і</span></p>
<p><span class="font48" style="font-variant:small-caps;">а&gt; on • ' §</span></p>
<p><span class="font39" style="font-style:italic;">о н* </span><span class="font45" style="font-weight:bold;">а з </span><span class="font14" style="font-weight:bold;font-variant:small-caps;">ф</span></p></div><div>
<p><span class="font48">• • • ЫЫ u&gt;</span></p>
<p><span class="font48">^c H H</span></p>
<table border="1">
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">о</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">d* с</span></p></td><td>
<p></p></td></tr>
<tr><td colspan="2">
<p><span class="font48" style="font-variant:small-caps;">а ф з</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">ш</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">ф</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">ф</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">3</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">m</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">1</span></p>
<p><span class="font45" style="font-weight:bold;">о с</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">а</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">г&quot;</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">а*о</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">4j</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">и*</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">ф w</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">•1</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">W</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">и</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">t*</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">11</span></p></td><td>
<p><span class="font11">га</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">и* </span><span class="font48" style="font-variant:small-caps;">g</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">о</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">&quot;в</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">w</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">о'</span></p></td><td>
<p><span class="font14" style="font-style:italic;">&amp;</span></p></td></tr>
<tr><td>
<p><span class="font10">»</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">о</span><span class="font9" style="font-style:italic;"> \</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">и</span></p></td></tr>
</table></div><div>
<p><span class="font45" style="font-weight:bold;">00 -J 0&gt; Kjy 4=r</span></p></div><div>
<p><span class="font48">u&gt; f\j —» и-</span></p></div><div>
<p><span class="font48">ЧЛ |гы м</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">2 О a </span><span class="font35" style="font-style:italic;">(V</span></p></div><div>
<p><span class="font48">О I H п Ш О 7 ÛJ </span><span class="font45" style="font-weight:bold;">С* CX Ф ÇT M &lt;t&gt;</span></p></div><div>
<p><span class="font48">4J 3 </span><span class="font39" style="font-style:italic;">h* О </span><span class="font45" style="font-weight:bold;">з a P Ф</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">О H* 5Г ЯГ</span></p>
<p><span class="font48">£ а d (I </span><span class="font45" style="font-weight:bold;">Ф а»</span></p>
<p><span class="font48">M м (Л о </span><span class="font45" style="font-weight:bold;">к у </span><span class="font48">гяил</span></p>
<p><span class="font45" style="font-weight:bold;">И f* И</span></p>
<p><span class="font48">м м d 3 и- із a и ИИ «u </span><span class="font45" style="font-weight:bold;">M і</span></p></div><div>
<p><span class="font48" style="font-variant:small-caps;">ф</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">о</span></p>
<p><span class="font45" style="font-weight:bold;">n a о и* ф 0&gt;</span></p>
<p><span class="font48">и мт</span></p>
<p><span class="font45" style="font-weight:bold;">&lt;4 И* 3 W</span></p></div><div>
<p><span class="font39" style="font-style:italic;">г</span><span class="font45" style="font-weight:bold;"> a</span></p>
<p><span class="font45" style="font-weight:bold;">H*</span><span class="font48"> ft W h' </span><span class="font45" style="font-weight:bold;">f*</span></p>
<p><span class="font48">M* ï </span><span class="font45" style="font-weight:bold;">3 H*</span></p>
<p><span class="font48">Wf* </span><span class="font15" style="font-style:italic;">&amp;</span></p>
<p><span class="font39" style="font-style:italic;">К ' </span><span class="font45" style="font-weight:bold;">Ф</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">г- »</span></p>
<p><span class="font45" style="font-weight:bold;">и» ф </span><span class="font39" style="font-style:italic;">{/I (А </span><span class="font45" style="font-weight:bold;">К Є</span></p>
<p><span class="font48">M» M</span></p>
<p><span class="font45" style="font-weight:bold;">Я ft</span></p>
<p><span class="font45" style="font-weight:bold;">Л W </span><span class="font48">і і</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">20 Г* Ф и* (/) W </span><span class="font48">С t+</span></p>
<p><span class="font48">M H» c+ 3 W 9)</span></p></div>
<p><span class="font45" style="font-weight:bold;">«Î-.</span></p>
<p><span class="font45" style="font-weight:bold;">о</span></p>
<table border="1">
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">«wt «é</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font6">•</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">ts&gt;</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">^ 1 SD</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">«А</span><span class="font39" style="font-style:italic;"> тЛ</span></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">ш</span></p></td></tr>
<tr><td>
<p><span class="font7">• •</span></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">• • а</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">fS) M</span></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">in) i\&gt; а</span></p></td></tr>
<tr><td>
<p><span class="font4">• ♦</span></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">• • о</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">4ru&gt;</span></p></td><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">i\&gt; — а</span></p></td></tr>
<tr><td colspan="3">
<p><span class="font45" style="font-weight:bold;">X •-) О О С/1 С/)</span></p></td></tr>
<tr><td colspan="2">
<p><span class="font48" style="font-variant:small-caps;">о э<sup>г</sup> ф</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">С «О ф</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">а ф</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">3</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">Ч С JÛ</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">ф</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">ф</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">и» С</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">M 2</span></p></td><td>
<p></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">g 1 ф</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">о</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">ш</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">08 П 3</span></p></td></tr>
<tr><td colspan="3">
<p><span class="font45" style="font-weight:bold;">ra(t(p ф о</span></p></td></tr>
</table><img src="Untitled.FR10_files/Untitled.FR10-2.jpg" style="width:72pt;height:147pt;"/>
<p><span class="font45" style="font-weight:bold;">V^UJLOU) U)U) rv&gt; r&gt;0 го го ro r\&gt; r\&gt; r\&gt; r\&gt; |\&gt;</span></p>
<p><span class="font45" style="font-weight:bold;">, » <sup>4-4</sup> 9 OO vOvOvO 00</span><span class="font39" style="font-style:italic;"> CO</span><span class="font45" style="font-weight:bold;"> 00 00 00 00 00 чО 14) NO vO SO 0%ЧЛЧЛ LO UJ (\) (\)</span></p><div>
<p><span class="font45" style="font-weight:bold;">f\)(V)fV) fV)</span></p>
<p><span class="font45" style="font-weight:bold;">^ «I «4</span></p>
<p><span class="font48">ONVn xr</span></p></div><div>
<p><span class="font48">l\&gt; f\) r\&gt; f\&gt;</span></p>
<p><span class="font48">чЛ VJ1</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">гч&gt; го гч&gt; го</span></p>
<p><span class="font48">O^ONON </span><span class="font48" style="font-variant:small-caps;">го vo k0\0</span></p></div><div>
<p><span class="font48">ГО Г0 l\&gt; f\&gt; </span><span class="font45" style="font-weight:bold;">ЧЯ ЧЯ VJ1 Ol </span><span class="font48">l\)000</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">f\&gt; !\&gt; ÏNJ</span></p>
<p><span class="font48">f\) f\) r\)</span></p>
<p><span class="font48" style="font-variant:small-caps;">vo on чл</span></p></div><div>
<p><span class="font48">rv&gt; rv) f\) fU ДГ &lt;jü u&gt; u&gt; О CO 09 a&gt;</span></p></div>
<p><span class="font48">xlii</span></p>
<p><span class="font47" style="font-weight:bold;">Appendix......................# ♦ • <sub>#</span><span class="font40" style="font-weight:bold;"></sub> 317</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark149">Al</span><span class="font48"> The System '3 Variables.....</span><span class="font45" style="font-weight:bold;">fff</span></a></p>
<p><span class="font39" style="font-style:italic;"><a href="#bookmark150">K2</span><span class="font48"> Description of the Data Area. ................- 523</span></a></p>
<p><span class="font48">A3 Parameter Adaption.........</span></p>
<p><span class="font48">320</span></p>
<p><span class="font48"><a href="#bookmark151">A4 The Chassis . . . <sub># # .</sub>..............^ <sub>h</sub></a></span></p>
<p><span class="font48">A5 The Subroutines . . . <sub># #</sub>......</span></p>
<p><span class="font48">Bibliography . . . . <sub># # # #</sub> , ; <sub>#</sub></span></p>
<p><span class="font48">MODELLING à SYSTEM</span></p>
<p><span class="font48">Models simulate systems. More precisely<sub>f</sub> a simulation studies a system's behaviour over some period by constructing a second system,&quot; with the same structure as the original, but easier to work with. The second system is called a model.</span></p>
<p><span class="font48">1.1 Systems</span></p>
<p><span class="font48">A system is a set of elements in some way related to one another. At any instant<sub>9</sub> it is in some particular state determined by the elements' states and relationships. The system's state changes when an element's state or its relation to other elements changes.</span></p>
<p><span class="font48">1.1.1&nbsp;Examples</span></p>
<p><span class="font48">*&nbsp;The planetary system:</span></p>
<p><span class="font48">Each planet has some set of private parameters<sub>9</sub> which describe its state. These could include its diameter, geological structure, surface temperature, mass and period of rotation.</span></p>
<p><span class="font48">But the system's momentary state depends not only on the planets' own states, it depends on planetary relationships as well. Those relational parameters would include the bodies' relative positions and velocities. If we assume that the planets' own states don't change during our observation, the system's state can change only in its relational parameters.</span></p>
<p><span class="font48">*&nbsp;A computer installation:</span></p>
<p><span class="font48">Complex systems usually have elements of various types. If a computer installation is regarded as a system, its elements can be classified as processors, memories, peripherals and jobs.</span></p>
<p><span class="font48">As before, the system's parameters are both private and relational: private parameters characterize its elements; relational parameters, the relations and dependencies between them. The relational parameters specify, among other things, which job runs on which processor or which peripherals a job is using. A state change occurs when a parameter's value changes. A relational parameter could change in that the resources allocated to a job change; a private parameter could change in that a job's residual running time or priority changes.</span></p>
<p><span class="font48">1.1.2&nbsp;Types of Systems</span></p>
<p><span class="font48">Systems theory classifies systems with a terminology that imposes rough order on the clutter of possibilities.</span></p>
<p><span class="font48">disturbed. Systems whose state can change are dynamic.</span></p>
<p><span class="font45" style="font-weight:bold;">• Deterministic and Stochastic Systems:</span></p>
<p><span class="font45" style="font-weight:bold;">Dynamic systems are divided into two further classes.</span><span class="font48"> A system </span><span class="font45" style="font-weight:bold;">is deterministic, when for each system state, the subsequent sys</span><span class="font48">tem</span><span class="font45" style="font-weight:bold;"> state is uniquely determined. If various states can follow, the system is stochastic. In plain English, chance is a part of the system. A radioactive nucleus is a stochastic system, since it emits nucleoids at random. 'At random' means that no given state leads, without fail, to radioactive decay.</span></p>
<p><span class="font45" style="font-weight:bold;">• Continuous and discrete systems:</span></p>
<p><span class="font45" style="font-weight:bold;">If state changes are continuous functions of time, as they are, say, in the planetary system, the system is continuous. A lake with streams feeding and draining it is also a continuous system. So is a spring-driven pendulum. If states change abrubtly and at intervals, the system is discrete. Two examples of discrete state changes are: a computer job frees one system resource and acquires another; the ballance in an -account is increased by the amount of a deposit.</span></p>
<p><span class="font48">1.1.3 Transaction-oriented and Event-oriented Systems</span></p>
<p><span class="font48">Among the discrete systems, we distinguish the transaction-oriented from the event-oriented. Many systems can be thought of as built from mobile and stationary system elements. The mobile elements wander between the stationary ones, altering them and being altered. The mobile elements are called transactions; the stationary elements, stations. Systems so constituted are transaction-oriented .</span></p>
<p><span class="font48">Examples:</span></p>
<p><span class="font48">*&nbsp;Computer installation</span></p>
<p><span class="font48">The stations are the system's resources, such as processors, working storage and peripheral devices. The transactions are jobs or tasks brought into the system; they travel from station to station and they acquire, free and queue up in front of stations.</span></p>
<p><span class="font48">*&nbsp;Warehouse</span></p>
<p><span class="font45" style="font-weight:bold;">A</span><span class="font48"> warehouse consists of a great many racks in which wares are kept. The racks count as stations and the wares as transactions. Wares arrive at the warehouse, are filed according to muster and remain stored a <a name="footnote1"></a><sup><a href="#bookmark152">1</a></sup> while. Finally, upon receipt of an order, they are removed from the racks and forwarded.</span></p>
<p><span class="font48">*&nbsp;Street intersection</span></p>
<p><span class="font48">The cars are transactions whose essential characteristic is direction-of-travel. A traffic light coordinates their movement: travel is barred where the light is red. The cars form queues at the light until it changes; then they travel on.</span></p>
<p><span class="font48">When a model mimics one of those systems, it is irrelevant whether its transactions represent jobs in a computer, packages in a warehouse or cars at a traffic light. The essential similarity is, they are all mobile system components« A model's stations are just as flexible. They are equally adept at representing any« thing stationary<sub>9</sub> whether computer processor, warehouse rack, or traffic light.</span></p>
<p><span class="font48">In transaction-oriented systems, all state changes originate in the transaction's movements. An event-orientation doesn't divide the world so sharply into things that move and things that stay put. Instead, it sees systems as composed of elements that may or may not be stationary, but whose interplay entitles them in any case to full-fledged systemhood. The elements undergo state changes, called events, whose origin need not have anything to do with others of the system's elements. Obviously, a complex system may be thought of as part transaction-oriented, part event-oriented.</span></p>
<p><span class="font48">Examples:</span></p>
<p><span class="font48"><sup>9</sup> An exchange of letters</span></p>
<p><span class="font48">Your grandmother remembered *to send you a birthday card. Since grandmothers remember such things quite on their own, they are genuine event-makers; their memories are not jogged by the movement of anything else on earth. If you wrote a pleasant reply, your activity is t ransaction—oriented| since it was occasioned by the birthday card's arrival.</span></p>
<p><span class="font48">• Traffic light</span></p>
<p><span class="font48">If we view the traffic light as a subsystem within the larger system sketched above, we could see it as event-oriented. Irrespective of traffic movements, it changes from red to green and back again.</span></p>
<p><span class="font48">1.2 Models</span></p>
<p><span class="font48">Even under the best of circumstances, it may be impossible to study a system directly. In systems planning, for example, the system doesn't yet exist. Or a system may be inaccessible, or its investigation dangerous or costly. Often, the system can't be studied because it changes too quickly or too slowly. So the study is carried out on a second system, built for the occasion. Of two systems structured alike, with respect to the values to be studied, the one used to investigate the other is called a model.</span></p>
<p><span class="font48">1.2.1 Similar Structures</span></p>
<p><span class="font48">An example should make clear what it means to say that two systems have a common structure:</span></p>
<p><span class="font48"><sup>11</sup> A mechanical system</span></p>
<p><span class="font48">A mass M is suspended from a rigid wall by a spring with elastic constant K and shock absorber with damping factor D. (Fig. 1) If a time-dependent force F(t) acts on the mass, the equation of motion of its center of gravity is:</span></p>
<p><span class="font17">*</span></p>
<p><span class="font48"><a name="bookmark153"></a>H* ♦ D* ♦ K* * K F(t)</span></p><div>
<p><span class="font48">I</span></p>
<p><span class="font48">I I j</span></p>
<p><span class="font48">I II</span></p>
<p><span class="font48">•---«I</span></p>
<p><span class="font48">I I</span></p>
<p><span class="font48">I</span></p>
<p><span class="font48">___I___(</span></p></div><div>
<p><span class="font48">I /</span></p>
<p><span class="font18">/</span></p>
<p><span class="font48">mi* /</span></p>
<p><span class="font18">/</span></p>
<p><span class="font48">inn / I</span></p>
<p><span class="font48">•___I___</span></p></div>
<p><span class="font48">-I — I</span></p>
<p><span class="font48">V</span></p>
<p><span class="font48">F(T)</span></p>
<p><span class="font48">FIGURE 1&nbsp;THE MECHANICAL SYSTEM</span></p>
<p><span class="font48">* An electrodynamic system</span></p>
<p><span class="font48">A resistance R, a condensor with capacitance C and a coil of inductance L are wi red in series. (Fig. 2) When a time—dependent voltage U(t) is applied to the circuit, the charge q in the circuit is governed by the equation:</span></p>
<p><span class="font48">Lq ♦ Rq ♦ q/c = q/c U(t)</span></p>
<p><span class="font31"><a name="bookmark154"></a>c</span></p>
<p><span class="font48">I I I I I I</span></p><div>
<p><span class="font48">I 0</span></p>
<p><span class="font48">I</span></p>
<p><span class="font48">0 I</span></p></div><div>
<p><span class="font48">U(T)</span></p></div>
<p><span class="font48">I I I I</span></p>
<p><span class="font39" style="font-style:italic;">t</span><span class="font48"> I /1 /1 /1</span></p>
<p><span class="font48">•&nbsp;/ I / I / I / • 1/ 1/ 1/ 1/</span></p>
<p><span class="font48"><a name="bookmark155"></a>•&nbsp;I I I</span></p>
<p><span class="font48">L</span></p>
<p><span class="font48">THE ELECTRODYNAMIC SYSTEM</span></p><div>
<p><span class="font48" style="font-variant:small-caps;">figure 2</span></p></div>
<p><span class="font45" style="font-weight:bold;">• A mathematical system</span></p>
<p><span class="font45" style="font-weight:bold;">A differential equation of the form:</span></p>
<p><span class="font45" style="font-weight:bold;">Ax ♦ Bx ♦ Cx <a name="footnote2"></a><sup><a href="#bookmark156">2</a></sup> C D(t)</span></p>
<p><span class="font45" style="font-weight:bold;">can also be treated as a system. The variables stand for abstract system elements with certain properties, e.g. for real numbers. The relation between the abstract elements is reflected in the equation.</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark157"></a>mathematical&nbsp;mechanical&nbsp;electrodynamic</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark158"></a>system&nbsp;•&nbsp;system&nbsp;system</span></p><div>
<p><span class="font1">%</span></p></div>
<table border="1">
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">a</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">m</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">mass</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">l ;</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">inductance</span></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">b</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">d</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">damping factor</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">r</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">resistance</span></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">c</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">k</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">elastic constant</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1/c</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">reciprocal capacitance</span></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">d(t)</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">f(t)</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">force</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">u(t)</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">voltage</span></p></td></tr>
</table>
<p><span class="font52" style="font-variant:small-caps;">table 1&nbsp;correspondence table for the systems</span></p>
<p><span class="font48">Table 1 compares the three systems. If we regard parallel elements as counterparts<sub>f</sub> the three systems behave quantitatively a-like, or<sub>f</sub> in English, they mirror one another. How one system's quantities correspond to those in another, is given by a rule or function.</span></p>
<p><span class="font48">Since each system apes the remaining two, any one of them could be used to model the others. As a rule, the mathematical system would be used to study the two physical systems. It is nonetheless conceivable to solve the differential equation by studying one of the physical systems.</span></p>
<p><span class="font48">1.2.2 Types of Models Physical models:</span></p>
<p><span class="font48">The system's elements are all physical entities and the relationships between them are governed by physical laws. For example: <a name="bookmark159"></a></span><span class="font45" style="font-weight:bold;"><sup>9</sup> The structure of</span><span class="font48"> a</span><span class="font45" style="font-weight:bold;"> molecule is visualized using a model with vari-colored balls for the atoms and wires for the molecular bonds.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark160"></a>• A three-dimensional surface represented by a mathematical e-quation is modelled by a sculptured block of wood.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark161"></a>Mathematical or analytic models:&nbsp;*</span></p>
<p><span class="font45" style="font-weight:bold;">A system's behaviour is represented by a set of equations<sub>f </sub>usually differential, to which simultaneous solutions yield the sought results. Mathematical models are quite exact. They are especially well-suited for modelling static systems, such as the stress in a bridge. Their major drawback is that there may be no known solution to complex systems of equations. Stochastic systems can be studied mathematically only in simple cases based on standard distributions.</span></p>
<p><span class="font45" style="font-weight:bold;">Computer-simulation models:</span></p>
<p><span class="font45" style="font-weight:bold;">Simulation falls roughly in the middle between highly concrete models and highly abstract models, ^or discrete systems, it is close to physical models: the system's events are* &quot;played through' by the computer. For continuous systems, it adapts itself to mathematical models: the machine can solve obstinate systems of differential equations by brute force. Simulation's main advantages are that its models are easy to alter and that it can model very complex systems. Its disadvantages are the costs of programming and computer time.</span></p><div>
<p><span class="font48">ADVANTAGE</span></p></div>
<p><span class="font48">DISADVANTAGE</span></p><div>
<p><span class="font48">EASILY UNDERSTOOD</span></p></div><div>
<p><span class="font48">LIMITED APPLICATION</span></p></div><div>
<p><span class="font48">PHYSICAL MODEL</span></p></div>
<p><span class="font48">OFTEN NO KNOWN SOLUTION</span></p><div>
<p><span class="font48">EXACT RESULTS</span></p></div><div>
<p><span class="font48">ANALYTIC MODEL</span></p></div>
<p><span class="font48">HANDLES COMPLEX SYSTEMS</span></p><div>
<p><span class="font48">SIMULATION MODEL</span></p></div>
<p><span class="font48">LARGE IMPLEMENTATION EFFORT</span></p>
<p><span class="font48">MODELS EASILY ALTERED</span></p><div>
<p><span class="font48">TABLE</span><span class="font39" style="font-style:italic;"> 2</span></p></div>
<p><span class="font48">COMPARISON OF MODEL TYPES</span></p>
<p><span class="font48"><a name="bookmark162"></a>1*3 Simulation Languages</span></p>
<p><span class="font48"><a name="bookmark163"></a>In computer simulation, a model is described&nbsp;In the chosen</span></p>
<p><span class="font48"><a name="bookmark164"></a>simulation language. The language features are&nbsp;like an erector</span></p>
<p><span class="font48"><a name="bookmark165"></a>set or kit from which the pieces are attached to&nbsp;a chassis to form a model.</span></p>
<p><span class="font48"><a name="bookmark5"></a>1.3-1 Types of Languages</span></p>
<p><span class="font48">If it is to simulate systems adeptly, our erector set's parts should go together quickly and without bother. That means that each type of model demands its own, easily adapted simulation language. A classification of simulation languages will correspond therefore to our classification of systems in 1.1.2.</span></p>
<p><span class="font48">Since it models a system's changes, simulation is useless for investigating static systems; its languages are fit to describe only dynamic systems. Dynamic systems usually have at least some random parameters, so most languages come equipped to build both stochastic and deterministic models.</span></p>
<p><span class="font48">Continuous and discrete systems are modelled using disparate methods. Continuous systems are usually described by systems of differential equations. A language equipped to simulate them must come armed with some means of describing continuous state transitions and tools for solving differential equations. DYNAMO (Pugh, 1963) and CSMP (IBM, 1967) are probably the best known languages of that type.</span></p>
<p><span class="font48">In discrete systems, the state changes occur in single, discontinuous steps. Languages designed to simulate them must offer features that change the model's state at the appropriate moments. Some examples are GPSS, GPSS-F, GASP, SIMSCRIPT and SIMULA. Among them, there are those (like GPSS) that model transaction-oriented systems and those (like GASP) that model event-oriented systems.</span></p>
<p><span class="font48">1.3.2 Model Formulation and Range of Application</span></p>
<p><span class="font48">The two criteria that judge a simulation language are:</span></p>
<p><span class="font48">a)&nbsp;How easily are its models built?</span></p>
<p><span class="font48">b)&nbsp;How broadly can it be applied?</span></p>
<p><span class="font45" style="font-weight:bold;">Our erector-set image shows that the criteria often clash. If the erector set's parts are mostly prefabricated, criterion a) is satisfied and the model goes together without any trouble. But prefabricated parts adapt themselves mainly to prefabricated ideas. Details may be difficult to represent accurately and special desires cannot be satisfied. In short, the erector set is inflexible.</span></p>
<p><span class="font45" style="font-weight:bold;">If the erector set's parts are small enough to show every manner of detail, model building is tedious and expensive. Moreover, modelling blunders are more likely. In that case, criterion b) is satisfied, but not a).</span></p>
<p><span class="font45" style="font-weight:bold;">Graphing ease-of-use roughly against generality-of-applleation</span></p>
<p><span class="font48">for several common languages, we get (according to (3)) the arrangement shown in figure 3.</span></p>
<p><span class="font48">It 1s of course possible to model with the usual high-level programming languages, such as FORTRAN, ALGOL, or PL/I. A programmer can embellish his models with almost any refinement; the only bounds are set by his muse and his language. But modelling in those languages is herculean work. They are a last resort when there is no adequate ready-made language.</span></p>
<p><span class="font48">A</span></p>
<p><span class="font48">E|&nbsp;• CPSS-FORTRAN</span></p>
<p><span class="font48">A|</span></p>
<p><span class="font48">S|&nbsp;• DYNAMO</span></p>
<p><span class="font48">II</span></p>
<p><span class="font48">I .&nbsp;• CSMP</span></p>
<p><span class="font48">I</span></p>
<p><span class="font48">• GPSS</span></p>
<p><span class="font48">I I I I</span></p>
<p><span class="font48">|&nbsp;• SIMSCRIPT</span></p>
<p><span class="font48">|&nbsp;• SIMULA</span></p>
<p><span class="font48">• GASP</span></p>
<p><span class="font48">I</span></p>
<p><span class="font48">S|&nbsp;• HIGH-LEVEL PROGRAMMING</span></p>
<p><span class="font48">E|&nbsp;LANGUAGES</span></p>
<p><span class="font48">RANGE OF APPLICATION&nbsp;GENERAL</span></p>
<p><span class="font52" style="font-variant:small-caps;">figure 3&nbsp;overview of common simulation languages</span></p>
<p><span class="font48">1.1 The Program Package GPSS-F</span></p>
<p><span class="font48">GPSS-F is a Fortran package that simulates discrete systems, whether stochastic or deterministic, whether transaction-oriented or event-oriented. This book emphasizes the stochastic and transaction-oriented and assumes that the reader can think his own way through the other, related cases.</span></p>
<p><span class="font48">1.1.1 Model Construction and Range of Application for GPSS-F</span></p>
<p><span class="font48">The simulator was developed expressly to meet the clashing criteria of 1.3.2. First, model construction was to be especially easy. GPSS-F consists of a pre-vritten main program, the chassis, and pre-written subroutines, the model-building modules. A model is built by attaching subroutine calls to the chassis. The pre-</span></p>
<p><span class="font48">written modules embody all important and often-used system elements. So CPSS-F satisfies the first criterion<a name="footnote3"></a><sup><a href="#bookmark166">3</a></sup></span></p>
<p><span class="font48">It satisfies the second by being easy to modify. Any Fortran programmer can learn how the simulator works; its structures a simple and clear. Whenever GPSS-F lacks a needed feature» it can be added without trouble» usually by writing a short subroutine to add to the stock of modules. As a result» GPSS-F takes a special place among simulation languages (see figure 3 again)«</span></p>
<p><span class="font48">1*4.2 A System's Elements and Functions</span></p>
<p><span class="font48">All elements and functions that occur in discrete systems can be classified into four categories. They are described briefly here and explained in detail in the chapters referred to in the headings:</span></p>
<p><span class="font48">•&nbsp;Queue processing (Chapter 3)</span></p>
<p><span class="font48">If a station cannot, for the moment, process newly arriving tasks, they queue up to wait on it.. (Tasks are to systems what transactions are to models.) When the station is ready again, one of the waiting tasks must be chosen from the queue to be pro-cessed. A procedure for selecting the next waiting task is cabled a policy.</span></p>
<p><span class="font48">Systems-analytic research has shown that any complex policy can be constructed from two elementary mechanisms: preemption and priority management. GPSS-F provides for both. Furthermore, each queue may be assigned its own specific policy, two of which are available as pre-written subroutines: 'Selection According to Priority' and 'First In, First Out'.</span></p>
<p><span class="font48">•&nbsp;Acquiring and freeing storage space (Chapter 6)</span></p>
<p><span class="font48">A storage is a station that accomodates tasks according to its capacity and their demands for space. Each arriving task requests a certain amount of space in the storage. A warehouse or a parking lot is a storage, since each incoming ware or car takes up some of the storage's available space. The loading up of storage is called its allocation; its unloading is called freeing.</span></p>
<p><span class="font48">Procedures called strategies are used to decide which of a storage's locations to load or unload. When an arriving task requests space in a storage, an allocation strategy assigns the space according to a specific rule. When a storage is unloaded, a freeing strategy must decide which spaces are to be freed, if the unloading request doesn't specify uniquely which items are to be removed.</span></p>
<p><span class="font48">Any technique for managing storage can be set up, if account is kept of the occupied locations and if strategies are available to allocate and free the storage's space. Again, GPSS-F provides for both. First, it keeps track automatically of the positions and contents of filled storage spaces. Second, it permits each storage to be assigned its own strategies. In addition, it provides two pre-written loading strategies: first-fit and best-fit.</span></p>
<p><span class="font48">•&nbsp;Coordinating tasks (Chapter ?)</span></p>
<p><span class="font48">The two mechanisms *Branch on Condition* and 'Wait on Condition* suffice to coordinate the movement of tasks through a dis-fO</span></p>
<p><span class="font48">Crete ays tea. One speaks of 'branching on condition'» in case a task can be sent to one of various stations, depending on the system's state. 'Waiting on condition' Beans that tasks can be held at some point<sub>f</sub> until the system's state changes to meet specific conditions.</span></p>
<p><span class="font48">In GPSS-F, tasks can branch or wait at any point in the model. The user specifies the condition under which branching or waiting occurs by means of a logical expression. Hence any coordination procedure can be specified without trouble»</span></p>
<p><span class="font48">* Denoting families of tasks (Chapter 8)</span></p>
<p><span class="font48">Tasks may belong to a family; they preserve their identity although they carry markers that show their family membership. Families are especially useful, when tasks running through a processing path must be handled differently from one another<sub>9</sub> depending on their properties.</span></p>
<p><span class="font48">1.4.3 Application Examples</span></p>
<p><span class="font48">GPSS-F can be put to a variety of uses. As a spur to imagination, some typical ones are listed below:</span></p>
<p><span class="font3">•</span></p>
<p><span class="font48">*&nbsp;Transportation planning</span></p>
<p><span class="font48">Planning of railroad stations, port facilities<sub>9</sub> airports, parking lots</span></p>
<p><span class="font48">Design of urban transportation systems Timetable production Traffic-light control</span></p>
<p><span class="font48">*&nbsp;Operations research Company modelling</span></p>
<p><span class="font48">Production planning, investment planning Scheduling and cost planning for projects Profitability studies Production control Stock control</span></p>
<p><span class="font48">Optimal workshop layout for a given job profile</span></p>
<p><span class="font48">*&nbsp;Administration Macroeconomic planning</span></p>
<p><span class="font48">Planning of schools, hospitals and universities Capacity studies</span></p>
<p><span class="font48">*&nbsp;Data processing</span></p>
<p><span class="font48">Planning computing installations</span></p>
<p><span class="font48">Planning operating procedures in a computer center Operating-systems design Computer-installation configuration -</span></p>
<p><span class="font45" style="font-weight:bold;">The sequence of steps taken to build a model depends on the problem being investigated« Nonetheless, a few broad points are fairly problem-independent; they belong to the development of nearly every model. Figure 4 shows them as a standard flow chart for modelling.</span></p>
<p><span class="font45" style="font-weight:bold;">First, the system is analyzed and its model designed and built. Then the model is tested to see how accurately it replicates the system. Finally, when it is a good likeness, the replica is used to study the original. For use in planning, say, one of the model's features would be altered to see how the system would react, if it were altered in the same way.</span></p>
<p><span class="font48">1.5*1 Analyzing a System</span></p>
<p><span class="font45" style="font-weight:bold;">The first step is to analyze the system carefully. After it has been classified roughly, the system's components are identified, along with their private parameters. Finally, the relational parameters are identified.</span></p>
<p><span class="font45" style="font-weight:bold;">Once the system's parameters have been found, they must be assigned actual values. This is relatively easy when their values are simple constants, but parameters are often random variables of unknown behaviour. If so, their customs and habits must be studied where they run wild: in the system itself. If the system is hostile to study, we satisfy ourselves with reasonable assumptions concerning its random variables. *</span></p>
<p><span class="font45" style="font-weight:bold;">It is advisable to analyse the system as much as possible without considering model construction. The analysis must be objective and neutral and it should not be restricted prematurely by model-building considerations.</span></p>
<p><span class="font45" style="font-weight:bold;">A system is modelled to solve a specific problem or to answer a clear question, whose nature guides most aspects of the system's analysis. The question to be answered determines, for example, which of the model's parameters will be varied and which will be studied. Then we study the model, setting the former to see what effect they have on the latter.</span></p>
<p><span class="font45" style="font-weight:bold;">Finally, we measure the model's performance for different parameter settings. Our measure or evaluation is a function of the parameters we choose to study and it specifies, perhaps with numerical precision, how pleased we would be to have the real system behave likewise. If several goals are to be pursued, not all with the same intensity, we choose an evaluating function that weights each goal according to its importance.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">* We want to Investigate how to serve the cars faster at a highway gas station. The improvements * costs are not to exceed some fixed limit. This system is clearly discrete, stochastic and transaction-oriented. Its components are the cars, the gas pumps, the station attendants and the cash register. Their private parameters are:</span></p>
<p><span class="font48">Mean arrival rate</span></p>
<p><span class="font48">Gasoline required</span></p>
<p><span class="font48">Flow rate in gallons per minute</span></p>
<p><span class="font48">Mean service time per car</span></p>
<p><span class="font48">Mean service time per car</span></p><div>
<p><span class="font48">Cars</span></p>
<p><span class="font48">Pumps</span></p>
<p><span class="font48">Attendants Cash register</span></p></div>
<p><span class="font48">Not counting the pump rate<sub>9</sub> which is constant, the parameters are all random variables whose behaviour has to be found by studying the gas station. The relational parameters specify spatial and temporal relations between the system's components.</span></p>
<p><span class="font48">The problem to be solved determines which values we shall want to study. Since the goal is to serve cars faster, a good choice would be to study the mean queue length at the pump. Or we could study the cars' mean waiting times, instead. The model is then used to find alterations to the system that minimize those parameters under various assumptions.</span></p>
<p><span class="font48">The parameters that can be altered are the number and layout of the pumps as well as their flow rate, the number of attendants, and the number of cash registers. We could study the effect,^ say, of substituting faster pumps merely by increasing the pumps' flow-rate parameter. The performance measure reflects the relative importance of reduced waiting times versus the cost of achieving it. The model might show that the faster pumps, do the job, but an additional slow pump has the same effect at half the cost.</span></p>
<p><span class="font48">A system's analysis is complete when the following have been determined:</span></p>
<p><span class="font48">*&nbsp;System's type</span></p>
<p><span class="font48"><sup>11</sup> System's components with private and relational parameters</span></p>
<p><span class="font48">*&nbsp;Problem formulation that specifies which parameters are to be altered and which to be studied</span></p>
<p><span class="font48">*&nbsp;Performance measure</span></p>
<p><span class="font48">1.5.2 Building a Model</span></p>
<p><span class="font48">The choice of simulation language determines a model's construction. It helps immensely to find a language adapted to the system and general enough to represent all wanted detail. Time spent selecting the right language is rarely lost. It is won back when the model is easier to build than it would have been using the wrong language.</span></p>
<p><span class="font48">How faithfully should a model reflect the modelled system? Replicating the system exactly is neither possible nor necessary. Precisely those system components have to be found that are relevant to the study. We can ignore all details whose inclusion would alter the results inessentially.</span></p>
<p><span class="font48">Improving a model's faithfulness inflates the effort to build it. The added effort includes computer time, memory requirements, programming time and testing time. Some effort is, of course, always required if the model is to reflect important aspects of the</span></p>
<p><span class="font48">But every far-reaching improvement demands that added ef-</span></p>
<p><span class="font48">fM**b* justified.</span></p><div>
<p><span class="font19">&lt;---</span></p></div>
<p><span class="font48">ANALYZE</span></p>
<p><span class="font48">THE SYSTEM</span></p><div>
<p><span class="font8">—&gt;</span></p></div>
<p><span class="font48">DESIGN AND</span></p>
<p><span class="font48">DEVELOP ITS MODEL</span></p><div><img src="Untitled.FR10_files/Untitled.FR10-3.jpg" style="width:187pt;height:246pt;"/></div><div>
<p><span class="font4">—&gt;</span></p></div>
<p><span class="font48" style="font-variant:small-caps;"><a name="bookmark167"></a>analyze</span></p>
<p><span class="font48" style="font-variant:small-caps;"><a name="bookmark168"></a>the results</span></p><div>
<p><span class="font48" style="font-variant:small-caps;">figure i</span></p></div>
<p><span class="font48" style="font-variant:small-caps;"><a name="bookmark169"></a>flow diagram for building models</span></p>
<p><span class="font48">A simulation model should be built along the same principles as any large or complex program system. Constructing the model from modules, keeping them understandable and building in test aids are excellent principles to follow.</span></p>
<p><span class="font48">1.5.3 Testing a Model</span></p>
<p><span class="font48">After a model is built, someone must test how well it reflects the modelled system. Of course, programming bugs falsify the replica. More important mistakes are a falsely analyzed system or a botched model. Other worries surround the parameters. Maybe we overlooked an essential one or assigned it the wrong value or mistook its relationship to the other essential parameter we forgot to include.</span></p>
<p><span class="font52" style="font-variant:small-caps;">a</span><span class="font48"> simulation model is often tested by comparing the results of a simulation with measurements taken from the system itself. This procedure presumes, of course, that the system already exists and that measurements are practical. If the model reflects the system accurately for the cases compared, we boldly assume the model's correctness in all remaining cases.</span></p>
<p><span class="font52" style="font-variant:small-caps;">a</span><span class="font48"> simulation model can sometimes be tested by comparing it with a mathematical model. From concurring results, ~we ponclude, as before, that the model also functions correctly in cases too complex to handle mathematically. This procedure's disadvantage is that it doesn't uncover any systems-analysis blunders, furthermore, if the analytic model uses approximation techniques, it isn't clear whether differing results convict the model or the approximation methods of error.</span></p>
<p><span class="font48">1.5.4 Using a Model</span></p>
<p><span class="font48">How a computer simulation is used to study a system should be clear from the gas-station example. Here we mention two problems specific to the use of certain stochastic models. The problems are discussed more thoroughly in (8).</span></p>
<p><span class="font48">Computer simulations of stochastic systems yield reliable results only after they have run for a certain time; analytic models yield exact results immediately, even for values dependent on random variables such as mean queue-length or mean serving time. To find mean values using a simulation model, the model is examined from time to time and the observations collected and analyzed .</span></p>
<p><span class="font48">For stationary sytems (systems in which the mean values are time-independent, i.e. constant), that is done by running the simulation and collecting the values of its random parameters, say queue length, at regular intervals. The law of large numbers insures that, despite statistical variation, the model's mean values will eventually approach the system's. If we observe the model and. plot the mean values of its random variables against time, we can see how they fluctuate and how the fluctuations die down, approaching the sought value.</span></p>
<p><span class="font48">A system is called non-stationary, if the mean values of its parameters, e.g. mean queue-length, are non-constant functions of</span></p>
<p><span class="font48">time. Suppose we seek the mean value of such a parameter. We cannot exclude statistical ^Variation from the results by running the model just once| but long enough that the law of large numbers assures that the observed mean approaches the actual mean. Since the mean is a function of time<sub>9</sub> there is no single, constant value for the observed mean to approach« The mean values of non-sta-tionary systems can be found only by running the model repeatedly until the observed values from the various simulation runs begin to converge to a single function. This method is so expensive for complex systems, that it restricts modelling by simulation severely.</span></p>
<p><span class="font48">If the conditions at the start of a simulation differ from the system's normal operating conditions, the model will fluctuate in ways that don't mirror the system until it reaches its normal, full-swing phase. There are two possibilities for avoiding spurious results due to the fluctuations of a model's startup.</span></p>
<p><span class="font48">First, we could start the model up in full swing. This would require pre— filling the queues and pre-assigning transactions to stations. The procedure requires extremely good knowledge of the system. Second, we could let the raôdel run through its startup phase, then start collecting data only after the startup fluctuations have settled down.</span></p>
<p><span class="font48">It is very difficult to determine exactly when the startup phase is over, since the startup fluctuations are hard to distinguish from normal statistical variation. In such cases, all systems, including stationary ones, must be treated in</span><span class="font45" style="font-weight:bold;font-style:italic;"> the</span><span class="font48"> initial phase as non-stationary.</span></p>
<p><span class="font48">1.5.5 Analyzing Results</span></p>
<p><span class="font48">Probability theory and statistics provide important tools for reducing and interpreting the results of a simulation. These fields are too broad to be handled here; the interested reader should consult the bibliography for recommended texts (e.g. (8)). If simulation is used for systems optimization, operations research offers additional tools for analyzing the results and for making it easier to optimize the system. Again, the interested reader is refered to the bibliography.</span></p>
<p><span class="font48">1.6 Simulating Discrete Systems</span></p>
<p><span class="font48">Discrete systems are modelled by means of a simple procedure, described below, which we refer to as flow management. Certain details of the description pertain GPSS-F's flow management, but the techniques used to process any discrete system are roughly the same.</span></p>
<p><span class="font48">Since we restrict ourselves to discrete systems, we can assume that the system goes from one state to another at definite times. This state change or transition occurs in that the values of the system's parameters change at those times.</span></p>
<p><span class="font48">Computer simulation immitates such processes. It sets up data areas corresponding to each of the system's elements. At specific</span></p>
<p><span class="font48">moments, indicated by the simulation clock» the simulator modifies the data areas, thereby mimicking a state change«</span></p>
<p><span class="font48">Plow management's job is to Insure that state changes occur at the prescribed times and in prescribed sequence. It has a list that specifies the time when each particular state change must occur. When the simulator clock reaches a time shown in flow management's list» it jumps to the section of the simulator program that effects the required change.</span></p>
<p><span class="font48">There are thus four simulator components» which work in tandem:</span></p>
<p><span class="font48">a Data areas for the system eleanents</span></p>
<p><span class="font48">The data areas specify the state of the system.</span></p>
<p><span class="font48">*&nbsp;The simulation program</span></p>
<p><span class="font48">The simulation program consists of various program parts that effect state changes by altering the data areas; each program part can be executed independently of the others.</span></p>
<p><span class="font48">*&nbsp;Flow manageaent</span></p>
<p><span class="font48">Flow management has a list available to it that specifies which program part is to be executed and at what time.</span></p>
<p><span class="font48">*&nbsp;The simulation clock</span></p>
<p><span class="font48">The simulation clock specifies the simulation time. Flow management consults it» in order to know when it has become time to carry out a state change in its list.</span></p>
<p><span class="font48">1.6.1 Bank-Window Model</span></p>
<p><span class="font48">An extremely simple model» built using GPSS-F, will show how discrete systems are simulated. The system consists of a bank window and customers. A detailed description of the bank-window model is given in section 11.1.</span></p>
<p><span class="font48">Starting at 8:00» a customer arrives at the window every 5 minutes. If the window is free, the customer can be served immediately. Serving time is exactly 6 minutes. If a customer is already at the window, an arriving customer waits in line, i.e. he queues up. Obviously, the first customer is the only one who won't have to wait and the line will grow longer and longer as the day wears on.</span></p>
<p><span class="font48">We shall represent the window, the system's only stationary element, by a facility. A facility is a GPSS-F station that serves just one customer at a time. Our facility can be in exactly one of two states: occupied (processing a customer) or free (ready to process the next</span><span class="font45" style="font-weight:bold;"> customer)</span><span class="font48"> . The transitions from one of those states to the other are the only state changes the facility can undergo.</span></p>
<p><span class="font48">The customers, the system's mobile elements, will be represented by transactions. When a customer steps up to the window to be served, we will say, in terms of the model, a transaction has acquired the facility; when he leaves the window, we will say the transaction has freed the facility.</span></p>
<p><span class="font48">| A TRANSACTION IS GENERATED j EVERY 5 MINUTES</span></p>
<p><span class="font48">I I</span></p>
<p><span class="font48">I</span></p>
<p><span class="font47">| THE TRANSACTION ACOUIRES THE j FACILITY. IT QUEUES UP AT j THE FACILITY IF THE FACILITY I IS OCCUPIED</span></p>
<p><span class="font48">I</span></p>
<p><span class="font47">| THE TRANSACTION SPENDS 6 j MINUTES AT THE FACILITY BEING SERVED</span></p>
<p><span class="font48">I</span></p>
<p><span class="font47">I THE TRANSACTION FREES THE</span></p>
<p><span class="font47">I FACILITY</span></p>
<p><span class="font48">I I</span></p>
<p><span class="font48">I</span></p>
<p><span class="font47">I THE TRANSACTION IS I ANNIHILATED</span></p>
<p><span class="font48">I I</span></p><div>
<p><span class="font45" style="font-weight:bold;">TOC* ryöilHNN» H «ajr*w*-r*iiJ« </span><span class="font48">6M0/IMOT?:* CGCP</span></p>
<p><span class="font45" style="font-weight:bold;">9HO* tftjtup SHT/Jlt&gt;i:cro Jâ/IA</span></p></div><div><img src="Untitled.FR10_files/Untitled.FR10-4.jpg" style="width:85pt;height:46pt;"/></div>
<p><span class="font47">TRANSACTION'S FLOW THROUGH THE BANK-WINDOW MODEL</span></p>
<p><span class="font48">From the system's point of view, a customer comes into existence for the first time when he enters the bank; everything he ever did up to that moment is irrelevant to the simulated system. Thus customers are created when they enter the system, or in terms of the model, transactions are generated. A transaction is generated by a station called a source. In our system, the source can be thought of as the bank's door. Once they have left the system, the customers' further activities can again be ignored, so the transactions used to represent them can be annihilated. A single transaction's progress through the system is diagrammed in figure 5.</span></p>
<p><span class="font48">For the purposes of this example, each transaction is, at any given time, in exactly one of three states: active, scheduled to be active, or waiting. A transaction can</span><span class="font45" style="font-weight:bold;"> pass</span><span class="font48"> from one block in</span></p><div>
<p><span class="font47">FIGURE 5</span></p></div>
<p><span class="font48">figure 5 to the next only when It la active. A transaction is generated active, so that it passes over to the second block. There, it either acquires the facility and proceeds to the third block or it queues up to the facility. While a transaction is queued up at the facility, it is waiting; when it reaches the head of the queue, it becomes active in order to acquire the facility and to proceed to the next block. As soon as it acquires the facility and begins being served, it is scheduled to be acti-* vated again in six minutes. Six simulated minutes later, it frees the facility and is annihilated. In terms of state changes, the first transaction's boring biography between generation and annihilation is: active, scheduled, active; for all remaining transactions it will be the more blood-stirring: active, waiting, active, scheduled, active.</span></p>
<p><span class="font48">The state changes in a GPSS-F model are undertaken by GPSS-F subroutines. We shall understand 'state change' in a broad sense in which a number of parameters could be altered together to make one (complex) state change. The simulation program describing our model consists of sequences of subroutine calls, each of which effects a particular type of state change. The statement at the head of each sequence is given a statement number, so that flow management has the means to jump to any state change. The statement numbers serve as targets labelling the simulation program's sections.</span></p>
<p><span class="font48">Flow management's list, from which it decides which program part to execute and when, is a list of targets (i.e. statement numbers) paired with state-change times; when the simulator clock reaches a time in the list, flow management jumps to the statement sequence whose target is paired with that time. At the end of the sequence, when the simulation program has carried out all necessary state changes, it returns to flow management. When the clock reaches the next time in the list, the procedure starts over again. In this way, flow management undertakes each state change at the proper time.</span></p>
<p><span class="font45" style="font-weight:bold;">The simulator clock shows simulated time and it is incremented in discrete time units. In the bank-window model, each time unit will correspond to one minute.</span></p>
<p><span class="font45" style="font-weight:bold;">Note that there are three kinds of time used in talking about models: the machine time in which the</span><span class="font48" style="font-variant:small-caps;"> gpss-f</span><span class="font45" style="font-weight:bold;"> model runs, the time shown on the simulation clock and the system time it simulates. In machine time, for example, only one transaction at a time is ever active. Thus we can speak, without confusion, of the active transaction. In simulated time, several transactions may be active simultaneously. That state is simulated by leaving the simulator clock constant and activating the transactions one after the other.-</span></p>
<p><span class="font45" style="font-weight:bold;">The GPSS</span><span class="font48" style="font-variant:small-caps;">-f</span><span class="font45" style="font-weight:bold;"> subroutines to be used in the bank-window model correspond one-to-one to the blocks in figure 5. They have the following functions:</span></p>
<p><span class="font48">•&nbsp;GENERA</span></p>
<p><span class="font48">When GENERA is called, it generates an active transaction. A transaction is considered generated when GENERA has aoqulred</span><span class="font50" style="font-weight:bold;"> a </span><span class="font48">line for it in the transactions' data area, and filled in its initial parameters. It is considered active when a GPSS-F subroutine sets an internal variable (LTX) to show that it is active. A transaction is represented exclusively by its entry in the transactions' data area; the entry &quot;is&quot; the transaction.</span></p>
<p><span class="font48">Each time it generates a transaction, GENERA schedules Itself to be called again to generate the next transaction. It does that by entering a new generation time and its own statement number as target in flow management's list. The new generation time is relative to the present simulated time; it is calculated from GENERA's argument ET, as follows:</span></p>
<p><span class="font48">New&nbsp;Present&nbsp;ET, that is, ellapsed</span></p>
<p><span class="font48">generation s simulator&nbsp;+ time until next</span></p>
<p><span class="font48">time&nbsp;clock time&nbsp;transaction generation</span></p>
<p><span class="font48">Since GENERA always generates a transaction for a particular source, it modifies both the sources' and the transactions' data areas.</span></p>
<p><span class="font48">Normally, GENERA returns control to the statement following it. (That isn't true of every GPSS-F subroutine; some of them sometimes return control directly to flow management.) After return from GENERA, execution continues with the next statement in the simulation program.</span></p>
<p><span class="font48">•&nbsp;SEIZE</span></p>
<p><span class="font48">The SEIZE subroutine administers the facility. If the facility is free, SEIZE changes its state to occupied; the currently active transaction acquires the facility. If the facility is already occupied, the active transaction is placed in the wait state in the facility's wait queue. Thus SEIZE changes either the facility's state from free to occupied, or the transaction's from active to waiting, but not both.</span></p>
<p><span class="font48">The SEIZE subroutine requires the facility's data area, in order to determine whether it is occupied or free and, if need be, in order to change the facility's state. SEIZE also requires the active transaction's data area in order to show, roughly speaking, its position in the queue.</span></p>
<p><span class="font48">If the active transaction acquires the facility, it remains active and SEIZE returns control to the statement following the call. If SEIZE puts the transaction in the wait state, the transaction can proceed no further; hence SEIZE returns control to flow management. In this case execution does not continue with the next statement in the program.</span></p>
<p><span class="font48">its way by being re-activated.</span></p>
<p><span class="font48">WORK schedules the transaction's re-activation by entering an activation time and its own statement number in flow management's list. When it is re-activated, flow management will Jump back to the CALL WORK statement that scheduled the re-activation; this time WORK recognizes the returning transaction and doesn't reschedule it.</span></p>
<p><span class="font48">WORK schedules a transaction to be re-activated at a time computed as follows from its argument WT:</span></p>
<p><span class="font48">New&nbsp;Present&nbsp;WT, that is, serving</span></p>
<p><span class="font48">activation <a name="footnote4"></a><sup><a href="#bookmark170">4</a></sup> simulator&nbsp;+ (working) time for the</span></p>
<p><span class="font48">time&nbsp;clock time&nbsp;transaction</span></p>
<p><span class="font48">The statement number that WORK enters as target in the list is given by its parameter, ID. In our model, WORK schedules the transaction to be re-activated in 6 minutes (WT s 6) and specifies that WORK is to be called again at that time (ID ? WORK CALL's statement number).</span></p>
<p><span class="font48">When it schedules a transaction to be re-activated, WORK returns control to flow management. When it is called the second time, it recognizes the transaction that has just been served and returns control to the statement following the call.</span></p>
<p><span class="font48">•&nbsp;CLEAR</span></p>
<p><span class="font48">This subroutine frees a facility by clearing the &quot;occupied&quot; code from the facility's data area. After a call to CLEAR, execution resumes with the following statement.</span></p>
<p><span class="font48">•&nbsp;TERMIN</span></p>
<p><span class="font48">TERMIN obliterates a transaction from the system by clearing its data area. It returns control to flow management.</span></p>
<p><span class="font48">The simulation program built from these subroutines to simulate the bank-window system is shown in figures 6 and 7 for two clock times. The interaction of the simulator clock, flow management and the simulation program are described more closely in the next section.</span></p>
<p><span class="font48">1.6.2 Simulation Flow</span></p>
<p><span class="font48">Flow management has a subroutine that searches its list for the earliest state change to be carried out. Then it sets the simulator's clock ahead to that time by transferring the value it finds to the variable</span><span class="font48" style="font-variant:small-caps;"> t,</span><span class="font48"> which is the clock. Associated with that earliest state-change time, it finds a target that shows which program part undertakes the state change now to take place. Flow management then jumps to that statement number and the designated program part undertakes the requisite state change.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">• In figure 6, the simulation clock shows time T = 11. GENERA</span><span class="font45" style="font-weight:bold;"> is </span><span class="font48">now supposed to generate a transaction, since the first customer appeared at the bank at time T = 1 and our model assumes that</span></p>
<p><span class="font48">customers arrive every.five minutes. Thus the target&nbsp;'1* appears in the list associated with activation time</span><span class="font52" style="font-variant:small-caps;"> t s</span><span class="font48"> 11. After advancing the clock to</span><span class="font52" style="font-variant:small-caps;"> t *</span><span class="font48"> 11, flow management jumps to statement number 1.</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark171"></a>simulator Clock t</span></p>
<p><span class="font48">I ii l&lt;</span></p>
<p><span class="font52" style="font-variant:small-caps;">flow management's list</span></p>
<p><span class="font52" style="font-variant:small-caps;">target state-chg stmt. time</span></p>
<p><span class="font48" style="font-variant:small-caps;"><a name="bookmark172"></a>ï~s t î3 t</span></p>
<p><span class="font48"><a name="bookmark173"></a>«•I 1 I 11 I»»</span></p>
<p><span class="font48" style="font-variant:small-caps;"><a name="bookmark174"></a>î t t</span></p>
<p><span class="font52" style="font-variant:small-caps;">data areas for the system elements</span></p>
<p><span class="font45" style="font-weight:bold;">I I I I I I I I</span></p>
<p><span class="font52" style="font-variant:small-caps;">source data area transaction data area</span></p><div>
<p><span class="font48">I I</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;">VI &lt;</span></p>
<p><span class="font48">I I</span></p>
<p><span class="font48">K«</span></p></div>
<p><span class="font52" style="font-variant:small-caps;">simulation program</span></p>
<p><span class="font48">CALL GENERA ( ET s 5 ) CALL SEIZE</span></p>
<p><span class="font48">CALL WORK ( WT = 6 , ID : 3) CALL CLEAR CALL TERMIN</span></p><div>
<p><span class="font52" style="font-variant:small-caps;">statement number</span></p>
<p><span class="font48">1 </span><span class="font30">2 </span><span class="font48">3</span></p></div>
<p><span class="font52" style="font-variant:small-caps;">the simulation model at time ts 11</span></p>
<p><span class="font45" style="font-weight:bold;">The system's progress is reflected by undertaking state changes one after the other. For each scheduled state change, a time and target appear In flow management's li3t. Flow management assures correct state-change sequencing by searching its list and selecting state changes in chronological order.</span></p>
<p><span class="font48">Example:</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 6</span></p></div>
<p><span class="font45" style="font-weight:bold;">• In figure 6, the simulation clock shows T = 11, at which time a transaction i3 generated. The next time at which a state change is to take place is T s 13. Hence, after the generation scheduled for T s 11 has been carried out, the simulation clock is advanced from 11 to 13. The new state is shown In figure 7.</span></p>
<p><span class="font45" style="font-weight:bold;">Flow management's list must be primed by the user, i.e. he</span></p>
<p><span class="font48"><a name="bookmark175"></a>■ust enter the tine and target for the very first 'state cha into flow management's list.&nbsp;<sup>nge</sup></span></p>
<p><span class="font47"><a name="bookmark176"></a>SIMULATOR CLOCK T</span></p>
<p><span class="font48"><a name="bookmark177"></a>I 13 !&lt;•••••«••</span></p>
<p><span class="font25" style="font-weight:bold;"><a name="bookmark178"></a>....... •</span></p>
<p><span class="font60" style="font-weight:bold;"><a name="bookmark179"></a>•</span></p>
<p><span class="font47"><a name="bookmark180"></a>FLOW MANAGEMENT'S«</span></p>
<p><span class="font47"><a name="bookmark181"></a>LIST&nbsp;•</span></p>
<p><span class="font20">•</span></p>
<p><span class="font47"><a name="bookmark182"></a>TARGET STATE-CHG • STMT. TIME&nbsp;•</span></p>
<p><span class="font48"><a name="bookmark183"></a>••I 3 I 13 I»»»</span></p>
<p><span class="font47"><a name="bookmark184"></a>™T ï îê T</span></p>
<p><span class="font48"><a name="bookmark185"></a>. j J</span></p>
<p><span class="font52" style="font-variant:small-caps;">statement number</span></p>
<p><span class="font46" style="font-weight:bold;">1 </span><span class="font18" style="font-weight:bold;">2 </span><span class="font48">3</span></p>
<p><span class="font48"><a name="bookmark186"></a>DATA AREAS FOR THE</span></p>
<p><span class="font48">SYSTEM ELEMENTS</span></p>
<p><span class="font26" style="font-weight:bold;"><a name="bookmark187"></a>.... ............... ..........</span></p>
<p><span class="font47"><a name="bookmark188"></a>ï &quot;\ ï rTTTTTT'î</span></p>
<p><span class="font48"><a href="#bookmark189">| FACILITY DATA AREA&nbsp;|&lt;&quot;</a></span></p>
<p><span class="font48">| TRANSACTION DATA AREA ~ |&lt;••</span></p>
<p><span class="font60" style="font-weight:bold;"><a name="bookmark190"></a>•</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a href="#bookmark191">simulation&nbsp;•</a></span></p>
<p><span class="font52" style="font-variant:small-caps;"><a href="#bookmark192">program&nbsp;•</a></span></p>
<p><span class="font60" style="font-weight:bold;"><a name="bookmark193"></a>•</span></p>
<p><span class="font48"><a href="#bookmark194">CALL GENERA ( ET = 5 )&nbsp;•</a></span></p>
<p><span class="font48"><a href="#bookmark195">CALL SEIZE&nbsp;•</a></span></p>
<p><span class="font48">CALL WORK ( WT s 6&nbsp;, ID s 3 ) »</span></p>
<p><span class="font48"><a name="bookmark196"></a>CALL CLEAR&nbsp;••••••</span></p>
<p><span class="font52" style="font-variant:small-caps;">call termin&nbsp;•••»•»</span></p>
<p><span class="font48">THE SIMULATION MODEL AT TIME T s 13</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">• In our model, priming . flow management's list consists of scheduling the first transaction generation. The user primes the list at the start of simulation by entering time T s 1 and GENERA's statement number as target. Now that the first state change has been scheduled, he passes control to flow management.</span></p>
<p><span class="font48">Each time flow management uses an entry in its list to initiate a scheduled state change, it erases that entry. In our example, at the start of simulation, there is only one scheduled state change (the first transaction generation). When flow management clears that entry and jumps to GENERA, its list is empty. But before it returns control to flow management, the model schedules new state changes, so that the simulator doesn't run out of things to do.</span></p><div>
<p><span class="font48">FIGURE 7</span></p></div>
<p><span class="font48">Examples</span></p>
<p><span class="font48">•&nbsp;In figure 6, a call to GENERA causes a transaction to be gen* erated. GENERA schedules the next generation automatically by entering the new generation time and its own statement number in the list as target. Since we want to generate a new transaction every 5 minutes, we set GENERA*s parameter ET s 5. The current simulator-clock time is T s 11, so GENERA enters the new generation time T s 16 in the list. Figure 6 shows the old transaction-generation entry; figure 7<sub>f</sub> the new one.</span></p>
<p><span class="font48">•&nbsp;Serving a transaction takes exactly 6 time units. When SEIZE acquires the facility for a transaction, it returns to the next statement, which is a call to WORK. WORK is thus called at the same simulator-clock time at which the facility begins serving the transaction. Since the facility is supposed to serve the transaction for 6 minutes, WORK schedules itself to be called a-gain at time T ♦ 6 by entering that time and its own statement number in the list; then</span><span class="font45" style="font-weight:bold;"> WORK</span><span class="font48"> returns to flow management (and not to the next statement in the model). Tn figures 6 and 7, the activation time 13 and the target 3 are shown. Then when WORK is called again, it recognizes the transaction that has just been served and returns control to the CALL CLEAR statement, which frees the facility.</span></p>
<p><span class="font48">In our bank-window example, the user sets the model in motion by priming flow management's list. All other state changes are scheduled automatically during the simulation by GPSS-F's subroutines.</span></p>
<p><span class="font48">ACTIV1 is flow management's subroutine that searches the list for the next state change. It advances the simulator's clock to the new state-change time and returns its associated target in the variable, NADDR. Then a computed GOTO jumps to the statement designated by NADDR. The simulation program looks schematically like this:</span></p>
<p><span class="font48">COMMON NADDR</span></p>
<p><span class="font48">CALL&nbsp;ACTIV1</span></p>
<p><span class="font48">GOTO&nbsp;(1,2,3), NADDR</span></p>
<p><span class="font48">1&nbsp;CALL&nbsp;GENERA</span></p>
<p><span class="font48">2&nbsp;CALL&nbsp;SEIZE</span></p>
<p><span class="font48">3&nbsp;CALL&nbsp;WORK CALL CLEAR CALL TERMIN</span></p>
<p><span class="font48">1.6.3</span><span class="font45" style="font-weight:bold;"> Waiting Transactions</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions queued up at a facility are in the wait state; they are neither active, nor scheduled to become active at any particular time* Before we show how flow management activates waiting transactions, we describe the data areas mentioned in section</span><span class="font48"> 1.6.2</span><span class="font45" style="font-weight:bold;"> more thoroughly. Flow management's list actually consists of two sublists:</span></p>
<p><span class="font48">• The event list</span></p>
<p><span class="font48">Only scheduled events appear in the event list. (Events are defined roughly in section 1.1.3.) The list entry in figure 7 that occasions a transaction generation is actually in the event list,</span></p>
<p><span class="font48">• The activation list</span></p>
<p><span class="font48">This sublist is exclusively for already existent transactions. There are entries in the list for all scheduled or waiting transactions. Scheduled transactions are those whose activation times are already determined. Their entries consist of an time and a target showing what further state change should occur when the transaction is again active. Figure 7 shows such a transaction; it is scheduled to free the facility at time T s 13. Its entry is actually in the activation list. The waiting transactions are waiting to acquire a presently occupied facility. Their activa-tion-llst entries consist of a block code and a target. The block code is a negative whole number -K, where K is the identifying station number of the facility where the transaction is waiting.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">•&nbsp;In figure 6, a transaction occupies the facility, which it will free at time T s 13. The transaction generated at time T ? 11 tried immediately to acquire the facility (CALL SEIZE), but found it occupied and has to wait. Hence its entry in the activation list at T s 13 has a block code (see figure 8). Since the transaction is waiting on a facility whose station number K is 1, -1 appears in the second column of the activation list. As soon as the facility has been freed, the waiting transaction can be served. Since it must then acquire the facility, the target in its activation-list entry while it waits is 2, the statement number of CALL SEIZE.</span></p>
<p><span class="font48">The transactions' data areas are the transaction matrix and the activation list. Each transaction has a line in the matrix where its parameters are stored. The first parameter in the matrix (NTX) is the transaction's identifying number, the third (ET) is its generation time. If a transaction's parameters are in the nth line in the transaction matrix, its entry in the activation list is likewise the nth line in that list. A complete description of the transaction matrix is given in chapter 2.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">•&nbsp;In figure 8, transaction number 3 is in line LTX * 2. To process this transaction, flow management also uses the second line in the activation list. In this case, the transaction was generated at time</span><span class="font45" style="font-weight:bold;"> T</span><span class="font48"> s 11 and is waiting on the facility whose station number is K s 1.</span></p>
<p><span class="font45" style="font-weight:bold;">The facilities' data areas are the facility matrix (FAC matrix) and the state vector. The FAC matrix contains information about the transaction currently occupying the facility. For instance, the first parameter (LTX) shows which transaction occupies it<sup>-</sup>. A complete description of the FAC matrix is given in</span></p>
<p><span class="font48"><a name="bookmark197"></a>chapter The state vector shows aa follows whether is occupied or free:</span></p><div>
<p><span class="font48">a facility</span></p></div><div>
<p><span class="font48">STATE(K)sO STATE(K)<a name="footnote5"></a><sup><a href="#bookmark198">5</a></sup>1</span></p></div>
<p><span class="font48"><a name="bookmark199"></a>The facility numbered K is occupied The facility numbered</span><span class="font39" style="font-style:italic;"> K</span><span class="font48"> is free.</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark200"></a>simulator clock t</span></p>
<p><span class="font47">nr»</span></p>
<table border="1">
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">event list</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">fac matrix</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">state</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">vector</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">target state-chg stmt. time</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">ltx</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">state</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">i I I</span></p></td><td>
<p><span class="font48">1 1 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font48">1 0</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">1 1 t 16 |</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">activation List</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">transaction</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">matrix</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">target tx stmt. state</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">ntx</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">et</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">1 3 1 13 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span><span class="font39" style="font-style:italic;"> 2</span><span class="font52" style="font-variant:small-caps;"> |</span></p></td><td>
<p><span class="font48">1 6 I</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td></tr>
<tr><td>
<p><span class="font48">12 1-11</span></p></td><td>
<p><span class="font48">I 3 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span><span class="font48"> 11</span><span class="font52" style="font-variant:small-caps;"> 1</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td></tr>
<tr><td>
<p><span class="font52" style="font-variant:small-caps;">figure</span><span class="font48"> 8</span><span class="font52" style="font-variant:small-caps;"> the</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">data areas at</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">time t =</span></p></td><td>
<p><span class="font48">13</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
</table>
<p><span class="font48">Examples:</span></p>
<p><span class="font52" style="font-variant:small-caps;">*&nbsp;a</span><span class="font45" style="font-weight:bold;"> facility's identifying number, K, doesn't appear explicitly in its data area, since facilities cannot be generated and annihilated. Its identifying number is, instead, simply its line number in the FAC matrix*</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Facility number K * 1 has the first line in the facility matrix. At time</span><span class="font57" style="font-weight:bold;"> T</span><span class="font45" style="font-weight:bold;"> s 13, the facility is occupied, since the corresponding element in the state vector has the code 0. (Figure 8)</span></p>
<p><span class="font48">1.6*4 Conditioned Activation</span></p>
<p><span class="font48">Vhen the facility is freed<sub>9</sub> one of the waiting transactions should be activated so that it can acquire the facility. In our model <sub>9</sub> the transaction waiting at the head of the queue is chosen to be activated <sub>f</sub> but more complex models can have more complex choice procedures. In general<sub>9</sub> then<sub>9</sub> the time when a transaction should be re-activated is not known when it enters a queue.</span></p>
<p><span class="font48">Hence, flow management cannot handle waiting transactions as scheduled; their activation is not to occur at some pre-arranged time. Expressed generally<sub>9</sub> the activation is to occur just when the system's state fulfils precisely specified conditions. Such activations are thus called conditioned.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">•&nbsp;Figure 8 shows the data areas at time T s 13. Transaction 2's scheduled activation (line number LTX = 1) hasn't yet been carried out.</span></p>
<p><span class="font48">ACTIV1 now activates transaction 2 and jumps, via the computed GOTO, to CALL WORK<sub>f</sub> which acknowledges the end of the transaction's time at the facility and returns to the subsequent statement. Subroutine CLEAR frees the facility and returns to the statement following its call; then 7ERMIN annihilates the transaction by clearing its data areas. The data areas after these manipulations are depicted in figure 9. Note that the clock still shows T s 13. Now the facility is free and a transaction is waiting to acquire it; a conditioned activation of transaction 3 (LTX s 2&gt; must follow.</span></p>
<p><span class="font48">Flow management's subroutine, ACTIV2, undertakes all conditioned activations. It searches the activation list for transactions with block codes<sub>9</sub> at the same time checking the state-vec-tor entry of the facility where the blocked transaction is waiting. If it finds a blocked transaction whose facility is free, the transaction can acquire it: a conditioned activation results.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">•&nbsp;In figure</span><span class="font39" style="font-style:italic;"> 9 <sub>9</span><span class="font48"></sub> flow management would find transaction 3t with block code -1<sub>9</sub> in the second line of the activation list. The absolute value of the block code is the line number of the facility where the transaction is waiting, in this case, the facility whose number is K s 1. The state vector shows the facility free.</span></p>
<p><span class="font48">Since the transaction can now be activated, ACTIV2 activates it, sets NADDR = 2 and returns to the computed GOTO, which jumps to CALL SEIZE. SEIZE acquires the facility for the active transaction, so it returns control to the next statement in the program, which is a CALL WORK. WORK schedules the transaction to be re-activated in six minutes (see figure 10), then it returns control to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">SIMULATOR CLOCK T</span></p>
<p><span class="font48" style="font-variant:small-caps;">mti</span></p><div>
<p><span class="font48">FIGURE 9</span></p></div><div>
<p><span class="font48" style="font-variant:small-caps;">fac matrix</span></p></div><div>
<p><span class="font48">STATE VECTOR STATE</span></p>
<p><span class="font48" style="font-variant:small-caps;">i</span></p></div>
<table border="1">
<tr><td>
<p><span class="font48">EVENT LIST TARGET STATE-CHG STMT. TIME .</span></p></td><td>
<p><span class="font48">FAC MATRIX LTX</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">state state</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">vector</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">I I</span><span class="font52" style="font-variant:small-caps;"> 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">| 1 I 16 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">ACTIVATION LIST TARGET TX STMT. STATE</span></p></td><td>
<p><span class="font48">TRANSACTION NTX</span></p></td><td>
<p><span class="font48">MATRIX ET</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font48">1</span></p></td></tr>
<tr><td>
<p><span class="font48">1 1 1</span></p></td><td>
<p><span class="font48">t 1</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td></tr>
<tr><td>
<p><span class="font48">12 1-11</span></p></td><td>
<p><span class="font48">1 3 1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span><span class="font48"> 11</span><span class="font52" style="font-variant:small-caps;"> 1</span></p></td><td>
<p></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td><td>
<p><span class="font52" style="font-variant:small-caps;">1</span></p></td></tr>
</table>
<p><span class="font48">FREEING THE FACILITY</span></p>
<p><span class="font48">SIMULATOR CLOCK T</span></p>
<p><span class="font0" style="font-style:italic;">mm mm mm ^m mm tm</span></p>
<p><span class="font28">I 13 I</span></p>
<p><span class="font48" style="font-variant:small-caps;">event list target state-chg stmt. time .</span></p>
<p><span class="font48" style="font-variant:small-caps;">ltx </span><span class="font10" style="font-weight:bold;font-style:italic;">\ 2 ]</span></p>
<table border="1">
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">1 1 i 16 |</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">ii 1 1</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">i i</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">activation list target tx stmt. state</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">transaction matrix ntx et</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">1 1 1</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">1 i i 1</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">i</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">1</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">1 3 1 19 i</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">13 1 | 11 |</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">i</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">1</span></p></td></tr>
<tr><td>
<p><span class="font48" style="font-variant:small-caps;">figure 10</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">acouirtng the facility </span><span class="font0" style="font-style:italic;">0</span></p></td><td>
<p><span class="font48" style="font-variant:small-caps;">1</span></p></td><td>
<p></p></td></tr>
</table>
<p><span class="font48">When the GPSS-F subroutines SEIZE or WORK or TERHIN return control to flow management, they always return control to ACTIV2. (The mechanism by which they do that, called an addressed exit, is described below.) To effect a conditioned activation, ACTIV2 enters the target in the variable NADDR. Then it exits to the computed GOTO, which uses NADDR to jump to the indicated program part. The computed GOTO is called the target selector. If ACTIV2 can find no conditioned activations to undertake, it exits instead to ACTIV1, which then searches for the next scheduled activation.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48"><sup>9</sup> Figure 10 shows a system state in which no transactions are waiting at a free facility; no conditioned activations are possible. ACTIV2 returns to ACTIV1, which will now initiate the scheduled transaction generation at T s 16.</span></p>
<p><span class="font48">ACTIV2 must return, as we have seen, either to the target selector or to ACTIV1. It does that by means of two addressed exits: if a^conditioned activation is possible, ACTIV2 returns by means of the second addressed exit to the target selector; otherwise ACTIV2 takes the first addressed exit, to ACTIV1.</span></p>
<p><span class="font48">An addressed exit is a feature available from many Fortran compilers whereby one or more statement numbers, prefixed by the symbol '&amp;'<sub>9</sub> are passed as parameters to a subroutine. The subroutine then has the option of returning to one of those statement numbers, instead of returning to the following statement. This is the only non-standard Fortran feature used in GPSS-F; it can be imitated, though inelegantly, in standard Fortran.</span></p>
<p><span class="font48">With provisions for conditioned activation, the simulation program looks schematically like this:</span></p>
<p><span class="font48">COMMON NADDR 1001 CALL ACTIV1 1003 GOTO (1,2,3), NADDR</span></p>
<p><span class="font48">1&nbsp;CALL GENERA</span></p>
<p><span class="font48">2&nbsp;CALL SEIZE</span></p>
<p><span class="font48">3&nbsp;CALL WORK CALL CLEAR , CALL TERMIN</span></p>
<p><span class="font48">1005 CALL ACTIV2 (41001,41003)</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">* The rest of this book is a GPSS-F programming manual. It can, nevertheless, introduce the reader to GPSS-F. Beginners should follow the preface's reading suggestions*</span></p>
<p><span class="font48">Plow management Is the heart of GPSS~F, It ensures that a model's state changes occur in proper sequence. It comprises event management and transaction management.</span></p>
<p><span class="font48">The elements of GPSS-F are stations and transactions. Transactions are the mobile components; they wander between stationary components, the stations. Both take on various states, which specify, for instance, when or under what circumstances a trans* action can proceed from one station to the next.</span></p>
<p><span class="font48">A GPSS-F simulation is run by executing a Fortran main prog« ram, large portions of which are pre-wrltten (see 2.6 and appendix A4), into which the user inserts the modules from which his model is built. The pre-written portion of the main program can be thought of as a chassis upon which the model is built; the modules from which the model is constructed are mostly calls to GPSS-F subroutines.</span></p>
<p><span class="font48">2.1 Event flanagement</span></p>
<p><span class="font48">We have already defined events roughly in 1.1.3* What counts as an event will vary slightly from one simulator to the next. For GPSS-F, we can avoid a tedious normative definition by defining events descriptively: an event is any state change scheduled in the event list. In practice, events will be changes that occur (mostly to stations) without being caused by the transactions * activities. An important class of events is transaction-generation.</span></p>
<p><span class="font48">2.1.1 The Event List</span></p>
<p><span class="font48">The event list is the data area that enables flow management to process events in correct order. An event is characterized completely by its time of occurrence and the change it comprises. Hence an entry in the event list specifies both: time and target. The list is defined as follows:</span></p>
<p><span class="font48">INTEGER EL</span></p>
<p><span class="font48">DIMENSION EL(&quot;EL1&quot;.2)</span></p>
<p><span class="font6">»</span></p>
<p><span class="font48">Each non-empty line schedules an event, so we can refer to a specific one by giving its line number (LEV s n) in the list. Each line has two fields whose meanings are:</span></p>
<p><span class="font48">EL(LEV,1) Target (statement number)</span></p>
<p><span class="font48">This field contains a statement number referring to the program part that changes the system's state as the event requires. Event management Jumps to that statement when the event's time (next field) has come.</span></p><div>
<p><span class="font48">0 F</span></p></div><div>
<p><span class="font48">0 P S S - F</span></p></div><div>
<p><span class="font48">STRUCTURE</span></p></div>
<p><span class="font47" style="font-weight:bold;">EL(LEV,</span><span class="font48">2) Event time</span></p>
<p><span class="font48">The time when the event is to take place la entered here. Event management compares the entry with the simulator's clock; when the values are the same<sub>9</sub> it Jumps to the target statement (see 2.3*2)*</span></p>
<p><span class="font48">Note:</span></p>
<p><span class="font48">*&nbsp;In describing GPSS-F, the data areas* sizes are left open by specifying a dimension symbolically in quotes. Before GPSS-F is compiled, each such symbol must be replaced throughout the source program by some actual value, tailored to the user's needs (See appendix A3)«</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">•&nbsp;To dimension the event list<sub>9</sub> the symbol &quot;EL1&quot; in EL(<sup>ff</sup>EL1 &quot;,2) must be replaced by an actual value, which specifies the number of 1 ines in the list* That value determines how many pending (i.e. scheduled) events at a time the system can handle.</span></p>
<p><span class="font48">2.1.2 EVENT</span></p>
<p><span class="font48">Purpose:</span></p>
<p><span class="font48">Subroutine EVENT is used to schedule an event.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL EVENT (EVT,EVAD,NS,&amp;1006<sub>f</sub> IPRINT)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">EVT&nbsp;Event time</span></p>
<p><span class="font45" style="font-weight:bold;">The time when the event should occur is specified. The event will be- scheduled only if the time specified is greater than or equal to the simulator clock's time.</span></p>
<p><span class="font48">EVAD</span><span class="font45" style="font-weight:bold;"> Target (statement number)</span></p>
<p><span class="font45" style="font-weight:bold;">The event is meant to cause a state change; this parameter specifies the statement number of the program part that carries out that state change.</span></p>
<p><span class="font45" style="font-weight:bold;">NS&nbsp;Source number</span></p>
<p><span class="font45" style="font-weight:bold;">When a call to EVENT schedules a transaction generation, the generating source (see 2.4.1) must be identified. NS s Source number</span></p>
<p><span class="font45" style="font-weight:bold;">Each source has an identifying number. NS r 0</span></p>
<p><span class="font45" style="font-weight:bold;">For all other events, that is events that don't schedule transactions to be generated, NS must be \&nbsp;zero.</span></p>
<p><span class="font45" style="font-weight:bold;">41006 Error exit for full event list</span></p>
<p><span class="font45" style="font-weight:bold;">EVENT returns to statement 1006 when the event cannot be scheduled. That occurs when there are no more lines in the list.</span></p>
<p><span class="font48">IPRINT Trace flag</span></p>
<p><span class="font48">Trace printouts are suppressed when IPRINT « 0*</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">EVENT alters the event list. If a transaction's generation is scheduled, the source matrix is used.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">EVENT works in tandem with GENERA, described in section 2.4.1. A first reading could overlook the details of their interplay without harm. In that case the only section to read is the one labelled &quot;Schedule&quot;.</span></p>
<p><span class="font48">&quot;Reset activation time&quot;</span></p>
<p><span class="font48">IF(NS.EQ.O) GOTO 50 IF(NS.LE.&quot;SRC1&quot;) GOTO 20 RETURN 1 20 IF(EVT.EQ.O) GOTO 200</span></p>
<p><span class="font48">IF(SRC(NS,1).EO.O) GOTO 50 I x SRC(NS,1) GOTO 150</span></p>
<p><span class="font48">Subroutine GENERA always generates a transaction for some particular source. Each time it is called, it automatically schedules the source to generate another transaction. If the user wishes to reschedule a source's generation, he can do so by calling EVENT with that source's identifying number. EVENT uses the source's line in the source matrix (described in 2.4.1) to find the event-list entry that must be modified.</span></p>
<table border="1">
<tr><td colspan="2">
<p><span class="font48">&quot;Schedule&quot;</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">50</span></p></td><td>
<p><span class="font48">DO 100 1 = 1,</span></p></td><td>
<p><span class="font48">&quot;EL1&quot;</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">IF(EL(I,1).EQ.0)</span></p></td><td>
<p><span class="font48">GOTO 150</span></p></td></tr>
<tr><td>
<p><span class="font48">100</span></p></td><td>
<p><span class="font48">CONTINUE</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN 1</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font48">150</span></p></td><td>
<p><span class="font48">EL(I » 1) &quot; EVAD</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">EL(1,2) s EVT</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">IF(LEL.LT.I) LEL</span></p></td><td>
<p><span class="font48">s I</span></p></td></tr>
</table>
<p><span class="font45" style="font-weight:bold;">A free line is sought ii\ the event list; wherever one Is found, the event's time and target are entered. Event management (ACTIV1) searches the list as far as the list-end pointer, LEL, and assumes remaining lines to be empty. If EVENT uses a line beyond the pointer, it must be modified.</span></p>
<p><span class="font45" style="font-weight:bold;">••Schedule a transaction generation&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(NS.GT.O) SRC(NS<sub>f</sub>1)&nbsp;r I RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">Every source has a line&nbsp;in the source matrix correspondlng to</span></p>
<p><span class="font45" style="font-weight:bold;">its identifying number, NS.&nbsp;When EVENT schedules a source to gen-</span></p>
<p><span class="font48"><a name="bookmark201"></a>•rate a transaction, it seta a pointer to the event in that source's data area (SRC(NS,D). At generating time, GENERA identifies the responsible source by Beans.of the pointer.</span></p>
<p><span class="font48"><a name="bookmark202"></a>&quot;Shut down a source&quot;</span></p>
<p><span class="font48"><a name="bookmark203"></a>200 I • SRC(NS,1) EL(I,1) s 0 EL(I,2) « 0</span></p>
<p><span class="font48"><a name="bookmark204"></a>When a source is shut down, its line in the event list is cleared.</span></p>
<p><span class="font48">&quot;Reset the list-end pointer, LEL&quot;</span></p>
<p><span class="font48">250 IF(EL(LEL,1).NE.O.OR.LEL.EQ.1) RETURN LEL s LEL - 1 GOTO 250 END</span></p>
<p><span class="font48">If shutting down a source frees a line at the end of the event list, the list-end pointer, LEL, must be decremented. ~</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font48">•&nbsp;The user must schedule the first transaction generation for each source by calling EVENT. If he knows at start of simulation when a source should generate its first transaction, he can schedule the event in section 6 of the chassis, &quot;Schedule the first events* (see 2.6). He must schedule at least one event there, normally a transaction's generation. We have already referred to that procedure as priming flow management's list.</span></p>
<p><span class="font48">•&nbsp;A given call to GENERA can generate a transaction for any source; the source number is not specified in GENERA's parameter list. Hence various calls to EVENT for various sources can specify the same CALL GENERA statement in the EVAD parameter. GENERA discovers for which source it is generating a transaction by finding out which source's entry in the SRC matrix points to the event that scheduled the generation.</span></p>
<p><span class="font48">•&nbsp;GPSS-F shuts a source down automatically when <sup>v</sup>the source has generated as many transactions as are specified in GENERA's ZTX (generation limit) parameter. The user can shut down a source before it has reached its generation limit by calling EVENT with EVT * 0.</span></p>
<p><span class="font48">2.2 Transactions</span></p>
<p><span class="font48">A discrete system's transactions have private parameters., which GPSS-F maintains in a data matrix, one transaction to a line. The parameters that specify whether a transaction is ac-tive<sub>f</sub> scheduled to become active or waiting to become active are kept in the activation list and in the variables LTX and LFAM;</span></p>
<p><span class="font48"><a name="bookmark205"></a>2.2*1 Transactions' Data Area</span></p>
<p><span class="font48">The parameters that characterize a transaction are assembled in a line of the transaction matrix (TX matrix). Since each transaction takes up one line<sub>9</sub> the number of lines dimensioned for the matrix specifies how many transactions at a time the system can handle. Each of them has space in the matrix for a total of</span><span class="font39" style="font-style:italic;"> &quot;7X2*</span><span class="font48"> parameters of which GPSS-F uses the first 18 positions. The user can use the remaining ones any way he wants. The TX matrix is defined as follows:</span></p>
<p><span class="font48">INTEGER TX</span></p>
<p><span class="font48">DIMENSION TX^TX!&quot; ,<sup>f,</sup>TX2&quot;)</span></p>
<p><span class="font48">The individual elements in each line are described below. The variable LTX -specifies the line in the TX matrix. Chapters re* ferred to in the headings detail their uses.</span></p>
<p><span class="font48">Transaction number (Chapter 2)</span></p>
<p><span class="font48">GENERA assigns each transaction entering the&nbsp;system</span></p>
<p><span class="font48">a unique, consecutive, identifying number.&nbsp;If this</span></p>
<p><span class="font48">field is zero, GPSS-F assumes the line to be&nbsp;free.</span></p>
<p><span class="font48">Duplicate number (Chapter 8)</span></p>
<p><span class="font48">It is sometimes useful to designate a number of transactions as belonging together; they are said to form a family. Since all transactions in a family have the same transaction number, they are distinguished from one another by this additional identifying number.</span></p>
<p><span class="font48">Creation time (Chapter 2)</span></p>
<p><span class="font48">The clock time when the transaction was generated is entered here.</span></p><div>
<p><span class="font48">TX(LTX<sub>9</sub>1)</span></p>
<p><span class="font48">TX(LTX<sub>f</sub>2)</span></p></div><div>
<p><span class="font48">TX(LTX<sub>f</sub>3)</span></p></div>
<p><span class="font48">Priority (Chapters</span><span class="font45" style="font-weight:bold;"> 2</span><span class="font48"> and</span><span class="font45" style="font-weight:bold;"> 3)</span></p>
<p><span class="font48">The transaction's priority is specified here, larger the number, the greater the priority.</span></p><div>
<p><span class="font48">TX (LTX,4)</span></p></div><div>
<p><span class="font48">The</span></p></div>
<p><span class="font45" style="font-weight:bold;">Post-preemption target (Chapter 4)</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction is preempted, this parameter tells where it needs to be targeted to reacquire the station.</span></p>
<p><span class="font45" style="font-weight:bold;">Residual serving time (Chapter 4)</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction is preempted from a station, its remaining serving time is entered here. That is the amount of time it needs to spend at that station to finish being served.</span></p>
<p><span class="font45" style="font-weight:bold;">Preemption return element (Chapter 5)</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction is preempted from a multifacili-</span></p>
<p><span class="font45" style="font-weight:bold;">ty, it is possible to specify that the element that</span></p>
<p><span class="font45" style="font-weight:bold;">began serving it finish serving it. Tn that case,</span></p>
<p><span class="font45" style="font-weight:bold;">the element's Identifying number is saved in this</span></p>
<p><span class="font45" style="font-weight:bold;">field.</span></p><div>
<p><span class="font48">TX(LTX,5)</span></p>
<p><span class="font48" style="font-variant:small-caps;">tx(ltx,6)</span></p>
<p><span class="font48" style="font-variant:small-caps;"><sup>t</sup>x(ltx,7)</span></p></div>
<p><span class="font48">Block time (Chapters 3 and H)</span></p>
<p><span class="font48">In case a transaction must wait, this field contains the time when it began waiting. The field is sometimes used by a policy to decide in which order to re-activate transactions.</span></p>
<p><span class="font48">Bin number (Chapter 10)</span></p>
<p><span class="font48">GPSS-F provides entitles called bins for accumulating data on transactions' behaviour. If GPSS-F should keep account of which bins the transaction is in<sub>t</sub> their numbers must be entered in fields TX(LTX,9) to TX(LTX<sub>9</sub>13). Thus, a transaction can be in up to five bins at a time.</span></p>
<p><span class="font48">Bin-entry time (Chapter 10)</span></p>
<p><span class="font48">In TX(LTX, 1*1) to TX(LTX,18) are recorded the times when the transaction entered the collections whose numbers are recorded in the corresponding five bin-number fields.</span></p>
<p><span class="font48">Free parameters</span></p>
<p><span class="font48">Here the user can store further private parameters for the transaction. He has &quot;TX2&quot; minus 18 available fields.</span></p><div>
<p><span class="font48">TX(LTX,8)</span></p>
<p><span class="font48">TX(LTX,9)</span></p></div><div>
<p><span class="font48">TX(LTX,14)</span></p>
<p><span class="font48">TX(LTX,19)</span></p></div>
<p><span class="font39" style="font-style:italic;">2.2.2</span><span class="font45" style="font-weight:bold;"> Transactions' States</span></p>
<p><span class="font45" style="font-weight:bold;">Transaction-oriented models lend themselves to a stock of imagery, of which this book shall make free use. Without the images, it would be deadly wearisome to describe even the simplest model's workings. The most important thing to imagine is that transactions move from station to station during the simulation. The other thing to imagine is that almost everything that happens in a model results from some transaction's activity. We shall say of every state change, except events, that a transaction undertook it or suffered it. We say, for instance, that a transaction acquires a facility, or that it is placed in some<sub>#</sub> state. Since state changes are actually undertaken by GPSS-F's subroutines, the programs called while a transaction is active could be thought of as carrying out or even as being its activities.</span></p>
<p><span class="font48">A</span><span class="font45" style="font-weight:bold;"> transaction can be in one of three states: active, scheduled or waiting. When it undertakes state changes, it is active: its activities include moving about or altering some element's state, usually its own or that of the station where it happens to be.</span></p>
<p><span class="font48">A</span><span class="font45" style="font-weight:bold;"> transaction is scheduled, if it is to be re-activated at some specific time: at the given moment, it becomes active and undertakes further state changes. A transaction is waiting, if it can't go any further until the model's state fulfils some specific condition: once the condition is satisfied, the transaction can proceed. Both scheduled and waiting transactions are inactive. The one becomes active again at a specified time, whatever . the system's state may be; the other becomes active again when the system's state meets certain requirements, whatever time it may be.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">• A transaction arrives at a facility<sub>9</sub> hoping to be served» but finds the facility occupied at the moment. So it has to wait. As soon as the condition</span></p>
<p><span class="font48">the facility is free</span></p>
<p><span class="font48">is satisfied, the transaction can proceed to be served, assuming it is the only one waiting. The condition will be satisfied when a single parameter changes<sub>9</sub> namely the facility's occupancy. Other types of stations can set more complex conditions, depending perhaps on numerous parameters, all of which must satisfy the condition, before the transaction may proceed.</span></p>
<p><span class="font48">Transactions don't wait around just anywhere<sub>9</sub> they always wait at a station, where they could be pictured as standing in line. We call the lines wait queues, or simply queues.</span></p>
<p><span class="font48">The proper moment arrives for a waiting transaction to become active again, when the system's state changes to fulfil the requisite condition. In order to know when that has happened, the relevant parameters must be tested; as soon as they satisfy the condition, the waiting transaction can proceed. There are two ways of watching out for the right moment:</span></p>
<p><span class="font48">1)&nbsp;For transactions waiting at most types of stations, GPSS-F keeps track of the system's state and re-activates them automatically. After each change in the system's state, transaction management checks to see if some waiting transaction's condition has been fulfilled. If so, the transaction is re-activated. Waiting transactions that are administered automatically in that way are called blocked.</span></p>
<p><span class="font48">2)&nbsp;For transactions waiting at certain types of stations, it is desirable to let the user prescribe when to re-test the system's state. He is free to call for a system-state check at any point in the program. Transactions so administered are called locked. (The stations where transactions wait in the locked state are storages, described in chapter 6, and type-1 gates, described in chapter 7.)</span></p>
<p><span class="font48">Thus waiting actually comprises two distinguishable states: blocked and locked.</span></p>
<p><span class="font48">The four states: active, scheduled, blocked and locked are exhaustive and mutually exclusive; i.e. at any machine-time moment, each transaction is in exactly one of those states. Furthermore, in machine time, only one transaction at a time may be active. Since there can be only one, we may refer to the currently active transaction without fear of confusion.</span></p>
<p><span class="font48">In simulated (i.e. simulator clock) time, more than one transaction can be active. GPSS-F simulates that state of affairs, say when two transactions are scheduled to be re-activated at some time T, by leaving the simulator clock fixed at T and activating the transactions one after the other: the first transaction proceeds until it becomes inactive, then the other.</span></p>
<p><span class="font48">The following overview summarizes the four possible transaction states (see also figure 11 and table 3):</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark206"></a>activate</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark207"></a>deactivate</span></p><div>
<p><span class="font52" style="font-variant:small-caps;">active</span></p></div>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark208"></a>scheduled activation</span></p><div><img src="Untitled.FR10_files/Untitled.FR10-5.jpg" style="width:191pt;height:92pt;"/></div><div>
<p><span class="font45" style="font-weight:bold;">SCHEDULE</span></p></div><div>
<p><span class="font11">-------------------&gt;</span></p></div>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark17"></a>conditioned activation •</span></p><div><img src="Untitled.FR10_files/Untitled.FR10-6.jpg" style="width:191pt;height:91pt;"/></div><div>
<p><span class="font45" style="font-weight:bold;">BLOCK</span></p></div>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark209"></a>a</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark210"></a>i start</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">LOCK</span></p>
<p><span class="font52" style="font-variant:small-caps;"><a name="bookmark211"></a>locked</span></p>
<p><span class="font48">FIGURE 11&nbsp;TRANSACTION STATES AND STATE TRANSITIONS</span></p>
<p><span class="font48">• Active</span></p>
<p><span class="font48">The transaction progresses from station to station, undertaking state changes. In terms of GPSS-F's variables, a transaction is active when LTX and LFAM are set to show that it is so (see 2.3.3).</span></p>
<p><span class="font48">All three remaining states are accessible to an active transaction. It goes into the scheduled state when it has carried out all of the state changes it can, for the time being, and its activities should begin again at some specific time. GPSS-F places a transaction automatically in one of the two wait states whenever it arrives at a station and cannot proceed on account of the</span></p>
<p><span class="font48">system's present state. Depending on the type of station the transaction is blocked or locked. If the former, GPSS-F tests automatically after each state change, whether the transaction may now proceed; if the latter» the user must oall for the testa himself.</span></p>
<p><span class="font48">•&nbsp;Scheduled</span></p>
<p><span class="font48">The transaction's re-activation time is already fixed. All transactions in this state have an entry in the activation list; its field AL(LTX,2) contains a positive whole number. (The activation list is defined in section 2.3.1.) At the appointed time (given in AL(LTX<sub>9</sub>2))<sub>9</sub> the the transaction becomes active. That state transition is called scheduled activation and is undertaken by subroutine ACTIV1 (see 2.3*2).</span></p>
<p><span class="font48">•&nbsp;Blocked</span></p>
<p><span class="font48">A blocked transaction can proceed no further on account of the system's state; it has arrived at a station (other than a storage or a type-1 gate) that requires it to wait. Transaction management watches out for the proper moment to re-activate it. Blocked transactions have a negative whole number, -K, called a block code, in the AL(LTX,2) field of their activation-list entry. Its absolute value identifies the station where the blocked transaction is waiting. As soon as the system's state changes in a way that fulfils the wait condition, the transaction becomes active. That state transition is called a conditioned activation and is undertaken by ACTIV2 (see 2.3*3).</span></p>
<p><span class="font48"><sup>1</sup> Locked</span></p>
<p><span class="font48">A locked transaction c an proceed no further, likewise on account of the system's state. It has reached a storage or a type-1 gate that requires it to wait. Here, the user occasions the sys-tem-state checks, as explained below. Locked transactions have a lock code in AL(LTX,2) consisting of a negative whole number, whose value is -(K+<sup>H</sup>KEND<sup>H</sup>), where K identifies the station at which it waits. &quot;KEND&quot; is the number of stations definable in GPSS-F. Since the value &quot;KEND&quot; is known to GPSS-F, it can always distinguish locked transactions from merely blocked ones: block codes run from -1 to -&quot;KEND&quot;; lock codes, from -(W&quot;FCEND&quot;) to -(&quot;KEND&quot;*&quot;KEND&quot;).</span></p>
<p><span class="font48">When the user wants to have a transaction's wait condition tested, he merely places it in the blocked state. Since the blocked transaction is then under GPSS-F's supervision, flow management tests Its wait condition at the first opportunity. The transition from locked to blocked is called a start and is effected by subroutine UNLOCK (see 2.5.3)•</span></p>
<p><span class="font48">2.3 Transaction Management</span></p>
<p><span class="font48">Transaction management has the task of overseeing transactions' passage from station to station. It keeps track of the transactions' states and, If need be, undertakes state transitions. It finds the information it needs</span><span class="font45" style="font-weight:bold;"> to perform</span><span class="font48"> those tasks In the activation list, which it processes by means of its routines ACTIV1 and ACTIV2.</span></p>
<p><span class="font48">STATE TRANSITION&nbsp;UNDERTAKEN BY (GPSS-F SUBROUTINES)</span></p>
<p><span class="font48">SCHEDULING&nbsp;WORK, SETUP, KNOCKD, ADVANC,</span><span class="font47" style="font-weight:bold;"> BUFFER</span></p>
<p><span class="font48">SCHEDULED ACTIVATION&nbsp;ACTIV1</span></p>
<p><span class="font48">BLOCKING&nbsp;SEIZE, PREEHP, GATE2, AMONG OTHERS</span></p>
<p><span class="font48">CONDITIONED ACTIVATION&nbsp;ACTIV2</span></p>
<p><span class="font48">LOCKING&nbsp;ENTER, ALLOC, GATE1, AMONG OTHERS</span></p>
<p><span class="font48">STARTING&nbsp;UNLOCK</span></p>
<p><span class="font48">TABLE 3&nbsp;TRANSACTION'S STATE TRANSITIONS</span></p>
<p><span class="font48">2.3*1 Activation List</span></p>
<p><span class="font48">The activation list contains all the information needed to activate scheduled and waiting transactions. Each line in the list corresponds to the same line in the transaction (TX) matrix; if a transaction's entry is the nth line in the TX matrix (LTX s n), its entry in the activation list is also the nth line. The activation list is defined as follows:</span></p>
<p><span class="font48">INTEGER AL</span></p>
<p><span class="font48">DIMENSION AL(&quot;TX1&quot;,2)</span></p>
<p><span class="font48">The fields of each line have the following meanings:</span></p>
<p><span class="font48">AL(LTX,1) Target.(statement number)</span></p>
<p><span class="font48">This field contains the statement number of the program part where the transaction in line LTX of the TX matrix is to continue its activity, the next time it becomes active.</span></p>
<p><span class="font45">AL(LTX,2)</span><span class="font48"> State code</span></p>
<p><span class="font45">A</span><span class="font48"> scheduled transaction has here a positive whole number giving the clock time when it is to be activated .</span></p>
<p><span class="font45">A</span><span class="font48"> waiting transaction has a negative whole</span><span class="font45"> number </span><span class="font48">called a wait code.</span><span class="font45"> A</span><span class="font48"> blocked transaction's code is </span><span class="font48" style="font-variant:small-caps;">-k</span><span class="font48"> and a locked transaction's code is</span><span class="font48" style="font-variant:small-caps;"> -(««-&quot;kend&quot;), </span><span class="font48">where</span><span class="font48" style="font-variant:small-caps;"> k</span><span class="font48"> is the station number of the station at which it is waiting.</span></p>
<p><span class="font48">2.3.2 ACTIV1 Purpose:</span></p>
<p><span class="font48">Subroutine ACTIV1 searches out the next event or the next scheduled transaction activation.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL ACTIV1 (&amp;1006)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">41006 Exit to final analysis section</span></p>
<p><span class="font48">1006 is the statement number of the final analysis section in the GPSS-F chassis. ACTIV1 takes this addressed exit when It finds nothing in the event or activation . lists to be carried out before time N, where N is a user-specified simulation-time limit. In other words, simulation stops when the simulator's clock reaches N or when ACTIV1 can find nothing left to do.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">ACTIV1 uses the event and activation lists and the data area COMMOM/FAM/.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">&quot;Clear the line pointers&quot;</span></p>
<p><span class="font48">LEV * 0 L7X s 0</span></p>
<p><span class="font45" style="font-weight:bold;">The line pointer LEV will be set to show which line in the event list contains the event to occur next. In the same way<sub>f</sub> LTX will point to that transaction's line in the activation list that is to be activated next.</span></p>
<p><span class="font48">&quot;Set the simulator clock&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">T1 s T - RT T = N ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">The current simulator clock -time is kept in the variable T; the variable is<sub>f</sub> so to speak, the simulator, clock. The clock determines the flow of events in GPSS-F and may under no circumstances be modified by the user. For the time being, the clock is set to a time greater than N.</span></p>
<p><span class="font45" style="font-weight:bold;">The variable RT is the user clock; GPSS-F always advances it the same number of units as the simulator clock, but the user can reset it to zero whenever he wants.</span></p>
<p><span class="font48">&quot;Search out the next event&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 J s 1 <sub>9</sub> LEL</span></p>
<p><span class="font52" style="font-variant:small-caps;">if(el(j,2).eq.0.0r.el(j,2).ge.t) goto 100 t « el(j,2) lev s j</span></p>
<p><span class="font48">NADDR x EL(LEV<sub>9</sub>1) 100 CONTINUE</span></p>
<p><span class="font48">The event list is searched for the event with the lowest actl-vat ion time; that time is entered in T.</span><span class="font47" style="font-weight:bold;"> By</span><span class="font48"> that means <sub>9</sub> the simulator clock is advanced. Further<sub>9</sub> the line number of that soonest event is set in LEV. ACTIV1 searches the list no further than the line pointed to by the list-end pointer, LEL; remaining lines are empty.</span></p>
<p><span class="font48">After return from ACTIV1<sub>9</sub> control flows in the GPSS-F chassis to the target selector (See 2.6). The target selector then passes control to the program part which is to execute the state change meant to occur for that event. It does that by jumping to the event's target statement nuaber<sub>9</sub> which is placed<sub>9</sub> for the target selector's use, in the variable NADDR.</span></p>
<p><span class="font48">•Search out the next transaction activation*</span></p>
<p><span class="font48">DO 200 J s 1 , LAL</span></p>
<p><span class="font48">IF(AL(J,2).LE.0.0R.AL(J<sub>f</sub>2).GE.T) GOTO 200 T • AL(J,2) LTX s J</span></p>
<p><span class="font48">NADDR s AL(LTX,1) LEV s 0 200 CONTINUE</span></p>
<p><span class="font48">ACTIV1 now searches the activation list for a transaction scheduled to be activated sooner than the event it just finished finding in the event list. If it should find one, it sets up the system variables to activate the transaction instead: LTX is set to point to the transaction's entry in the activation list, LEV is cleared and T2ADDR and the clock time T are reset. The routine searches the list as far as the list-end pointer, LAL; remaining lines are empty.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Check for simulation halt*</span></p>
<p><span class="font48">IF(T.GT.K) RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">At search start, T was set -to a time one time unit greater than the user's time limit. That procedure insures that the search finds only times less than or equal to that limit. If no such time is found, T will have kept the value N+l, in which case simulation is to be broken off. Then, ACTIV1 returns to the final analysis section. Otherwise, control returns to the statement following the call to ACTIV1. That statement will normally be the target selector.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the user clock<sup>1</sup>*</span></p>
<p><span class="font45" style="font-weight:bold;">RT : T • T1</span></p>
<p><span class="font45" style="font-weight:bold;">The user's clock, RT, runs as fast as the simulator's. It con<a name="bookmark212"></a></span><span class="font48">tains the time relative to the last point when the user reset it. Until the user resets his clock, it contains the sane time as the simulator clock.</span></p>
<p><span class="font48"><a name="bookmark213"></a>&quot;Family membership&quot;</span></p>
<p><span class="font48"><a name="bookmark214"></a>LFAM * 0</span></p>
<p><span class="font48">IF(LTX.EQ.O) GOTO 400 IF(TX(LTX,2).EQ.O) RETURN DO 300 J s 1 , &quot;FAM1&quot; IF(TX(LTX<sub>t</sub>1).EQ.FAM(J,1)) GOTO 350 300 CONTINUE</span></p>
<p><span class="font48">RETURN 350 LFAM s J RETURN</span></p>
<p><span class="font48">If the transaction is a family member, the line number of the family's entry in the family matrix is set.</span></p>
<p><span class="font48">&quot;Clear the event's entry&quot;</span></p>
<p><span class="font48">400 EL(LEV,1) s 0 EL(LEV,2) s 0</span></p>
<p><span class="font48">When an scheduled event is carried out, its entry in the event list is cleared.</span></p>
<p><span class="font48">•Reset the list-end pointer, LEL&quot;</span></p>
<p><span class="font48">450 IF(EL(LEL,1).NE.0.0R.LEL.EG.1) RETURN LEL s LEL - 1 GOTO 450 END</span></p>
<p><span class="font48">When the event cleared happens to be at the last in the list, the list-end pointer has to be reset.</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The very first state change in a</span><span class="font48"> GPSS-F</span><span class="font45" style="font-weight:bold;"> simulation must be an event, since there are not yet any transactions. In fact, the first event will usually be a transaction's generation. At the start of simulation, ACTIV1 receives control so as to find and initiate the first event. It receives control again each time ACTIV2 runs out of conditioned activations to perform; then it searches out the next event or scheduled activation. The interplay between ACTIV1 and ACTIV2 is shown in figure 12 (see 2.6).</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;When it happens that both events and transact ions' activations are scheduled for the same (simulated) time, the events take precedence. If multiple events are scheduled for the same time, the event occuring first in the list takes precedence; the same goes for simultaneously scheduled activations. That sequence can be altered by rewriting ACTIV1.</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>11</sup> ACTIV1 does event management's Job by keeping track of the</span></p>
<p><span class="font48"><a name="bookmark215"></a>•vent list. At the same time, ACTIV1 does part of* transaction management's Job by performing all scheduled activations.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark216"></a>2.3.3 ACTIV2 </span><span class="font48">Purpose:</span></p>
<p><span class="font48">ACTIV2 tests wait conditions for all blocked transactions. If the transaction that was last active has altered the system's state so as to enable a blocked transaction to proceed, it is activated. That is called a conditioned activation.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL ACTIV2 (41001,41003)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font39" style="font-style:italic;">f</span></p>
<p><span class="font48">41001 Scheduled activation exit</span></p>
<p><span class="font48">If no conditioned activation can be found, transaction management continues by looking for a scheduled activation. That means that this subroutine exits to the «CALL ACTIV1 statement in the chassis, which must carry statement number 1001« 41003 Conditioned activation exit</span></p>
<p><span class="font48">If ACTIV2 finds a conditioned activation, it exits to the target selector, which must bear the statement number 1003.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">ACTIV2 uses the activation list and the data areas COMMON/FAM/ and COMMON/POL/.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">Because it administers the trial of type</span><span class="font45" style="font-weight:bold;">-2</span><span class="font48"> gates (described in chapter 7) and because it must prepare certain data areas for the policies (described in chapter</span><span class="font45" style="font-weight:bold;"> 3), ACTIV2</span><span class="font48"> is somewhat involved. A first reading could skip to the notes at the end of this section.</span></p>
<p><span class="font48">&quot;Clear the event pointer&quot;</span></p>
<p><span class="font48">LEV = 0</span></p>
<p><span class="font48">An event may have occurred just before</span><span class="font45" style="font-weight:bold;"> ACTIV2</span><span class="font48"> gained control. </span><span class="font45" style="font-weight:bold;">If so, LEV</span><span class="font48"> will still point to the event's entry in the event list; it must be cleared.</span></p>
<p><span class="font48">&quot;Let transactions try the type</span><span class="font45" style="font-weight:bold;">-2</span><span class="font48"> gates&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IT.EQ.T) GOTO 200 IT i T</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I * &quot;BGATE2&quot; <sub>f</sub> *EGATE2&quot; 100 STATE(I) * 1</span></p>
<p><span class="font48">ACTIV2 administers trial of the type-2 gates automatically. Each time a transaction has been active» ACTIV2 must teat whether it has altered the system state so as to permit transactions waiting at such gates to proceed. (Gates are explained In detail in sections 7.2 and 7.3«) The type-2 gates' elements in the state vector are set to show them accessible» so that a blocked transaction can try the gate (i.e. test its condition).</span></p>
<p><span class="font48">&quot;Search for a blocked transaction<sup>19</sup></span></p>
<p><span class="font48">200&nbsp;00 201 JA * 1 » LAL IF(AL(JA.2).GE.O) GOTO 201 K « - AL(JA,2) IF(K.GT.&quot;KEND&quot;) GOTO 201 IF(STATE(K).NE.0) GOTO 250</span></p>
<p><span class="font48">201&nbsp;CONTINUE IT » 0 RETURN 1</span></p>
<p><span class="font48">ACTIV2 searches for a transaction blocked at an accessible station. (An accessible station is one that is ready to serve a waiting transaction.) When it finds such a transaction, it passes control to the section labelled &quot;Assemble<sup>19</sup>. ACTIV2 searches the activation list only as far as the list-end pointer LAL; subsequent lines are empty. If it cannot find a transaction waiting at an accessible station, ACTIV2 exits to ACTIV1. When that occurs, the IT mechanism must be reset (see 7.3-3)-</span></p>
<p><span class="font48">&quot;Assemble&quot;</span></p>
<p><span class="font48">250 P0LC * 1</span></p>
<p><span class="font48">POLVEC(POLC) * JA JA s JA + 1</span></p>
<p><span class="font48">IF(JA.GT.LAL) GOTO 350 DO 300 JB s JA , LAL IF(AL(JB,2).NE.-K) GOTO 300 P0LC r POLC + 1 POLVEC(POLC) s JB 300 CONTINUE</span></p>
<p><span class="font48">When It finds one blocked transaction that could be activated, ACTIV2 searches the activation list for other transactions blocked at the same station. It enters the count of such transactions in the variable POLC and their line numbers in the vector P0LVEC. It collects that information for use by the policies, which are described in chapter 3.</span></p>
<p><span class="font48">&quot;Policy selection&quot;</span></p>
<p><span class="font48">350 CALL POLICY (•&lt;)</span></p>
<p><span class="font48">The information in POLC and P0LVEC is passed to the POLICY subroutine in COMMON. The subroutine selects one of the transactions waiting at the station K to be activated. It does that by setting the variable LTX to point to the transaction to be</span></p>
<p><span class="font48"><a name="bookmark217"></a>aotivated. &quot;Conclusion*</span></p>
<p><span class="font48">IF(K.LE.&quot;EGATE2&quot;) OK * 1</span></p>
<p><span class="font48">IF(K.LT.&quot;BGATE2&quot;.OR.K.CT.*ECATE2&quot;) IT * O</span></p>
<p><span class="font48">Finally, the OK a:id IT mechanisms must be reset. OK and IT are two flags used by GPSS-F for reasons explained in sections 3.5 and 7.3.3.</span></p>
<p><span class="font48">&quot;Activate the transaction&quot;</span></p>
<p><span class="font48">MADDR « AL(LTX,1) LFAM s 0</span></p>
<p><span class="font48">IF(TX(LTX<sub>9</sub>2).EQ.O) RETURN 2 DO 400 J s 1 , &quot;FAM1&quot; IF(TX(LTX<sub>f</sub>1).EQ.FAM(J,1)) GOTO 450 400 CONTINUE RETURN 2 450 LFAM s J RETURN 2 END</span></p>
<p><span class="font48">A transaction is considered active when the variables LTX and possibly LFAM are set to show that it is active. LTX contains the line number of the transaction's entry in the TX matrix. If the transaction is a family member, the line number of its family entry in the family matrix is set in LFAM.</span></p>
<p><span class="font48">Since a transaction is now active, ACTIV2 exits to the target selector. The target selector then Jumps to the statement number contained in NADDR.</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font48"><sup>1</sup> Each transaction that has been active can have changed the system's state before it became inactive again. Thus, whenever a transaction is deactivated, ACTIV2 must receive control in order to test whether any conditioned activations have become possible. Every time anything happens, ACTIV2 asks again,, 'have any wait conditions been satisfied?' Once ACTIV2 has found all of the conditioned activations it can (perhaps none), it returns to ACTIV1.</span></p>
<p><span class="font48">•&nbsp;ACTIV2 undertakes conditioned activations in the order it finds them. If, at some given time, a conditioned activation is possible at more than one station, ACTIV2 prefers the station it happens to find first. That sequence can be altered by rewriting this subroutine.</span></p>
<p><span class="font48">•&nbsp;ACTIV2 searches the activation list only for block . codes between -1 and -&quot;KEND&quot;. By that means, it restricts itself to transactions whose re-activation transaction management administers, overlooking any locked transactions.</span></p>
<p><span class="font48">A start (explained in section 2.5.3) is undertaken by replacing the lock code -(K+^KEND&quot;) with the block code -K. The next</span></p>
<p><span class="font48">time ACTIV2 is called, the started transactions are tested for possible activation along with the other blocked transactions.</span></p>
<p><span class="font48">2.4 Transaction Generation and Annihilation</span></p>
<p><span class="font48">When a transaction enters a system, it has been, from the system's naive viewpoint, created or generated; when a transaction leaves the system, it has been, so far as the system cares, annihilated. GPSS-F has special programs for generating and annihilating transactions.</span></p>
<p><span class="font48">2.4.1 GENERA&nbsp;* Purpose:</span></p>
<p><span class="font48">This subroutine creates transactions and fills in important</span></p>
<p><span class="font48">private parameters for the transaction.&nbsp;It also schedules an</span></p>
<p><span class="font48">event, the next generation by the source&nbsp;responsible for the present one.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL GENERA (ET,ZTX,PR<sub>t</sub>ID,41006,IPRINT)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">Emission interval</span></p>
<p><span class="font48">This specifies how much time should ellapse before the source generates another transaction. If the simulator's clock shows time T when GENERA is called, the next generation will occur at time T ♦ ET. Generation limit</span></p>
<p><span class="font48">The user specifies for each source, how many transactions it may generate before being shut down. When the limit is reached, GENERA generates no transaction and schedules no new generation. Priority</span></p>
<p><span class="font48">A transaction's priority is specified at generating time</span></p>
<p><span class="font45" style="font-weight:bold;">and set in TX(LTX,4) .</span></p>
<p><span class="font48">GENERA CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">This statement number is entered in the event list as the event's target. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">GENERA takes an addressed exit to statement 1006, if it cannot find the source responsible for the generation, or if the transaction cannot be generated because the TX matrix is already full. It Is recommended in both cases to stop the simulation. (A simulation ends normally by passing control to the final analysis section of the GPSS-F chassis, which bears statement number 1006.) Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT * 0.</span></p><div>
<p><span class="font48">ET</span></p>
<p><span class="font48">ZTX</span></p>
<p><span class="font48">PR</span></p>
<p><span class="font45" style="font-weight:bold;">ID</span></p>
<p><span class="font45" style="font-weight:bold;">41006</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">IPRINT</span></p></div>
<p><span class="font48"><a name="bookmark218"></a>Data area:</span></p>
<p><span class="font48">GENERA uses the TX and source matrices• Each source has a line in the source matrix (SRC matrix)<sub>9</sub> which is defined as follows:</span></p>
<p><span class="font48">INTEGER SRC</span></p>
<p><span class="font48">DIMENSION SRC(&quot;SRCI&quot;<sub>9</sub>2)</span></p>
<p><span class="font48">The two fields in each line have the following meanings:</span></p>
<p><span class="font48">SRC(J,1) Event-list pointer</span></p>
<p><span class="font48">Each event calling for the generation of a transaction has an entry in the event list* This field points to the line in the list where this source's next generation is scheduled.</span></p>
<p><span class="font48">SRC(J<sub>9</sub>2) Transactions counter.</span></p>
<p><span class="font48">Each time a transaction is generated for this source, this counter is incremented by 1.</span></p>
<p><span class="font48">GENERA also uses the variable NTXC to assign each newly generated transaction a unique Identifying number. Each time JLt generates a transaction<sub>9</sub> it increments NTXC by 1.&nbsp;~</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">&quot;Find the source&quot;</span></p>
<p><span class="font48">DO 100 J = 1 <sub>9</sub> &quot;SRC1&quot; IF(SRC(J<sub>9</sub>1).EQ.LEV) GOTO 150 100 CONTINUE RETURN 1</span></p>
<p><span class="font48">GENERA finds the source responsible for generating this transaction by searching the SRC matrix for the entry whose first field, SRC(J,1), matches the event list's line pointer, LEV. The contents of SRC(J,1) will have been set when generation was scheduled<sub>9</sub> either by a call to EVENT, or by the last call to GENERA for the source.</span></p>
<p><span class="font48">&quot;Advance the counters&quot;</span></p>
<p><span class="font1">#</span></p>
<p><span class="font48">150 SRC(J,1) = 0</span></p>
<p><span class="font48">SRC(J,2) a SRC(J,2) ♦ 1 NTXC s NTXC ♦ 1</span></p>
<p><span class="font48">The counter NTXC and the count of the number of transactions already generated by the current source are incremented by 1.</span></p>
<p><span class="font48">&quot;Generate&quot;</span></p>
<p><span class="font48">DO 200 LTX s 1 , &quot;TX1&quot; IF(TX(LTX,1).EQ.0) GOTO 250 200 CONTINUE RETURN 1 250 TX(LTX.I) s NTXC</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">GENERA uses the ?X and source matrices. Each source has a line in the source matrix (SRC matrix), which is defined as follows:</span></p>
<p><span class="font48">INTEGER SRC</span></p>
<p><span class="font48">DIMENSION SRC(&quot;SRC1&quot;,2)</span></p>
<p><span class="font45" style="font-weight:bold;">$1</span></p>
<p><span class="font48">The two fields in each line have the following meanings:</span></p>
<p><span class="font48">SRC(«J,1) Event-list pointer</span></p>
<p><span class="font48">Each event calling for the generation of a transaction has an entry in the event list. This field points to the line in the list where this source's next generation is scheduled.</span></p>
<p><span class="font48">SRC(J<sub>f</sub>2) Transactions counter.</span></p>
<p><span class="font48">Each time a transaction is generated for this source, this counter is incremented by 1•</span></p>
<p><span class="font48">GENERA also uses the variable NTXC to assign each newly generated transaction a unique identifying number. Each time^it generates a transaction, it increments NTXC by 1.&nbsp;<sub>#</sub></span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">&quot;Find the source&quot;</span></p>
<p><span class="font48">DO 100 J s 1 <sub>f</sub> «SRC1&quot; IF(SRC(J,1).EQ.LEV) GOTO 150 100 CONTINUE RETURN 1</span></p>
<p><span class="font48">GENERA finds the source responsible for generating this transaction by searching the SRC matrix for the entry whose first field, SRC(J,1), matches the event list's line pointer, LEV. The contents of SRC(J,1) will have been set when generation was scheduled, either by a call to EVENT, or by the last call to GENERA for the source.</span></p>
<p><span class="font48">&quot;Advance the counters&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">150 SRC(J,1) s 0</span></p>
<p><span class="font48">SRC(J,2) s SRC(J,2) ♦ 1 NTXC s NTXC ♦ 1</span></p>
<p><span class="font48">The counter NTXC and the count of the number of transactions already generated by the current source are incremented by 1.</span></p>
<p><span class="font48">&quot;Generate&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 200 LTX s 1 &quot;TX1&quot; IF(TX(LTX,1).EQ.0) GOTO 250 200 CONTINUE RETURN 1 250 TX(LTX,1) s NTXC</span></p>
<p><span class="font48">TX(LTX<sub>f</sub> 3) * T TX(LTX<sub>f</sub>4) u PR</span></p>
<p><span class="font48">An empty line is sought in the TX matrix. Here, the generation time, the priority and the transaction number are entered. If no empty line can be found, the error exit is taken.</span></p>
<p><span class="font48">&quot;Reset the event list&quot;</span></p>
<p><span class="font48">IF(LTX.GT.LAL) LAL * LTX IF(SRC(J,2).GE.ZTX) RETURN SRC(J,1) * LEV EL(LEV,1) s ID EL(LEV,2) s T ♦ ET IF(LEV.GT.LEL) LEL » LEV RETURN END</span></p>
<p><span class="font48">If the source hasn't yet reached its generation limit, GENERA schedules it to generate another transaction. The list-end pointer, LEL, shows how far the event list is filled in with scheduled events. If GENERA makes an entry beyond that point (which ACTIV1 counted down, if necessary, when it erased the event from the event list), it must reset LEL.</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font48">*&nbsp;When a transaction is generated, it is active. Its line number in the TX matrix is placed in LTX and its activity continues with the statement following the call to GENERA.</span></p>
<p><span class="font48">•&nbsp;A given call to GENERA can generate a transaction for any source; there is no one-to-one correspondence between sources and calls to GENERA. Which source is responsible for the transaction generated by a particular call is determined by the contents of the event list and the source matrix.</span></p>
<p><span class="font48"><sup>9</sup> The user must schedule the first generation for each source by calling EVENT. Normally, he does that in section 6 of the chassis, &quot;Schedule the first events<sup>91</sup>. GENERA schedules subsequent generations automatically.</span></p>
<p><span class="font48">2.4.2 TERMIN Purpose:</span></p>
<p><span class="font48">TERMIN annihilates a transaction by clearing its line in the TX matrix. In case the transaction was the last surviving member of its family, its entry in the family matrix is cleared as well.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL TERMIN (&amp;1005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">«a</span></p>
<p><span class="font48">p«ru«tiru</span></p>
<p><span class="font48">A1005 Exit to transaction management</span></p>
<p><span class="font48">After a tranaaotlon has been annihilated, tranaaotlon Management must be called to activate the next tranaaotlon« 1005 la the number of the CALL ACTIV2 statement. I Fit INT Trace flag</span></p>
<p><span class="font48">Trace printouts are suppressed when IPRINT «0.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">TERMIN uses the activation list and the TX matrix. If the transaction to be annihilated is a family member, the FAM and ASH matrices are used as well.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48"><a name="bookmark219"></a>•Family&quot;</span></p>
<p><span class="font48">IF(LFAM.EO.O) 00T0 200 FAM(LFAM,2) * FAH(LFAM<sub>f</sub>2) - 1 IF(FAM(LFAH<sub>f</sub>2).GT.0) GOTO 200 DO 100 IB « I , 3 100 FAM(LFAM<sub>f</sub>IB) s 0</span></p>
<p><span class="font48">DO 110 IB • V , &quot;ASM1&quot; 110 ASM(LFAM,IB) « 0 LFAM « 0</span></p>
<p><span class="font48">For family members, the counter in FAM(LFAM<sub>f</sub>2) is decremented. If the transaction is the last surviving member of the family, the family's data areas are cleared.</span></p>
<p><span class="font48"><sup>19</sup> Annihilate&quot;</span></p>
<p><span class="font48">200&nbsp;DO 201 IA «&nbsp;1 , &quot;TX2&quot;</span></p>
<p><span class="font48"><a href="#bookmark220">201&nbsp;TX(LTX<sub>V</sub>IA) a&nbsp;0</a></span></p>
<p><span class="font48"><a href="#bookmark221">DO 202 IA *</span><span class="font48" style="font-variant:small-caps;">&nbsp;1</span><span class="font48"> i 2</span></a></p>
<p><span class="font48"><a href="#bookmark222">202&nbsp;AL(LTX,IA) *&nbsp;0</a></span></p>
<p><span class="font48">A transaction Is annihilated by clearing its line in the TX matrix and in the activation list.</span></p>
<p><span class="font48">&quot;Reset the llst~end pointer, LAL&quot;</span></p>
<p><span class="font48">250 IF(TX(LAL,1).NE.O.OR.LAL.EQ.1 ) RETURN 1 LAL * LAL - 1 GOTO 250 END</span></p>
<p><span class="font48">When the last transaction In the activation list 1s annihilated, the list-end pointer must</span><span class="font45" style="font-weight:bold;"> be</span><span class="font48"> decremented, perhaps by several lines. The latter is the</span><span class="font45" style="font-weight:bold;"> case</span><span class="font48"> when there are gaps in the next-to-last positions in the list, say from previous annihilations.</span></p>
<p><span class="font48">2.5 Transaction-State Management</span></p>
<p><span class="font48">Among GPSS-F's model-building subroutines are several whose only function is to alter the transaction's state, say from active to scheduled, or from locked to blocked* Such subroutines are discussed in this section.</span></p>
<p><span class="font48">2.5.1 ADVANC Purpose;</span></p>
<p><span class="font48">A CALL ADVANC statement deactivates a transaction for a specified time by placing it in the scheduled state. The call also specifies the transaction's re-activation target.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL ADVANC (AT,IDN,&amp;1005<sub>f</sub>IPRINT)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">AT&nbsp;Detention time</span></p>
<p><span class="font48">This parameter specifies how long the transaction is to be detained at its present position in the system. ADVANC can detain a transaction while it occupies a station or while it is underway between stations. If the simulator's clock shows time T when ADVANC is called, the transaction is scheduled to be re-activated at time T ♦ AT. IDN&nbsp;Target</span></p>
<p><span class="font48">After ACTIV1 re-activates the transaction, it passes control to this statement number. &amp;1005 Exit to transaction management</span></p>
<p><span class="font48">ADVANC detains a transaction, wherever it happens to be, by deactivating it and placing it in the scheduled state. Following deactivation, transaction management is called to activate a new transaction. IPRINT Trace flag</span></p>
<p><span class="font48">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">ADVANC uses the activation list.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">&quot;Detain&quot;</span></p>
<p><span class="font48">AL(L7X,1) = IDN AL(LTX,2) = T ♦ AT RETURN 1 END</span></p>
<p><span class="font48">The new activation time and target statement number are entered in the activation list.</span></p>
<p><span class="font48">2.5*2 BUFFER Purpose:</span></p>
<p><span class="font48">BUFFER deactivates a transaction. The transaction is scheduled for the current time T<sub>9</sub> but first, all transactions for which a conditioned activation is possible are processed.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL BUFFER (IDN<sub>9</sub>&amp;1005<sub>9</sub>IPRINT)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">IDN&nbsp;Target</span></p>
<p><span class="font48">When the transaction is re-activated<sub>9</sub> it resumes its activity at this statement number.</span></p>
<p><span class="font48">&amp;1005 Exit to transaction management</span></p>
<p><span class="font48">After the currently active transaction has been deactivated <sub>9</sub> ACTIV2 must be called so that it can search out all transactions whose conditioned activation is possible.</span></p>
<p><span class="font48">IPRINT Trace flag</span></p>
<p><span class="font48">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">BUFFER uses the activation list.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description: &quot;Deactivate&quot;</span></p>
<p><span class="font48">AL(LTX<sub>f</sub>1) s IDN AL(LTX<sub>f</sub>2) s T RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">The currently active transaction is re-scheduled for the same time<sub>9</sub> In that the target statement number and the current clock time T are entered for it In the activation list. Then BUFFER returns to ACTIV2<sub>f</sub> which seeks out all possible conditioned activations before it passes control to ACTIV1 to search for scheduled activations. Thus<sub>f</sub> the desired effect is achieved.</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>11</sup> BUFFER places a transaction in the scheduled state. Since the activation time specified is the current clock time, a call to BUFFER is equivalent to a call to ADVANC with AT = 0.</span></p>
<p><span class="font48">2.5.3 UNLOCK Purpose:</span></p>
<p><span class="font48">UNLOCK places locked transactions in the blocked state; transaction management can then administer their re-activation. That state transition is called a start. When UNLOCK is called, it starts all transactions waiting at the station specified in its parameter list.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL UNLOCK (K<sub>9</sub>IPRINT)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">K&nbsp;Station number</span></p>
<p><span class="font48">The transactions waiting at the station whose number is K are placed in the blocked state. The transition is carried out only for stations where waiting transactions can be locked<sub>9</sub> i.e. storages and type-1 gates. IPRINT Trace flag</span></p>
<p><span class="font48">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">UNLOCK uses the activation list.</span></p>
<p><span class="font48">Algorithm description:</span></p>
<p><span class="font48">&quot;Start&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">Kl s - &quot;KEND&quot; - K DO 100 I s 1 <sub>f</sub> LAL IF(AL(I<sub>f</sub>2).NE.K1) GOTO 100 AL(I<sub>V</sub>2) r - K 100 CONTINUE RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">Locked transactions have the lock code -&quot;KEHD<sup>I,</sup>-K in their</span><span class="font48"> ac-</span><span class="font45" style="font-weight:bold;">tivation-list entries. The code is replaced with -K. In this</span><span class="font48"> way, </span><span class="font45" style="font-weight:bold;">the transactions are placed under transaction management's supervision.</span></p>
<p><span class="font45" style="font-weight:bold;">2.6 The Chassis</span></p>
<p><span class="font45" style="font-weight:bold;">The GPSS-F chassis determines how a simulator program is constructed by specifying the position of various sections of the program. When the user writes a simulator program, he inserts the statements (mostly calls) necessary to represent his model into the proper sections of the chassis. (See appendix A4.)</span></p>
<p><span class="font48">2.6.1 Chassis Sections</span></p>
<p><span class="font48">The chassis is divided into 12 sections, each with its own function. Some of the sections are fixed and not to be altered; others are meant to be filled in by the user.</span></p>
<p><span class="font48">•1. General Fortran declarations&quot;</span></p>
<p><span class="font48">In this section, all arrays are dimensioned<sub>9</sub> variable-type conventions specified and COMMON areas declared. The user must enter any declarations needed for his own variables.</span></p>
<p><span class="font48">&quot;2. Statement functions&quot;</span></p>
<p><span class="font39" style="font-style:italic;">■mr</span></p>
<p><span class="font48">The user must define here any statement functions he uses.</span></p>
<p><span class="font48">&quot;3- Clear the data areas&quot;</span></p>
<p><span class="font48">Subroutine RESET clears all data areas belonging&nbsp;immediately</span></p>
<p><span class="font48">to GPSS-F. If his own data areas need clearing, the&nbsp;user must clear them himself.</span></p>
<p><span class="font48">&quot;4. Initialize constants and control variables&quot;&nbsp;•</span></p>
<p><span class="font48">The policy, strategy and plan matrices are initialized. If the user doesn't initialize these data areas, they are processed using the default values specified by GPSS-F. The capacities of the storages must be entered in the STO matrix and the multifa-cillty capacities must be set in the MFAC matrix. The use of those matrices is explained in chapters 3» 5 and 6.</span></p>
<p><span class="font48">The INITn subroutines initialize GPSS-F's control variables. INIT1 sets the starting values for the random number generators. INIT2 constructs the multifacilities' data areas and INIT3 constructs the addressible storages' data areas, each from the appropriate capacity specifications.</span></p>
<p><span class="font48">&quot;5. Read in control values, initial values and function-value tables&quot;</span></p>
<p><span class="font48">It is often useful to read in certain values, instead of specifying them in the simulation program. The function ITREAD is a-vallable for helping in this task; it reads and echo-prints integers in 110 format.</span></p>
<p><span class="font48">&quot;6. Schedule the first events&quot;</span></p>
<p><span class="font48">In order to set the simulation rolling, the user must schedule some event. Normally, the first event will be a transaction's generation, scheduled by calling EVENT and specifying a call to GENERA as target.</span></p>
<p><span class="font48">&quot;7. Flow management 1: Events and scheduled activations&quot;</span></p>
<p><span class="font48">Simulation gets under way in this section. ACTIV1 seeks out the earliest event or scheduled activation and sets it in motion* at the same time clearing its entry from the list.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;8. Target selector<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">This section Jumps to the part of the program meant to carry out the state transition for an event or an activated transaction. The target selector consists of a computed GOTO, which Jumps to the statement number specified in the system's variable, NADDR. It must contain all statement numbers occurring as targets in the next section. The user must write the target selector.</span></p>
<p><span class="font45" style="font-weight:bold;">Model&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">The user must write his model, which will consist mainly of calls to GPSS-F subroutines. Any statement that flow management should be able to Jump to must bear a statement number, preferably between 1 and 999, so as not to conflict vith other statement numbers in the chassis.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;10. Flow management 2: Conditioned_activations&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">Each time an active transaction becomes inactive, ACTIV2 tests whether any new conditioned activations have become possible. If so, it activates one of the waiting transactions and returns to section 8, which Jumps to part of the model; otherwise, it returns to section 7, which searches for the next scheduled activation.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;11. Final analysis&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine ENDBIN is called, which computes final values for all transactions whose behaviour has been assembled in bins (see 10.1). Otherwise, the user must write this section to analyze the results of his simulation.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;12. Print results&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">Here, the user prints out the results of his simulation. It is always a good idea to look over the final state of the model. Subroutine REPORT makes that easy by printing out the contents of all of GPSS-F's data areas.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">• The chassis' structure clarifies flow control's procedure. First, an event takes place or a scheduled transaction is activated. Then, when the event has occured or the transaction has concluded its activity, the system's new state is checked to see whether any conditioned activations have become possible. Only when there are no more conditioned activations to carry out, will the next event occur or scheduled activation be undertaken. The following sequence is thus in force:</span></p>
<p><span class="font45" style="font-weight:bold;">Event or scheduled activation</span></p>
<p><span class="font45" style="font-weight:bold;">All conditioned activations thus made possible Event or scheduled activation</span></p>
<p><span class="font45" style="font-weight:bold;">ACTIV1: EVENT OR SCHEDULED ACTIVATION</span></p>
<p><span class="font45" style="font-weight:bold;">YES</span></p>
<p><span class="font43" style="font-style:italic;">• UO</span></p><div>
<p><span class="font45" style="font-weight:bold;">TARGET SELECTOR</span></p></div>
<p><span class="font45" style="font-weight:bold;">| L s HAVE ALL POSSIBLE CONDITIONED ACTIVATIONS BEEN UNDERTAKEN?</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">V</span></p>
<p><span class="font45" style="font-weight:bold;">MODEL</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">V</span></p>
<p><span class="font45" style="font-weight:bold;">ACTIV2: CONDITIONED ACTIVATION</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45">FIGURE 12&nbsp;FLOW MANAGEMENT'S PROCEDURE</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">• A transaction schedules itself to free a facility. At the appointed time, ACTIV1 activates it; when ACTIV2 receives control, the facility will be ready to . accept another transaction. If there are any transactions waiting at the facility, a conditioned activation has become possible.&nbsp;<sub>é</sub></span></p>
<p><span class="font45" style="font-weight:bold;">2.6.2 INIT1 Purpose:&nbsp;<sup>1</sup></span></p>
<p><span class="font45" style="font-weight:bold;">INITt initializes the requisite values for the random number generators.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL INIT1</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">INIT1 uses the area COMMON/DRN/.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the multipliers&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">All of GPSS-F's random number generators are indepent from one another. Independence is insured by the fact that each generator has its own multiplier for its iterative routine. The multipliers are stored in DFACT(RNUM)• The multipliers are set .according to the requirements explained in sections 9*2 and 9.4.1. (See also appendix A5.)</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Specify constants and modulo&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DMODUL s 2.*•30 DO 10 I s 1 , &quot;DRH1&quot; 10 DCONST(I) s 227623267.</span></p>
<p><span class="font45" style="font-weight:bold;">The values of the additive constants and the modulo are set.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the starting values&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 20 1*1 <sub>9</sub> &quot;DRN1&quot; 20 DRN(I) s 1. RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">Each random number generator receives its own starting value</span></p>
<p><span class="font48"><a name="bookmark223"></a>2.6.3 IMIT2 </span><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font48">Subroutine INIT2 divides up the servloe element matrix to eor-respond to the individual multifaellitles. (See 5*1)</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL INIT2 (49999)</span></p>
<p><span class="font48">Parameters:</span></p>
<p><span class="font48">49999 List-end exit</span></p>
<p><span class="font48">If the sum of the service elements of all multifaellitles is larger than the number of available lines In the SE matrix, simulation is broken off at once.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">INIT2 uses the data'area COMMON/MFA/.</span></p>
<p><span class="font48">Algorithm description:&nbsp;•</span></p>
<p><span class="font48">&quot;Specify the multifaellitles used&quot;</span></p>
<p><span class="font48">LSE a 1</span></p>
<p><span class="font48">DO 100 I s 1 , •HFAC1&quot; IF(MFAC(I,2).EQ.0) GOTO 100</span></p>
<p><span class="font48">The user must fill in the second field of each line in the MFAC matrix, MFAC(MFA,2), with the number of the service elements for that multifacility. If the multlfacllity's entry in this field is zero, it is assumed to remain unused; INIT2 sets up no space in the SE matrix for it.</span></p>
<p><span class="font48">&quot;Set up a section of the SE matrix&quot;</span></p>
<p><span class="font48">MBV(I) s LSE LSE s LSE ♦ MFAC(I,2) IF(LSE-1.GT.&quot;SE1&quot;) GOTO 200 100 CONTINUE</span></p>
<p><span class="font48">RETURN 200 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">Each section of the SE matrix contains the data areas for the service elements of a multifacility. Each section of the SE matrix is .specified by the number, called the basis number, of its first line. In each pass through the loop, the basis number of the next section is determined and entered in the multifacility basis vector. In case INIT2 runs over the end of the SE matrix, it aborts the simulation.</span></p>
<p><span class="font50" style="font-weight:bold;"><a name="bookmark224"></a>Votes:</span></p>
<p><span class="font50" style="font-weight:bold;"><a name="bookmark225"></a>• IMT2 may not be called before the end of section H of the chassis, since construction of the SE matrix depends on values entered in the NFAC matrix.</span></p>
<p><span class="font48">2.6.* INIT3 Purpose:</span></p>
<p><span class="font48">Subroutine INIT3 divides up the segment matrix</span><span class="font50" style="font-weight:bold;"> to correspond </span><span class="font48">to the capacities of the storages. (See 6.4.1.)</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL INIT3 (49999) Parameters:</span></p>
<p><span class="font48">49999 List-end exit</span></p>
<p><span class="font48">When the sum of the capacities of the addresslble storages is larger than the number of lines allocated to the segment matrix, simulation is aborted.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">INIT3 uses areas COMMON/SBV/, COMMON/STO/ and COMMON/STR/. Algorithm description: &quot;Check for addressibiiity&quot; LSM r 1</span></p>
<p><span class="font48">DO 100 I s 1 , &quot;ST01&quot; IF(STRAMA(I,1).EQ.O) GOTO 100</span></p>
<p><span class="font48">The user specifies in the strategy matrix (STRAMA) which strategy is to be used to allocate and free storages (see 6.5). If a line of this matrix is empty, then INIT3 assumes it isn't dealing with an addresslble storage. In that case, it doesn't set up a section in the segment matrix.</span></p>
<p><span class="font48">&quot;Set up a section in the segment matrix**</span></p>
<p><span class="font45" style="font-weight:bold;">SBV(I) r LSM SM(LSM,1) = ST0(1,2) SM(LSM,2) s - 1 LSM s LSM ♦ ST0(I,2) IF(LSM-1 . GT.&quot;SM1**) GOTO 200 100 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 200 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">A</span><span class="font48"> section is set up in the segment matrix by setting its</span><span class="font45" style="font-weight:bold;"> ba-</span></p>
<p><span class="font47" style="font-weight:bold;">sls-llne number In the storage basis vector. Then the entire segment Is aarked with Its length and an Indicator showing that It Is free. The length of the section corresponds to the capacity of the storage.</span></p>
<p><span class="font47" style="font-weight:bold;">In each pass through the loop, the basis number for the next seotlon Is computed. If the number runs over the end of the segment matrix, simulation Is aborted.</span></p>
<p><span class="font47" style="font-weight:bold;">Note:</span></p>
<p><span class="font47" style="font-weight:bold;">* INIT3 may not be called before the end of section 4 of the chassis, since the stragegy and STO matrices must be filled In first.</span></p>
<p><span class="font45" style="font-weight:bold;">2.6.5 RESET Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine RESET clears all of GPSS-F's data areas. Calling sequence: CALL RESET Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">All of the data areas to be cleared are In COMMON.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Clear the simulation clocks&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">T s 0 RT s 0</span></p>
<p><span class="font45" style="font-weight:bold;">At simulation start, the simulation clocks are set to zero.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the OK and IT mechanisms&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">OK s 0 </span><span class="font45">IT = 0</span></p>
<p><span class="font45" style="font-weight:bold;">These mechanisms require that the OK and IT flags be pre-set</span></p>
<p><span class="font45" style="font-weight:bold;">to zero.&nbsp;(See 3-<sup>i</sup>* and 5.3.3.)</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Reset the NTXC counter&quot;</span></p>
<p><span class="font45">MTXCs 0</span></p>
<p><span class="font45" style="font-weight:bold;">The counter NTXC is zeroed.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Reset the list<sub>r</sub>end pointers'*</span></p>
<p><span class="font45" style="font-weight:bold;">LEL »1 LAL = 1</span></p>
<p><span class="font45" style="font-weight:bold;">The two list-end pointers<sub>9</sub> which show how far the event and activation lists need to be searched, are reset*</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Clear the data areas&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">(Program listed in appendix A5.)</span></p>
<p><span class="font45" style="font-weight:bold;">All of GPSS-F's data areas are cleared at start of simulation.</span></p>
<p><span class="font56" style="font-weight:bold;">3</span><span class="font48"> STATIONS AND POLICIES</span></p>
<p><span class="font48">If a GPSS-F station cannot process an arriving transaction immediately <sub>9</sub> the arrival is placed in the wait state. That can happen, in principle, at any GPSS-F station; the particular circumstances that determine whether an arriving transaction must wait include the station's type and current state. A transaction that must wait is placed in the wait queue (or simply queue) in front of the station. When the ; station is again ready, one of the transactions in its queue is selected and activated, so that it may begin its processing phase. The procedure by which a waiting transactions is selected is called a policy.</span></p>
<p><span class="font48">In .general, a station that is ready to process a transaction is said to be accessible; in the reverse case, inaccessible. Facilities, for example, are accessible precisely when they are not occupied by a transaction, but the accessibility of other types of stations may be a a more complex matter. The types of GPSS-F stations and the chapters where they are discussed in detail are listed below:</span></p>
<table border="1">
<tr><td>
<p><span class="font48">a</span></p></td><td>
<p><span class="font48">Facility (4)</span></p></td></tr>
<tr><td>
<p><span class="font53">•</span></p></td><td>
<p><span class="font48">Multifacility (5)</span></p></td></tr>
<tr><td>
<p><span class="font48">a</span></p></td><td>
<p><span class="font48">Storage (6)</span></p></td></tr>
<tr><td>
<p><span class="font51">•</span></p></td><td>
<p><span class="font48">Type-1 Gate (7)</span></p></td></tr>
<tr><td>
<p><span class="font48">a</span></p></td><td>
<p><span class="font48">Type-2 Gate (7)</span></p></td></tr>
<tr><td>
<p><span class="font48">a</span></p></td><td>
<p><span class="font48">Gather station (7)</span></p></td></tr>
<tr><td>
<p><span class="font49">•</span></p></td><td>
<p><span class="font48">Gather station for families (8)</span></p></td></tr>
<tr><td>
<p><span class="font57" style="font-weight:bold;">•</span></p></td><td>
<p><span class="font48">User chain and trigger station (7)</span></p></td></tr>
<tr><td>
<p><span class="font50">•</span></p></td><td>
<p><span class="font48">User chain and trigger station for families (8) *</span></p></td></tr>
</table>
<p><span class="font45" style="font-weight:bold;">3.1 Policies</span></p>
<p><span class="font45" style="font-weight:bold;">From a systems-analytic viewpoint, each transaction-oriented system is composed of elementary subsystems. Each of these subsystems consists of a station and its queue (see figure 13). Of the many types of policies for selecting transactions from a queue, the following sections set out the most important.</span></p>
<p><span class="font45" style="font-weight:bold;">3.1.1 Priority and Preemption</span></p>
<p><span class="font45" style="font-weight:bold;">The criterion by means of which a transaction is selected from a queue is reflected in the transaction's priority. High priority</span></p>
<p><span class="font48">means greater importance and sooner selection from the queue, A priority-driven policy searches a given queue for the the trans« action with the highest priority and selects It to be activated*</span></p>
<p><span class="font48">Priority-driven policies give preference to the Important transactions<sub>9</sub> but in systems with long queues<sub>9</sub> low-priority transactions nay not be processed sufficiently<sub>f</sub> or even at all*« Other kinds of policies take pains to avoid unjustlfiedly handicapping low^priority transactions.</span></p>
<p><span class="font48">In especially pressing cases<sub>9</sub> we may even want to clear a cur* rently occupied station to permit an especially Important arrival to be processed immediately* The mechanism for doing that is called preemption* Preemptions always take up some amount of time* Thus, though a policy with preemption can always react quickly to pressing cases<sub>9</sub> this advantage is bought at the cost of setup time<sub>9</sub> which increases administrative overhead*</span></p>
<p><span class="font48">In a system with priority management and preemption» every imaginable policy can be built*</span></p>
<p><span class="font45" style="font-weight:bold;">-----------• - I&nbsp;I</span></p>
<p><span class="font48">III I II I II I----1 STATION I</span></p>
<p><span class="font45" style="font-weight:bold;">----------• I&nbsp;I</span></p>
<p><span class="font48">WAIT QUEUE&nbsp;----------------</span></p>
<p><span class="font48">FIGURE 13&nbsp;STATION WITH QUEUE</span></p>
<p><span class="font45" style="font-weight:bold;">3-1.2 FIFO (First In<sub>9</sub> First Out)</span></p>
<p><span class="font45" style="font-weight:bold;">The FIFO policy assigns priorities according to arrival time: the transaction longest in the queue gets the highest priority. FIFO's principle is &quot;first-come, first-served&quot;; it corresponds to a simple ideal of fair treatment. A preemptive FIFO policy clears a station to allow an arriving transaction to be processed, if the arriving transaction has the higher priority.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font48">* A</span><span class="font45" style="font-weight:bold;"> doctor's patients are admitted according to their order of arrival in the waiting room. When an emergency case arrives, the patient being treated at the moment must return to the waiting room. He has been preempted.</span></p>
<p><span class="font45" style="font-weight:bold;">3.1.3 LIFO (Last In, First Out)</span></p>
<p><span class="font45" style="font-weight:bold;">Where FIFO selected the transaction longest in the queue, LIFO selects the newest. LIFO works according to the stacking principle: incoming work goes on top of the stack and the stack is worked off top-down.</span></p>
<p><span class="font47" style="font-weight:bold;"><a name="bookmark226"></a>Example</span></p>
<p><span class="font47" style="font-weight:bold;">• Tourists rids to the top of the Washington Monument in an elevator. The last tourist in the elevator is the first tourist out.</span></p>
<p><span class="font48">3*1SJF (Shortest Job First)</span></p>
<p><span class="font48">SJF assigns the highest priority to the transactions with the shortest processing times. Throughput can be optimized in this way, i.e. the greatest number of tasks can be processed and the largest number of customers satisfied. The moral of this policy is that it's a good idea to do the short work as fast as possible before starting in on the tough work.</span></p>
<p><span class="font48"><a name="bookmark227"></a>Examples</span></p>
<p><span class="font50" style="font-weight:bold;">• A</span><span class="font48"> computer's operating system gives shorter jobs higher priority. Long jobs have to settle for long waiting times since they take up large portions of the system's available resources. SJF can be equipped with preemption, just like any other policy.</span></p>
<p><span class="font48">3*1*5 Round-Robin (Cyclic Policy)</span></p>
<p><span class="font48">Round-robin gives each waiting transaction a time slice on the station. At the end of the slice, round-robin checks whether the transaction has been completely processed: if so, it can leave the station; otherwise, it's thrown back in the queue and its remaining processing time is noted. (See figure 14.) This policy assumes it's a good idea to process each transaction a little bit, then go on to the next. It is especially useful when waiting transactions can tend to other matters in between being processed by the station, say matters not involving this station.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">• In a time-sharing computer system, each user gets a slice of time every so often. Each job gets processed, though the rule is: the</span><span class="font45" style="font-weight:bold;"> more users</span><span class="font48">, the slower everybody runs.</span></p>
<p><span class="font48">Round-robin can be implemented, of course, only when preemption is available: each task gets preempted at the end of its time slice. A task is, however, not preempted because a higher-priority task arrives; it is preempted on account of a regular report from the clock.</span></p>
<p><span class="font48">Round-robin is more flexible when the time slices are assigned on the basis of transaction priority instead of being constant. Such a policy is called</span><span class="font45" style="font-weight:bold;"> RRP</span><span class="font48"> (Round-Robin with priorities).</span></p>
<p><span class="font50">• •</span></p>
<p><span class="font35"><a href="#bookmark228">—--- * •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><sup><a href="#bookmark229">11</sup> I&nbsp;I&nbsp;•&nbsp;«</a></span></p>
<p><span class="font45" style="font-weight:bold;">TP*</span></p>
<p><span class="font45" style="font-weight:bold;">I III! I I I----1 STATION j----• FINISHED ?</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark230">I&nbsp;I •&nbsp;•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark231">WAIT QUEUE&nbsp;—---------------•&nbsp;•</a></span></p>
<p><span class="font58" style="font-weight:bold;"><a name="bookmark232"></a>• •</span></p>
<p><span class="font45" style="font-weight:bold;">I NO</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">FIGURE 14&nbsp;ROUND-ROBIN POLICY</span></p>
<p><span class="font45" style="font-weight:bold;">QUEUE</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark233">(ROUND-ROBIN) _________• •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark234">—&gt; nun i—&nbsp;« •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark235">_________• i _______________„ • •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark236">Il I • «YES I----1 STATION |----• FINISHED ? •---&gt;</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark237"><a name="bookmark237"></a>I I •</span><span class="font47" style="font-weight:bold;">&nbsp;• _________» j ________________ • •</span></a></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark238">-&gt; huh i—&nbsp;• •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark239">i_________• •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark240">QUEUE&nbsp;| NO</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark241">I (FIFO)&nbsp;|</a></span></p>
<p><span class="font40">*</span></p>
<p><span class="font57" style="font-weight:bold;">• • • •</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark242">I&nbsp;___. YES •&nbsp;«</a></span></p>
<p><span class="font45" style="font-weight:bold;">-------------------------------• N s 0 ? •</span></p>
<p><span class="font57" style="font-weight:bold;"><a name="bookmark243"></a>• •</span></p>
<p><span class="font57" style="font-weight:bold;"><a name="bookmark244"></a>• • • /</span></p>
<p><span class="font45" style="font-weight:bold;">| NO</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 15</span></p></div>
<p><span class="font45" style="font-weight:bold;">LIMITED-FEEDBACK POLICY</span></p>
<p><span class="font45" style="font-weight:bold;">3.1*6 LFB (Limited Feedback)</span></p>
<p><span class="font45" style="font-weight:bold;">Because cyclic policies have high overhead, we may often want to limit the number of transactions taking part in round-robin. There are various ways of dividing the transactions into two groups: the one handled by round-robin, the other by some other policy.</span></p>
<p><span class="font45" style="font-weight:bold;">A simple example of such a policy would be LFB. LFB assigns each transaction entering round-robin some number of time slices, N; each time a transaction uses one of its time slices, its number of remaining slices is decreased by 1. When a transaction runs out of round-robin slices, it is placed in another queue, from which it is selected by some other policy, say FIFO. Transactions are selected from the FIFO queue only when there are no more transactions in the round-robin queue. (See figure 15.)</span></p>
<p><span class="font45" style="font-weight:bold;">3*2 Dynamic Priority Assignment</span></p>
<p><span class="font45" style="font-weight:bold;">Each transaction is assigned a static priority when it is generated; it keeps that priority so long as it is in the system. Dynamic priority assignment, on the other hand, gives waiting transactions priorities that depend on specific conditions. .</span></p>
<p><span class="font45" style="font-weight:bold;">3.2.1 Types of Dynamic Priority Assignment</span></p>
<p><span class="font45" style="font-weight:bold;">The moment when priorities should be assigned depends on the problem to be solved. Two typical procedures are the following:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;Priorities are assigned at regular intervals.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Priorities are assigned every time a station is freed and the</span></p>
<p><span class="font45" style="font-weight:bold;">policy must select a new task.</span></p>
<p><span class="font45" style="font-weight:bold;">The more often new priorities are assigned, the better they reflect the system's current condition. Since, however, each priority assignment means administrative overhead, up-to-date priorities are paid for in time and effort. When processing time is short compared with priority assignment's overhead, the overhead can't be ignored. Oyerhead time depends on the number of tasks whose priorities must be computed and on the complexity of the computation.</span></p>
<p><span class="font45" style="font-weight:bold;">Any of a multitude of conditions can determine the priority dynamically assigned to a transaction. Nothing especially general can be said about them here, except that the priorities assigned should be the value of some function of the system's current state. The following sections describe a few typical policies for dynamic priority assignment.</span></p>
<p><span class="font45" style="font-weight:bold;">3.2.2 UTL (Upper Time Limit)</span></p>
<p><span class="font45" style="font-weight:bold;">This policy can only be used on queues at facilities or multi-facilities . Each transaction can be assigned an upper time limit,</span></p>
<p><span class="font45" style="font-weight:bold;">within which tine it sust be processed. The closer the tine Unit approaches, the higher the priority goes. In that case, the transaction's priority is a simple function of the time remaining before the limit. The remaining time could include the transaction's processing time. The very simplest function for specifying the priority would be the following linear equation:</span></p>
<p><span class="font45" style="font-weight:bold;">Priority * -Remaining time</span></p>
<p><span class="font45" style="font-weight:bold;">All priorities thus assigned would be negative and -1 would be the highest priority.</span></p>
<p><span class="font48">3.2.3 UTLP (Upper Time Limit with Priorities)</span></p>
<p><span class="font45" style="font-weight:bold;">A</span><span class="font48"> refinement and improvement of the UTL policy reassigns priorities on the basis of the transaction's initial priority. It raises a transaction's priority faster, if it had a high priority to begin with.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark245"></a>A</span></p>
<p><span class="font45" style="font-weight:bold;">201 XXXXXX TASK WITH IP s 1&nbsp;••«*•»*»»«»*»«•»*</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark246">IP&nbsp;»X</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark247">|R •••«•• TASK WITH IP s 4&nbsp;•&nbsp;X</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark248">II&nbsp;«X</a></span></p>
<p><span class="font45" style="font-weight:bold;">10&nbsp;«X 151R • X</span></p>
<p><span class="font45" style="font-weight:bold;">11&nbsp;«X IT »X</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark249">|Y&nbsp;«X</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark250">I&nbsp;«X</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark251">10| • I&nbsp;X •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark252">I&nbsp;X •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark253">I&nbsp;X •</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark254">I&nbsp;X&nbsp;•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark255">51&nbsp;X&nbsp;•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark256">I&nbsp;X&nbsp;•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark257">I&nbsp;X</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark258">I&nbsp;X</a></span></p>
<p><span class="font45" style="font-weight:bold;">1| X&nbsp;TIME ---♦—♦—♦—♦—♦——♦—♦—♦—♦—♦—♦—♦—♦—&gt;—♦—♦—&gt;</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark259">1&nbsp;5&nbsp;10&nbsp;15</a></span></p>
<p><span class="font45" style="font-weight:bold;">FIGURE 16&nbsp;PRIORITY CHANG.E IN UTLP FOR TRANSACTIONS WITH</span></p>
<p><span class="font45" style="font-weight:bold;">DIFFERENT INITIAL PRIORITIES, IP</span></p>
<p><span class="font45" style="font-weight:bold;">Figure 16 show3 how the priorities of two transactions could rise o.ver time in UTLP. A transaction's initial priority, IP, is</span></p>
<p><span class="font45" style="font-weight:bold;">specified when it is created. In the figure, a transaction is created at time T * 1 with initial priority IP « 1. Its</span><span class="font48"> priority </span><span class="font45" style="font-weight:bold;">increases by 1 each time unit, so that by time T « 13<sub>9</sub> it has P * 13. Another transaction enters the system at time T * 8 and receives initial priority iP * 4. But the policy raises the second transaction's priority by 4 for each time unit that passes,</span><span class="font48"> so </span><span class="font45" style="font-weight:bold;">that by time T * 14, it has reached the upper priority limit P s 20. An essential feature of such policies is that the transaction-processing sequence within a queue can change: in UTLP, transactions can catch up from behind.</span></p>
<p><span class="font45" style="font-weight:bold;">3*2.4 W7LP (Waiting Time Limit with Priorities)</span></p>
<p><span class="font45" style="font-weight:bold;">If a facility is especially burdened, transactions with low, static priorities may have to wait too long to be processed. To help matters, a dynamic priority assignment could see to it that transactions that have waited long, gradually get better and better priorities. The catch is that transactions with high initial priorities have to settle for longer total processing times. Note that if all arriving transactions have the the same priority, and if all waiting transactions bubble up at the same rate, WTL reduces to FIFO.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">• A facility's queue Is equipped with 20 possible priority levels. It can be shown that with dynamic priority assignment, low-priority transactions have lower total processing times and thus lower total waiting times than with static assignment. (See 11.4)</span></p>
<p><span class="font45" style="font-weight:bold;">3*3 Policies in CPSS-F</span></p>
<p><span class="font45" style="font-weight:bold;">Using the two mechanisms, priority-driving and preemption, any desired policy can be built. Priority-driving is possible in every queue in GPSS-F; GPSS-F supports preemption, however, only for facilities and multifacilities. The subroutines that carry out preemptions for those stations are respectively PREEMP and MPREEM. Preemption for storages could be handy for some models, but a general subroutine for such cases would be unwieldy. Thus we leave it to the user to write his own special-purpose routines to effect the particular kind of storage preemption he needs.</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F's priority-driving support consists of several features. First, each transaction carries a priority, freely chosen by the user at generation time, in TX(LTX,i). Further, there are procedures driven by other kinds of priorities, e.g. FI^O, for selecting transactions from a queue to be processed. Since reasonable selection criteria could well differ from queue to queue, the user can assign each station its own* specific policy, each of which can be designed to handle the special selection criteria for its station. For simple cases, such as priority selection or FIFO selection, GPSS-F supplies pre-built policies.</span></p>
<p><span class="font45" style="font-weight:bold;">When a station becomes accessible, transaction management's task (undertaken in ACTIV2) is to find a waiting transaction and</span></p>
<p><span class="font45" style="font-weight:bold;">activate it so that it can begin being processed. To find out precisely which transaction should be activated, ACTIV2 sets up the POLVEC vector and calls POLICY. POLICY figures out which of the policies belongs to the station in question and calls it. Pi* nally, this last subroutine picks a transaction and passes its 7X-matrix line number back to POLICY, which passes the result back to ACTIV2. Figure 17 is a bird's-eye view of the program hierarchy and the data areas passed.</span></p>
<p><span class="font45" style="font-weight:bold;">•----------— POLVEC -------------- POLVEC --------</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark260"></a>I&nbsp;I----------&gt;l&nbsp;I—-------&gt;1&nbsp;|</span></p>
<p><span class="font45" style="font-weight:bold;">I ACTIV2 I&nbsp;I POLICY t&nbsp;| SELECTION |</span></p>
<p><span class="font45" style="font-weight:bold;">|&nbsp;|&lt;----------1&nbsp;|&lt;----------1&nbsp;J</span></p>
<p><span class="font45" style="font-weight:bold;">-------------- LTX ------~------ LTX ----—--------</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark261"></a>FIGURE 17&nbsp;SUBROUTINE HIERARCHY OF A CALL TO POLICY</span></p>
<p><span class="font45" style="font-weight:bold;">3.3.1 POLICY Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">The POLICY subroutine determines which policy processes transactions waiting in the the station's queue whose station number is K; then it calls the subroutine that effects that policy.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL POLICY (K)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">K&nbsp;Station number</span></p>
<p><span class="font45" style="font-weight:bold;">The station number</span><span class="font45" style="font-weight:bold;font-style:italic;"> X</span><span class="font45" style="font-weight:bold;"> specifies the station from whose queue a waiting transaction is to be selected.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">The variables used by POLICY are collected in LABELLED COMMON/POL/.</span></p>
<p><span class="font45" style="font-weight:bold;">POLVEC (&quot;TXÎ&quot;) (Policy Vector)</span></p>
<p><span class="font45" style="font-weight:bold;">ACTIV2 enters here the line numbers of all blocked transactions that are waiting at station K. A transaction's line number LTX entered in the POLVEC vector designates its position in the activation list and in the TX matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">POLC (Queue length)</span></p>
<p><span class="font45" style="font-weight:bold;">ACTIV2 enters here at the station.</span></p><div>
<p><span class="font45" style="font-weight:bold;">number of blocked transactions</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">waiting</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">the</span></p></div>
<p><span class="font48">POL</span><span class="font45" style="font-weight:bold;"> (Policy Matrix)</span></p>
<p><span class="font45" style="font-weight:bold;">In GPSS-F, each queue of transactions waiting at a station can bt processed by its own policy. The user enters data in the poll» ey Matrix that specify which policy processes each station. It la defined as follows:&nbsp;—&gt;</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER POL</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION POL(&quot;P0L1&quot;,2)</span></p>
<p><span class="font45" style="font-weight:bold;">The individual elements have the following meanings:</span></p>
<p><span class="font45" style="font-weight:bold;">POL(I,1) Station number</span></p>
<p><span class="font45" style="font-weight:bold;">The station's station number K to be processed by the policy is designated in P0L(I,1).</span></p>
<p><span class="font45" style="font-weight:bold;">P0L(I,2) Policy number</span></p>
<p><span class="font45" style="font-weight:bold;">Each policy is designated by a number. The number of the policy that is to process the queue at the station designated in P0L(I,1) is entered here.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find the policy&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I s 1., &quot;P0L1&quot; IF(P0L(I,1).NE.K) GOTO 100 IADDR s P0L(I,2) - GOTO 120 100 CONTINUE IADDR = 1 120 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">GOTO (1,2,3,*»,5) , IADDR</span></p>
<p><span class="font45" style="font-weight:bold;">The policy matrix is searched to find the policy assigned to station K. If there is no entry in the policy matrix for station K, its queue is processed using the policy whose number is 1.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Call the policy-implementing subroutine&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">1&nbsp;CALL PFIF0 RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">2&nbsp;CALL FIFO RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">3&nbsp;CALL P0LI3 RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">1»&nbsp;CALL P0LI4</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 5 CALL P0LI5 RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">A computed GOTO is used to jump to the subroutine call appropriate to station K. That subroutine sets the line number of the selected transaction in the variable LTX. Since LTX is in a COMMON area, it is available to ACTIV2. Policy numbers 1 and</span><span class="font39" style="font-style:italic;"> 2 </span><span class="font45" style="font-weight:bold;">are assigned to the pre-built GPSS-F policies PFIF0 and FIFO.</span></p>
<p><span class="font45" style="font-weight:bold;">• If the user writes his own policies, they must be assigned ni»bers and Fortran names. The user enters the station and policy numbers in the policy matrix by writing the appropriate statements into section 4 of the chassis«; The policy's name must appear in a CALL statement added at the point corresponding to its * policy number to the above section of subroutine POLICY.</span></p>
<p><span class="font45" style="font-weight:bold;">3.3-2 PFIFO Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">PFIFO selects the blocked transaction with the highest priority | If more than one transaction has the same priority, then further selection is on the basis of the FIFO policy.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL PFIFO</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">PFIFO uses the area COMMON/POL/.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Initialize the search*</span></p>
<p><span class="font45" style="font-weight:bold;">IPR x 1</span></p>
<p><span class="font45" style="font-weight:bold;">LTX s POLVEC(I) IF(POLC.EQ.I) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">The search begins with the first transaction in the policy vector. The variables used in the search are initialized. If only one transaction is in the queue, the search can be avoided; then the subroutine returns to the calling program, POLICY.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compare&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 1=2, POLC LTX1 : POLVEC(I)</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,4)-TX(LTX1,4)) 110 , 120 , 100 110 LTX = LTX1 IPR = 1</span></p>
<p><span class="font45" style="font-weight:bold;">POLVEC(I) x LTX GOTO 100 120 IPR s IPR ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">POLVEC(IPR) = LTX1 A 100 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">The policy vector is sorted according to priority with highest priority first. IPR is the count of transactions with the highest occuring priority.</span></p>
<p><span class="font45" style="font-weight:bold;">•Call FIFO*</span></p>
<p><span class="font45" style="font-weight:bold;">POLC » IPR</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IPR.LE.1) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">CALL FIFO</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">If more than one transaction has the highest occuring priority, FIFO selects the winner. Since these transactions have been sorted to the top of the vector, only they must be searched by FIFO. Hence PFIFO sets the number IPR in POLC. If, on the other hand, there is only one transaction with the highest priority, PFIFO returns to POLICY.</span></p>
<p><span class="font47">3-3-3</span><span class="font45" style="font-weight:bold;"> FIFO Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">FIFO finds the transaction in a queue that has the earliest block time, i.e., the one that has been waiting the longest. If there is more than one such transaction, the one with the smallest transaction number is selected. If more than one transaction has the same transaction number, they must all belong to a family; then the duplicate number decides.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL FIFO</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">FIFO uses the area COMMON/POL/.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">•Initialize the search<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">LTX s P0LVECO) IF(P0LC.EQ.1) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">The search begins with the first transaction in the policy vector. The variables required in the search are initialized. If there is only one transaction in the queue, the search can be a-voided; then the subroutine returns to the calling program.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compare*</span></p>
<p><span class="font48" style="font-variant:small-caps;">do 150 i s 2 , polc ltx1 s polvec(i) 100 if(tx(ltx,8)-tx(ltx1,8)) 150 , 110 , 130 110 if(tx(ltx,1)-tx(ltx1,1)) 150 , 120 , 130 120 if(tx(ltx,2)-tx(ltx1,2)) 150 , 150 , 130 130 ltx = ltx1 150 continue</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">The transactions in the policy vector are searched in order of occurrence. The variable LTX is set to point to the transaction selected.</span></p>
<p><span class="font45" style="font-weight:bold;">3-3.4 Dynamic Priority Assignment with Subroutine DYNVAL Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">DYNVAL is used to assign priorities dynamically. The subroutine searches out all transactions waiting at the station K and assigns them a new priority. The new priority is computed by the function DYNPR<sub>V</sub> which is written by the user.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL DYNVAL (K<sub>f</sub>PCOUNT,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">K&nbsp;Station number</span></p>
<p><span class="font45" style="font-weight:bold;">All transactions waiting at the station designated by this number receive a new priority. PCOUNT Count of reassigned priorities</span></p>
<p><span class="font45" style="font-weight:bold;">The number of transactions that received new priorities is returned in this counter.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">DYNVAL uses the activation list and the transaction matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Reassign the priorities&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">PCOUNT s 0</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I s 1 <sub>f</sub> LAL</span></p>
<p><span class="font45" style="font-weight:bold;">IF(AL(I<sub>f</sub>2).NE.-K. AND. AL( T <sub>f</sub> 2) . NE^K-^KEND&quot;) GOTO 100 PR s TX(I,i|) TX(I<sub>f</sub>M) s DYNPR(I ) PCOUNT s PCOUNT ♦ 1 100 CONTINUE RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">The activation list is searched for transactions blocked or locked at the station K. The new priority is computed by the function DYNPR and set in TX(LTX<sub>f</sub>4).</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">* Administrative overhead incurred by assigning priorities dynamically is usually too big to ignore. The overhead depends on the number of new priorities assigned and the complexity of the priority computation.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;The user is responsible for accounting for the overhead of dynamic priority assignment.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;DYNVAL reassigns priorities only to transactions in the queue; any transactions currently occupying the station are ignored.</span></p>
<p><span class="font45" style="font-weight:bold;">3.* The State Vector</span></p>
<p><span class="font45" style="font-weight:bold;">All GPSS-F stations can be accessible or inaccessible, i.e. ready to process an arriving transaction or not ready. A transaction arriving at an inaccessible station is placed in the wait state and thereby entered in the station's queue. Each station has an element in the state vector, which specifies its state:</span></p>
<p><span class="font45" style="font-weight:bold;">STATE(K) s 0 Station number-K is inaccessible. STATE(K) s 1 Station number-K is accessible.</span></p>
<p><span class="font45" style="font-weight:bold;">The element number, K, in the state vector is the station's Identifying number. In addition to a station number, each station has a type number, which identifies it among stations of the same type. A station's station number can be computed from its type and type number when the construction of the state vector is taken into account. (The state vector's construction is shown in appendix A2; the following examples refer to the state-vector diagram there.)</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* If the maximum number of facilities set by the program definition parameter &quot;FAC1&quot; is &quot;FAC1&quot; s 20, the multifacility with the type number MFAC s 5 is the station whose station number is 25.</span></p>
<p><span class="font45" style="font-weight:bold;">In order to be able to refer easily to state-vector elements belonging to a particular station type, the upper limit of each section of the state vector has a special designator as shown in the following list:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;FAC1&quot; &quot;EFAC&quot; ♦ &quot;EMFAC&quot; • &quot;ESTO&quot; ♦ &quot;EGATE1&quot; &quot;EGATE2&quot; &quot;EGATH1&quot; &quot;EGA7H2&quot; &quot;EUCHN1&quot;</span></p><div>
<p><span class="font45" style="font-weight:bold;">EFAC&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EMFAC&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">ESTO&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EGATE1&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EGATE2&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EGATH1&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EGATH2&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EUCHN1 &quot;</span></p>
<p><span class="font45" style="font-weight:bold;">EUCHN2&quot;</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">MFAC1&quot; &quot;ST01&quot; GATE1&quot; &quot;GATE2&quot; &quot;GATH1&quot; &quot;GATH2&quot; &quot;UCHN1&quot; <sup>ff</sup>UCHN2<sup>ff</sup></span></p></div><div>
<p><span class="font45" style="font-weight:bold;">&quot;FAM1&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;FAtH&quot; </span><span class="font69" style="font-weight:bold;">2</span></p></div>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">The</span><span class="font45"> last</span><span class="font45" style="font-weight:bold;">&nbsp;multifacility has the state-vector element</span></p>
<p><span class="font45" style="font-weight:bold;">STATE</span><span class="font45"> I &quot;EMFAC&quot;)</span><span class="font45" style="font-weight:bold;"> .&nbsp;The first storage, i.e. the storage whose type number</span><span class="font45"> is NST</span><span class="font45" style="font-weight:bold;"> = 1, has the state-vector element STATE(&quot;EMFAC&quot;*1)I</span></p>
<p><span class="font45" style="font-weight:bold;">• Gather stations that are specially designed to process families have more than one element in the state vector. Each has &quot;FAM1&quot; elements since each family must have its own state-vector element.</span></p>
<p><span class="font48">3.5</span><span class="font45" style="font-weight:bold;"> The Watchdog</span></p>
<p><span class="font45" style="font-weight:bold;">We shall require that no transaction gain access to a station without having been in that station's queue. To put it differently, a transaction must have been selected by a station's policy before the station may serve it. Were it not for the restriction, a new arrival could be processed without having to wait its turn.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions- sometimes arrive at a station that has Just become accessible and at which other transactions are already waiting. Were it not for the watchdog, the new arrival would acquire the station without having competed for selection with the waiting transactions. The hound sees to it that each newly arriving transaction is blocked at least once.</span></p>
<p><span class="font45" style="font-weight:bold;">Our faithful mutt is driven by the variable OK. If a transaction arrives at a station that has just been freed, it finds the variable set OK s 0 and is automatically blocked. Fido forces the arriving transaction to compete for selection with transactions that have already waited their turns. When a transaction is blocked, it has been deactivated, which means that ACTIV2 will be called next. ACTIV2 finds the station accessible with transactions waiting at it; thus a conditioned activation is called for. ACTIV2 lets the station's policy select a waiting transaction and then activates it. At the same time, it sets OK s 1, so that faithful Fido won't bark. (For an example of Fido in action, see 4.1.1.)</span></p>
<p><span class="font45" style="font-weight:bold;">4 FACILITIES</span></p>
<p><span class="font45" style="font-weight:bold;">Facilities are stations that serve one transaction at a time. The transaction acquires it, is served by it for some period and finally frees it (see figure 18). While it serves one transaction, a facility is Inaccessible to all others; new arrivals must wait in its queue until it has been freed. Then one of the waiting transactions will be chosen from the queue to be served.</span></p>
<p><span class="font48">I ACQUIRE&nbsp;| | PROCESS |</span></p>
<p><span class="font48"><a href="#bookmark262">&gt;1 THE&nbsp;|---&gt;| THE&nbsp;|</a></span></p>
<p><span class="font48"><a href="#bookmark263">I FACILITY&nbsp;| | TASK&nbsp;|</a></span></p>
<p><span class="font48"><a href="#bookmark264">I FREE&nbsp;I</a></span></p>
<p><span class="font48"><a href="#bookmark265">&gt;| THE&nbsp;-&gt;</a></span></p>
<p><span class="font48"><a href="#bookmark266">| FACILITY&nbsp;I</a></span></p>
<p><span class="font48">FIGURE 18&nbsp;A TASK'S OCCUPATION OF A FACILITY</span></p>
<p><span class="font48">Examples:</span></p>
<p><span class="font48">*&nbsp;A supermarket checkout-stand handles only one customer at a time. If a customer's groceries are being checked, arriving customers must stand in line; they form the queue.</span></p>
<p><span class="font48">•&nbsp;A certain computing system's CPU can process only one task at a time. All tasks competing for CPU time are placed in a queue. When the CPU is freed, one of the tasks in the queue is selected according to a policy and acquires the CPU. If the system sup« ports preemptions, an incoming task can insist that it be pro-cessed, assuming the policy gives it preference, thereby forcing the currently processing task back into the queue.</span></p>
<p><span class="font48">Data area:</span></p>
<p><span class="font48">When a facility is to be acquired, two data areas are needed: the state vector and the facility matrix. The state vector specifies whether the facility is accessible or not. When it is accessible, a transaction can acquire it; when not, the transaction must wait. A facility is accessible precisely when it is free, I.e. when it isn't processing a transaction. The facility matrix specifies the facility's parameters and is defined as follows:</span></p>
<p><span class="font48">INTEGER FAC</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION FAC( &quot;FACI<sup>w</sup> ,3)</span></p>
<p><span class="font50" style="font-weight:bold;">The individual alésants have the following meanings:</span></p>
<p><span class="font50" style="font-weight:bold;">FAC(NFA,1) Occupation code</span></p>
<p><span class="font45" style="font-weight:bold;">This field shows which transaction occupies the facility. It also specifies whether or not the transaction is interruptible (preemptible) or not. FAC(NFA,1)*0 The facility is free. FAC(NFA,1)«LTX The transaction whose line is LTX in</span></p>
<p><span class="font45" style="font-weight:bold;">the activation list occupies the facility; it is interruptible. FAC(NFA,1)*-LTX The transaction whose line is LTX in</span></p>
<p><span class="font45" style="font-weight:bold;">the activation list occupies the facility; it is not interruptible.</span></p>
<p><span class="font45" style="font-weight:bold;">FAC(NFA,2) Preemption code</span></p>
<p><span class="font45" style="font-weight:bold;">The code shows whether or not a preemption is in progress.</span></p>
<p><span class="font45" style="font-weight:bold;">FAC(NFA,2)*0 A preemption is not in progress. The</span></p>
<p><span class="font45" style="font-weight:bold;">transaction occupying the facility is in its normal service phase. FAC(MFA<sub>t</sub>2)x1 A preemption is in progress.</span></p>
<p><span class="font45" style="font-weight:bold;">FAC(NFA,3) Service phase</span></p>
<p><span class="font45" style="font-weight:bold;">This element specifies which phase the transaction currently being served is in: setup, work or knockdown (see 4.2). FAC(NFA<sub>f</sub> 3)st Setup FAC(NFA<sub>f</sub>3)*2 Work FACOJFA, 3)-3 Knockdown</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;">• For facilities without preemption, only FAC(N^A<sub>f</sub>1) is actually used.</span></p>
<p><span class="font45" style="font-weight:bold;">4.1 Acquiring and Freeing a Facility</span></p>
<p><span class="font45" style="font-weight:bold;">SEIZE acquires and CLEAR frees a facility for the active transaction. WORK simulates the time a transaction spends being served.</span></p>
<p><span class="font45" style="font-weight:bold;">».1.1 SEIZE Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">The active transaction tries to acquire a facility by calling SEIZE, which tests the facility's accessibility. If the facility is free, the active transaction acquires it; the facility is then inaccessible. If the facility is inaccessible to begin with, SEIZE blocks the active transaction and enters it in the facility's queue.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SEIZE (NFA<sub>9</sub>ID<sub>9</sub> &amp;1005 <sub>f</sub>IPRINT) Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NFA&nbsp;Facility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Facillties^are identified by consecutive numbers* ID&nbsp;SEIZE CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If SEIZE blocks an arriving transaction, ID specifies the target where the transaction will continue its activity when it is re-activated. At that time, its activity should be to acquire the station. Therefore, ID should specify the same CALL SEIZE statement that caused the transaction to enter the wait queue. 41005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">Vhen a transaction tries to acquire a facility that is currently occupied, it must be blocked. Then transaction management must receive control again. Hence, the statement number of CALL ACTIV2 must always be specified here.</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0. ♦</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SEIZE uses the activation list, the TX matrix, the FAC matrix and the state vector.</span></p>
<p><span class="font45" style="font-weight:bold;">•Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Blocking Decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 100 OK s 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(FAC(NFA<sub>f</sub> D.NE.0) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">First, the watchdog sniffs the calling transaction. Only in case OK.NE.O has it already competed with the others for selection; otherwise it may not acquire the facility. OK is reset immediately. Then SEIZE checks whether or not the facility is already occupied. If FAC(NFA,1) is 0, i.e. if the facility is free, the program continues with the &quot;Acquire&quot; section; otherwise it jumps to the &quot;Block&quot; section.</span></p>
<p><span class="font43" style="font-style:italic;">%</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Acquire&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">FAC(NFA,1) = LTX STATE(NFA) s 0 TX(LTX,5) * ID TX(LTX,8) s 0 RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">SEIZE sets the acquiring transaction's line number, LTX, in FAC(NFA,1). Since the facility is now occupied again, it marks the station inaccessible by zeroing its state-vector entry. Finally, it elears the acquiring transaction's block time. •Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) a - NFA TX(LTX,8) * 7 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">The transaction to be blocked has the line numbered 'LTX' in the activation list. SEIZE enters a block code for it there. When it is re-activated, its activity continues with the statement whose statement number is ID; SEIZE sets that number in the activation list as target. For certain policies, such as FIFO, which use the block- time, it enters the current clock time in the TX matrix.&nbsp;~</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;There can be several points of entry to a given facility, i.e. several CALL SEIZE statements in the model can specify the same facility number, NFA. (Examples are discussed in section 4.3*)</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;When a transaction first arrives at an accessible facility, where no other transactions are waiting, it will call SEIZE twice in a row. The first time, the watchdog, whose function is explained in 3-5, causes the arrival to be blocked and SEIZE returns to flow management. ACTIV2 then finds the accessible facility with a waiting transaction, which it now activates. The newly re-activated transaction is targeted to call SEIZE again. This time,</span><span class="font39" style="font-style:italic;"> OK</span><span class="font45" style="font-weight:bold;"> will be 1. Since the transaction has been selected from the queue, the watchdog lets it acquire the facility.</span></p>
<p><span class="font45" style="font-weight:bold;">4.1.2 U0RK Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">By calling WORK, the active transaction simulates the time it spends being served at a facility. WORK schedules the transaction to call it again after it has been served, then returns to flow management. At the end of its service phase, when the transaction calls WORK again, the program recognizes it and, leaving it active, returns normally to the statement following the call.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL WORK (WT,NFA,ID,IEX,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">WT&nbsp;Work time</span></p>
<p><span class="font45" style="font-weight:bold;">The active transaction requests to be served for WT time units. If the simulator's clock shows time T, WORK schedules the transaction to be re-activated at T ♦ WT.</span></p>
<p><span class="font45" style="font-weight:bold;">UFA&nbsp;Facility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The facilities are identified by sequential numbers.</span></p>
<p><span class="font45" style="font-weight:bold;">ID&nbsp;WORK CALL'S statement number</span></p>
<p><span class="font45" style="font-weight:bold;">WORK targets the transaction to call it again at the end of its work phase. It does that by entering its own statement number, which is passed to it in ID, and the re-activation time in the ?&quot;tivation list.</span></p>
<p><span class="font45" style="font-weight:bold;">TEX&nbsp;Preemption code</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;This parameter specifies whether the active transaction</span></p>
<p><span class="font45" style="font-weight:bold;">may be preempted once it has acquired the facility. IEX s 0 The transaction now acquiring the facility may be preempted in case a higher-priority transaction desires to be served. IEX * 1 The transaction may not be preempted. Any transaction arriving while it is being served will be blocked.</span></p>
<p><span class="font45" style="font-weight:bold;">41005 Scheduling exit</span></p>
<p><span class="font45" style="font-weight:bold;">WORK deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another transaction.</span></p>
<p><span class="font45" style="font-weight:bold;">&amp;1006 Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine returns via this exit if ^a transaction tries to be served at a facility it doesn't occupy.</span></p>
<p><span class="font45" style="font-weight:bold;">IPRIHT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed'when IPRIHT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">WORK uses the activation list, the TX matrix and the FAC matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">Since WORK sometimes operates in tandem with PREEMP, (see 4.2.1), the reader should learn their algorithms together, unless he has no use for preemptions. A first reading could skim WORK'S algorithm or skip directly to the notes at the end of this section.</span></p>
<p><span class="font45" style="font-weight:bold;">•Error check*</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</span></p>
<p><span class="font45" style="font-weight:bold;">The program tests wether the calling transaction actually occupies the facility it specifies in the NFA parameter. If not, the error exit is taken.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Serving decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 IF(FAC(NFA, 2 ).EQ.O ) GOTO 150</span></p>
<p><span class="font45" style="font-weight:bold;">IF(FAC(NFA,3).EQ.1) TX(LTX,6) s WT RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">150 IF(FAC(NFA,3).EQ.2) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">This section culls out returning or preempted transactions and iaaues a normal return when it finds them« If a preemption Is in progress, PAC(NFA<sub>f</sub>2) will be non-zero. If the transaction has just completed its setup phase, FAC(NFA,3) will be 1, In which case its remaining work time (TX(LTX,6)) is the entire time it would have been served, WT. Preempted transactions remain active and WORK returns to the statement following its call.</span></p>
<p><span class="font45" style="font-weight:bold;">If a preemption isn't in progress, the subroutine culls out transactions returning to report the end of their work phase; they will have a phase code of 2 in FAC(MFA,3) • Those transactions also remain active and WORK returns normally.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions at the start of their work phase fall through to the next section, if a preemption isn't in progress.</span></p>
<p><span class="font45" style="font-weight:bold;">•Serve<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">IF(IEX.EQ.O) FAC(NFA,1) « LTX IF(IEX.EQ.1) FAC(NFA,1) s - LTX FAC(NFA,3) * 2 IF(TX(LTX,6).NE.O) GOTO 200 AL(LTX,1) s ID AL(LTX,2) s I ♦ BT RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">The facility's entry in the FAC matrix is set to show that it is in its work phase (FAC(NFA,3) = 2) and that its occupant is interruptible or not. If the transaction was once preempted and hasn't yet been completely served, TX(LTX,6) will show how much time it has left to spend in the work phase; WORK jumps to &quot;Serve reacquiring transactions&quot;. Finally, if the facility is serving the calling transaction from scratch, WORK schedules it by setting a time and target in its activation-list entry and then returns to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Serve reacquiring transactions&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">200 AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) s T ♦ TX(LTX,6) ?X(LTX,6) s 0 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">In a re-acquisition, WORK schedules the calling transaction to be served for the remainder of its processing time*</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;">• Were it npt for preemption, WORK would be a very simple program. In fact, a programmer who doesn't use preemption could assume that the entire subroutine consists of nothing more than the four statements:</span></p>
<p><span class="font52" style="font-variant:small-caps;">if(fac(nfa,3).eq.2) return fac(nfa,3) * 2</span></p>
<p><span class="font45">AL(LTX,1) s ID AL(LTX,2) s T ♦ WT</span></p>
<p><span class="font45" style="font-weight:bold;">«.1.3 CLEAR</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">By calling CLEAR, the active transaction frees the facility it</span></p>
<p><span class="font45" style="font-weight:bold;">occupies.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL CLEAR (NPA,EXIT1,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NFA&nbsp;Facility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The facility's identifying number is given here.</span></p>
<p><span class="font45" style="font-weight:bold;">EXIT1 Preemption exit</span></p>
<p><span class="font45" style="font-weight:bold;">CLEAR takes this exit when the calling transaction is being preempted from the facility. If the user chooses, he may have the subroutine return to a section of his own code, so as to count preemptions or whatever. Then, since CLEAR has blocked the preempted transaction, he must jump to flow management. If the user need take no special action when a preemption occurs, he should code 41005 here; then CLEAR returns directly to ACTIV2.</span></p>
<p><span class="font45" style="font-weight:bold;">41006 Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">CLEAR exits to this statement number when the active transaction doesn't occupy the facility it is trying to free.</span></p>
<p><span class="font45" style="font-weight:bold;">I PR INT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">CLEAR uses the FAC matrix, the state vector and the TX matrix. Algorithm description: &quot;Error check&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">. IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction that doesn't occupy the facility numbered 'NFA' has no business trying to free it; the model is incorrectly designed .</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Free&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 DO 150 I s 1 , 3 150 FAC(NFA,I) r 0 STATE(NFA) s 1</span></p>
<p><span class="font45" style="font-weight:bold;">The program clears the facility's data areas and marks it accessible.</span></p>
<p><span class="font45" style="font-weight:bold;">•Block a</span><span class="font45" style="font-weight:bold;font-style:italic;"> preempted</span><span class="font45" style="font-weight:bold;"> transaction&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX<sub>t</sub>6).EQ.O) GOTO 200 AL(LTX,1) * TX(LTX,5) AL(LTX<sub>9</sub>2) ж - NPA TX(LTX<sub>9</sub>8) » T • 200 TX(LT£,5) » 0</span></p>
<p><span class="font45" style="font-weight:bold;">If the calling transaction has been preespted<sub>9</sub> it belongs In the facility's queue again, since it has to come back to finish being served. CLEAR recognizes preempted transactions from the fact that their residual-processing-time field, TX(LTX<sub>f</sub>6), has been filled in. The blocked transaction is targeted to the call to PREEMP that caused it to be preempted.</span></p>
<p><span class="font45" style="font-weight:bold;">•Return*</span></p>
<p><span class="font45" style="font-weight:bold;">IP(TX(LTX<sub>9</sub>6).EQ.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">This section chooses the correct return for each kind of transaction. If the transaction is leaving the facility of its own free will, it remains active and CLEAR returns to the statement following the call. If the transaction is being preempted, though« CLEAR has blocked it and must return via the preemption exit.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">• A facility at which preemptions don't occur, like the facility in figure 18, is modelled by the following sequence of statements, in which HORK's IEX parameter is, of course, meaningless:</span></p>
<p><span class="font45" style="font-weight:bold;">2&nbsp;CALL SEIZE (NFA,2,41005,JPRIN7)</span></p>
<p><span class="font45" style="font-weight:bold;">3&nbsp;CALL WORK (WT,flPA,3tIEX,41005,41006,TPRIMT) CALL CLEAR (ЯРА,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">4.2 Preemption</span></p>
<p><span class="font45" style="font-weight:bold;">Preemption interrupts a facility's service to let a more important transaction acquire it. ^he preempted transaction returns to the queue with a code showing how much time it had left to be served. The facility finishes serving it later, when it is selected from the queue.</span></p>
<p><span class="font45" style="font-weight:bold;">4.2.1 PREEMP Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">PREEMP acts like SEIZE, except that it preempts a facility's current occupant, if the new arrival is important enough to warrant Immediate service.</span></p>
<p><span class="font45" style="font-weight:bold;">If PREEMP finds the facility free, the calling transaction ac-<a name="bookmark267"></a></span><span class="font47">•a</span></p>
<p><span class="font45" style="font-weight:bold;">quires it; then the facility is inaccessible* Since no preemption occurs, PREEMP does exactly what SEIZE would have done.</span></p>
<p><span class="font45" style="font-weight:bold;">If, on the other hand, PREEMP finds the facility occupied, it lots the policy decide which transaction should occupy it. If the policy decides in favor of the facility's occupant, PREEMP simply blocks the calling transaction and returns to flow aanagement. But if the policy decides against the facility's occupant, PREEMP Initiates a preemption: it blocks the arriving transaction, but it cuts off the occupant's remaining serving time.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL PREEMP (NFA,ID,&amp;1005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">UFA&nbsp;Facility Number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter identifies the facility whose current occupant is to be preempted. The facilities are Individ-ualy, consecutively numbered. ID&nbsp;PREEMP CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">Tf PREEffP blocks an arriving transaction, ID-specifies the target where the transaction will continue its» activity when it is re-activated. At that time, its activity should be to acquire the station. Therefore, ID should specify the</span><span class="font43" style="font-style:italic;"> sane</span><span class="font45" style="font-weight:bold;"> CALL PREEMP statement that caused the transaction to enter the queue. &amp;1005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">PREEMP takes this exit whenever it blocks the arriving transaction. That occurs in every case, except when the transaction acquires the facility* IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRIN? s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">PREEMP uses the activation list, the TX matrix, the FAC matrix and the state vector.</span></p>
<p><span class="font45">Algorithm description:</span></p>
<p><span class="font45">A first reading could overlook references to the facility's setup and knockdown phases; they are inessential to an understanding of PREEMP's workings.</span></p>
<p><span class="font45">&quot;Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">K1 s 1</span></p>
<p><span class="font45">TF(FAC(NFA<sub>f</sub> U.NE.O) GOTO 200 </span><span class="font41" style="font-weight:bold;">K 1 s 0</span></p>
<p><span class="font45">IF(OK.EO.O) GOTO 200 OK s 0</span></p>
<p><span class="font45">If the facility is already occupied, or if the watchdog barks<sub>9 </sub>the above statements jump to</span><span class="font45" style="font-weight:bold;"> &quot;Block&quot;,</span><span class="font45"> setting K1 along the</span><span class="font43" style="font-style:italic;"> way, </span><span class="font45">in order to show why the arrival is being blocked.</span></p>
<p><span class="font45" style="font-weight:bold;">acquire-</span></p>
<p><span class="font45" style="font-weight:bold;">FAC(NFA, 1)</span><span class="font39" style="font-style:italic;"> m LTX </span><span class="font45" style="font-weight:bold;">STATE(MFA) »0 TX(LTX<sub>f</sub>8) s 0 7X(LTX<sub>f</sub>5) « ID RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">PREEMP sets the acquiring transaction's line number, LTX, in FAC(NFA,1). Since the facility is now occupied again, it marks the station inaccessible by zeroing its state-vector entry. Finally, it clears the acquiring transaction's block time.</span></p>
<p><span class="font45" style="font-weight:bold;">A preempted transaction finds its way, via subroutine CLEAR, back into the queue. Eventually, the policy responsible for that queue will select it to re-acquire the facility. When that happens, the activated transaction should call PREEMP again. Since CLEAR must target the preempted transaction to PREEMP (see 4.1.3 &quot;Block a preempted transaction&quot;), the transaction carries PREEMP's statement number around in the TX(LTX,5) field.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">200 AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(L7X,2) s - NFA TX(LTX<sub>f</sub>8) x T IF(KI.EQ.O) RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If the watchdog blocks the arriving transaction, PREEMP takes the blocking exit without further adieu. Otherwise, it continues on to the next section.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Suppress the preemption&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">300 IF(FAC(NFA,1).LT.O.AND.FAC(NFA,3bEQ.2) RETURN 1 IF(FAC(NFA,3).E0.3.0R.FAC(NFA,2).EQ.1) RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">This section suppresses the preemption, if the facility's occupant is in a non-interruptible work phase, or if it is in the process of leaving the facility anyway. The latter is the case when the facility is in its knockdown phase (зее 4.2.4).</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Call the policy&quot;</span></p>
<p><span class="font45">P0LVECO) s TABS(FAC(NFA, 1) ) P0LC s 1</span></p>
<p><span class="font45">DO 350 1x1, LAL IF(AL(I,2).ME.-MrA) GOTO 350 P0LC = P0LC</span><span class="font45" style="font-weight:bold;"> ♦ 1 </span><span class="font45">POLVEC(POLC) s I 350 CONTINUE</span></p>
<p><span class="font45">CALL POLICYOJFA)</span></p>
<p><span class="font45">I<sup>C,</sup>(LTX.EQ.TABS(FAC(NFA, 1))) RETURN 1</span></p>
<p><span class="font45">Here, the policy decides whether a preemption is called</span><span class="font45" style="font-weight:bold;"> for or </span><span class="font45">not. Just as in ACTIV2, PREEMP gathers in P0LVEC the line numbers</span></p>
<p><span class="font47">of mil transactions waiting at the facility, inserting the facll~ ity's occupant as the first entry<a name="footnote6"></a><sup><a href="#bookmark268">6</a></sup> Then it calls POLICY (see 3*3)» which returns the line number of the transaction it selects In LTX. If the policy has selected the facility's occupant, no preemption is called for*</span></p>
<p><span class="font47">&quot;Preempt&quot;</span></p>
<p><span class="font47">LTX s IABS(FAC(HFA<sub>f</sub>1)) FACOIFA,2) s 1</span></p>
<p><span class="font47">IF(FAC(NFA,3).E0.1) RETURN 1 TX(LTX,6) s AL(LTX,2) - T AL(LTX,2) s T RETURN 1 END</span></p>
<p><span class="font48">First, we set the preemption code, so that WORK will know what has happened (see 4*1.2 &quot;Serving decision&quot;). If the facility's occupant is being set up, it may not be interrupted, but we set the preemption code, so that it will skip its work phase and go directly to its knockdown phase (if there is one).</span></p>
<p><span class="font48">If the facility's occupant is in its work phase, PftEEMP sets its remaining processing time in TX(LTX,6) ajnd schedules it*to be reactivated immediately: we have cut off the occupant's service. Now the occupant will again call WORK,, which recognizes it and returns to the next statement in the model.</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font48"><sup>9</sup> To simulate a facility with preemptions, but without considering setup and knockdown phases, merely substitute PREEffP for SEIZE, as follows:</span></p>
<p><span class="font48">2&nbsp;CALL PREEMP (NFA,2,41005,IPRIN?)</span></p>
<p><span class="font48">3&nbsp;CALL WORK (WT,NFA, 3 •IEX,41005<sub>f</sub>41006<sub>f</sub>IPRINT) CALL CLEAR (NFA,41005,41006,IPRINT)</span></p>
<p><span class="font48">No other changes whatever are necessary. The IEX parameter I can, of course, specify for each transaction individually, whether or not it is interruptible.&nbsp;- ■''^■^■H</span></p>
<p><span class="font45" style="font-weight:bold;">pant is In the process of leaving anyway.</span></p>
<p><span class="font45" style="font-weight:bold;">• The only reason for having the policy look over all transactions is that their priorities could have changed since the facility began serving its present occupant. If priorities aren't assigned dynamically, though, we can be sure that the facility's occupant has a higher one than any transaction waiting in the queue. In that case, PREEMP could decide whether or not to preempt, merely by comparing the occupant's priority with the arriving transaction's. If the new arrival has the higher priority, it preempts the occupant. The user can implement that simpler, time-saving procedure by replacing &quot;Call the policy<sup>11</sup> with the following section:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compare priorities&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">LTX1 « IABS(FAC(NFA,1)) IF(TX(LTX,4).LE.TX(LTX1,4)) RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">4.2.2 Setup and Knockdown in Case of Preemption</span></p>
<p><span class="font45" style="font-weight:bold;">If we just look closely enough, most serving processes actually consist of three phases:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;a setup phase in which the station and its new task are made ready for work,</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;a work phase in which the station serves or processes the task and finally,</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;a knockdown phase in which the station is set back in its original state and its task is dismounted or removed.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;At a car-repair shop, the setup phase consists of driving the car in from the parking lot and setting out the tools. The mechanic repairs the car during the work phase. During the knockdown phase, he clears away his tools and drives the car back on to the lot.</span></p>
<p><span class="font45" style="font-weight:bold;">If work at a facility is never preempted, we lump all three phases together, as we did in the example at the end of section 4.1.3. But if a transaction is ever preempted, it will have to be set up and knocked down once more* each time it makes room for a more pressing case. Its total service time could be considerably longer than it would otherwise have been. Hence, we shall often want to model each phase separately. Each time its service is interrupted, the facility loses the old transaction's knockdown time , plus the new one's setup time (see figure 19).</span></p>
<p><span class="font48"><a name="bookmark269"></a>Example:&nbsp;•</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>11</sup> An emergency patient arrives at a doctor's office. The patient he is treating at the moment has to get dressed and return to the</span></p>
<p><span class="font45" style="font-weight:bold;">waiting room while the doctor clears his Instruments away and washes his hands. All in all<sub>9</sub> it takes two minutes of knockdown time before the pressing case can be admitted. Then it takes the doctor another three minutes of setup time to figure out precise« ly what's the matter and to get his Instruments ready.</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine PREEMP occasions preemptions, when they are called for, and subroutines SETUP and KNOCKD simulate the time ft takes to set the facility up or to knock it back down. Of course WORK simulates the facility's normal working phase.</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 19</span></p></div>
<p><span class="font45" style="font-weight:bold;">OCCUP</span></p>
<p><span class="font45" style="font-weight:bold;">FREE</span></p>
<table border="1">
<tr><td>
<p><span class="font45" style="font-weight:bold;">1 SERVICE</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">STATION'S</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1 STATE</span></p>
<p><span class="font45" style="font-weight:bold;">I 1</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">1 I</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">1 •• 1</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1 1</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">I SETUP PHASE |</span></p></td><td>
<p></p></td><td>
<p><span class="font36">•</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font32">-</span></p></td><td>
<p></p></td><td>
<p></p></td></tr>
</table>
<p><span class="font45" style="font-weight:bold;">A</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">PREEMPTION</span></p>
<p><span class="font45" style="font-weight:bold;">A</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">ACQUISITION</span></p>
<p><span class="font45" style="font-weight:bold;">TIME FLOW FOR PREEMPTIONS WITH KNOCKDOWN AND SETUP</span></p>
<p><span class="font45" style="font-weight:bold;">4.2.3 SETUP Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">By calling SETUP, the active transaction simulates the time it spends being set up at a facility. SETUP schedules the transaction to be activated at the end of its setup phase, targeting it to a specified statement number. During its setup phase, the transaction is not preemptible.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SETUP (ST,UFA,IDN,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">ST&nbsp;Setup time</span></p>
<p><span class="font45" style="font-weight:bold;">The active transaction requests to be set up for ST time units.</span></p>
<p><span class="font47" style="font-weight:bold;">UFA&nbsp;Facility number (Type number)</span></p>
<p><span class="font47" style="font-weight:bold;">The facilities are identified by sequential numbers»</span></p>
<p><span class="font47" style="font-weight:bold;">ION&nbsp;Target</span></p>
<p><span class="font45" style="font-weight:bold;">SETUP targets the transaction to this statement number, where it is to continue its activities at the end of its setup phase. That will normally be a call to WORK.</span></p>
<p><span class="font45" style="font-weight:bold;">A1005 Scheduling exit</span></p>
<p><span class="font45" style="font-weight:bold;">SETUP deactivates the calling transaction by placing it in the scheduled state. Then flow management must re* ceive control again, so that it can activate another transaction, ft 1006 Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine returns via this exit if a transaction tries to be set up at a facility it doesn't occupy. IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT «0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SETUP uses the activation list, the TX matrix and the FAC matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Error check&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction that doesn't occupy the facility numbered 'NFA' has no business trying to be set up there; the model is incor~ rectly designed.&nbsp;.&nbsp;i</span></p>
<p><span class="font45" style="font-weight:bold;">•Set up the facility&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 FAC(NFA,1) s - LTX FAC(NFA<sub>f</sub>3) * 1 AL(LTX<sub>9</sub>1) s IDN AL(LTX,2) s T ♦ ST RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">We mark the facility occupied<sub>9</sub> non-interruptible and setting up. Then we schedule the transaction and return to flow management.</span></p>
<p><span class="font45">4.2.4 KNOCKD Purpose:</span></p>
<p><span class="font45">By calling KNOCKD, the active transaction simulates the time it spends being knocked down at a facility.</span><span class="font45" style="font-weight:bold;font-style:italic;"> KNOCKD</span><span class="font45"> schedules the transaction to be activated at the end of its knockdown phase, targeting it to. a specified statement number. During its knockdown phase, the transaction is not preemptible.</span></p>
<p><span class="font47">Knockdown time</span></p>
<p><span class="font47">The active transaction requests to be knocked KT time units,</span></p>
<p><span class="font47">Pacility number (Type number)</span></p>
<p><span class="font47">The facilities are identified by sequential numbers. Target</span></p>
<p><span class="font47">KNOCKD targets the transaction to this statement number, where it is to continue its activities at the end of its knockdown phase. That will normally be a call to CLEAR. Scheduling exit</span></p>
<p><span class="font47">KNOCKD deactivates the calling transaction by placing it In the scheduled state. Then flow management must re* ceive control again, so that it can activate another transaction. Error exit</span></p>
<p><span class="font47">The subroutine returns via this exit if a transaction tries to be knocked down at a facility it doesn/t occupy.</span></p>
<p><span class="font47">Trace control</span></p><div>
<p><span class="font47">KT</span></p>
<p><span class="font47">UFA IDN</span></p>
<p><span class="font45" style="font-weight:bold;">A1005</span></p></div><div>
<p><span class="font47">down for</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">41006</span></p>
<p><span class="font47">IPRINT</span></p></div><div>
<p><span class="font47">Calling sequence:</span></p>
<p><span class="font47">CALL KNOCKD &lt;KT<sub>t</sub>MFA<sub>f</sub>IDII,*1005t4t006<sub>f</sub> IPItlMT) Parameters;</span></p></div>
<p><span class="font47">Trace printouts are suppressed when IPRXNT</span></p>
<p><span class="font45" style="font-weight:bold;">0.</span></p>
<p><span class="font47">Data area:</span></p>
<p><span class="font47">KNOCKD uses the activation list, the TX matrix and the PAC matrix.</span></p>
<p><span class="font47">Algorithm description:</span></p>
<p><span class="font47">&quot;Error check&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IABS(FAC(NFA,1)).E0.LTX) GOTO 100 RETURN 2</span></p>
<p><span class="font47">A</span><span class="font45" style="font-weight:bold;"> transaction that doesn't occupy the facility numbered</span><span class="font47"> <sup>#</sup>NFA' has</span><span class="font45" style="font-weight:bold;"> no business trying to be knocked down there; the model</span><span class="font47"> is</span><span class="font45" style="font-weight:bold;"> incorrectly designed.*</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Knock down the facility&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 FAC(NFA,1) * - LTX FAC(NFA,</span><span class="font52" style="font-variant:small-caps;">3) - 3 </span><span class="font45" style="font-weight:bold;">AL(LTX,1) x IDN AL(LTX,2) s T ♦ KT RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">We mark the facility occupied, non-interruptible and knocking down. Then we schedule the transaction and return to flow management .</span></p>
<p><span class="font43" style="font-style:italic;">t</span></p><div>
<p><span class="font50" style="font-weight:bold;">TASK-PROCESSING BRANCH</span></p>
<p><span class="font50" style="font-weight:bold;">GENERA</span></p></div>
<p><span class="font50" style="font-weight:bold;">ZNTERROPT-PROCESSINO BRANCH</span></p>
<p><span class="font50" style="font-weight:bold;">GENERA</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark155">I&nbsp;I&nbsp;I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I SEIZE ' I&nbsp;I&nbsp;PREEMP I</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark270">I&nbsp;I&nbsp;I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark271">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark272">I&nbsp;II&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I WORK&nbsp;I&nbsp;I&nbsp;WORK I</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark273">I&nbsp;III</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark274">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I ------------------------------</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark275">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark276">I CLEAR&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark277">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark278">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark279">I TERMIN&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark280">I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">FIGURE</span><span class="font39" style="font-style:italic;"> 20</span><span class="font45" style="font-weight:bold;">&nbsp;PREEMPTION OF A TRANSACTION BÏ</span></p>
<p><span class="font45" style="font-weight:bold;">A CLOCK SIGNAL</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">* To simulate a facility with all three service phases, use the following sequence of statements:</span></p>
<p><span class="font45" style="font-weight:bold;">2&nbsp;CALL PREEMP (NFA,2,41005,XPRTNT)</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SETUP (ST,UFA,3,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">3&nbsp;CALL WORK (WT,NFA,3,IEX,41005,41006,TPRTNT) CALL KUOCKD (KT,fJPA,J4,41005,41006, IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">H CALL CLEAR (NFA,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">The sequence differs from that in section 4.2.1 only in that the calls to SETUP and nJOCKD have been inserted and the call to CLEAR has a statement number. Of course a facility could also</span></p>
<p><span class="font47" style="font-weight:bold;">have any two of the three phases, or It could have any number of work phases.</span></p>
<p><span class="font47" style="font-weight:bold;">• SETUP and ICNOCfCD are similar to ADVANC (see 2.5.1), except that they mark the facility's service phase and decree the facility's occupant non-lnterruptible.</span></p>
<p><span class="font45" style="font-weight:bold;">H.3 Multiple Entries to a Facility</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions can easily acquire a facility from various processing paths in a model; some of them could acquire the facility by means of one call to SEIZE; others acquire it by means of a second. Both calls would specify the same facility number</span><span class="font47" style="font-weight:bold;"> (UFA). </span><span class="font45" style="font-weight:bold;">Multiple entries are especially useful where transactions in one processing path preempt transactions that acquired the facility in another.</span></p>
<p><span class="font45" style="font-weight:bold;">Exaaple:&nbsp;r</span></p>
<p><span class="font47" style="font-weight:bold;">• A</span><span class="font45" style="font-weight:bold;"> computer's central processing unit is to be time-sliced: whichever task is being processed should be preempts after so and so much time, to give other tasks a shot at the CPU. ^e preempted task returns to the queue, along with a code showing how auch processing time it has left. Then the other tasks have a chance at the CPU.</span></p>
<p><span class="font45" style="font-weight:bold;">In the system's model, the transactions representing tasks acquire the facility (CPU) by means of a call to SEIZE. The interrupting signals, which the model generates at regular intervals, are highest-priority transactions. Their only purpose in life is to interrupt the tasks, which they do by calling PREEMP from the second processing path. After it has processed the interruption, the CPU is again free, whereupon the next task in the queue acquires it. Figure 20 shows the tasks' and interruptions' paths through the model.</span></p>
<p><span class="font47" style="font-weight:bold;">NULTIFACILITIES</span></p>
<p><span class="font47" style="font-weight:bold;">Multifacilities are, in M9«not<sub>9</sub> a group of facilities that share a</span><span class="font45" style="font-weight:bold;"> queue.</span></p>
<p><span class="font45" style="font-weight:bold;">5.1 The Structure of Multifacilities</span></p>
<p><span class="font45" style="font-weight:bold;">A aultifacility consists of entities we shall call service</span><span class="font47" style="font-weight:bold;"> el</span><span class="font45" style="font-weight:bold;">ements, each of which serves one transaction at a time,</span><span class="font47" style="font-weight:bold;"> A aulti</span><span class="font45" style="font-weight:bold;">facility 's service elements operate in parallel and they all take transactions from the same queue. A aultifacility may contain any number m of service elements. In case m*1, it works just like</span><span class="font47" style="font-weight:bold;"> a </span><span class="font45" style="font-weight:bold;">simple facility.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* A computing system with multiple processors is simulated most easily using a multifacility. Each processing unit is a service element and the jobs being processed form a ready queue, from which they acquire whichever processor happens to be free.</span></p>
<p><span class="font45" style="font-weight:bold;">A multifacility's queue is administered by a policy and in its service elements by a plan. The policy selects from among the waiting transactions the one to be processed next, just as a normal facility's policy would. The plan is a procedure that decides which of a multifacility's service elements a transaction should acquire (see figure 21). The plan serves a further function during preemptions: it decides which service element to clear to make room for the preempting transaction.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45">*&nbsp;Under the plan</span><span class="font45" style="font-weight:bold;"> 'FIRST',</span><span class="font45"> a task acquires the first free</span><span class="font45" style="font-weight:bold;"> service </span><span class="font45">element in the multifacility, whichever that may be. Since FIRST searches the service elements sequentially, starting at</span><span class="font45" style="font-weight:bold;"> the </span><span class="font45">first, the earlier ones will be used more heavily. FTRST-M (First-Modified) uses the service elements more uniformly</span><span class="font45" style="font-weight:bold;"> by </span><span class="font45">starting its search where it left off the last time.</span></p>
<p><span class="font45">•&nbsp;In preemptions, the plan 'PRIOR' (Priority dependence) clears whichever service element happens to be processing the lowest— -priority transaction.</span></p>
<p><span class="font45">A multifacility is homogenous if each task can be served by any of its elements; no task is ever assigned to a special element. Real systems are often non-homogenous in this sense, especially if tasks can be preempted. A preempted task may have to come back to the same service element where it began.</span><span class="font45" style="font-weight:bold;font-style:italic;"> GPSS^F</span><span class="font45"> s multifacilities are</span><span class="font45" style="font-weight:bold;"> homogenous,</span><span class="font45"> so far as arriving transactions are concerned<sub>f</sub> but each preempted transaction can specify whether it shall be bound to the element that began serving it.</span></p><div>
<p><span class="font76" style="font-weight:bold;">5</span></p></div>
<p><span class="font47" style="font-weight:bold;"><a name="bookmark231"></a>WAIT QUEUE</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark281">I---I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark282">I--I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark283">I---I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark284">I---I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark285">I POLICY FOR&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark286">I MANAGING THE&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark287">I WAIT QUEUE&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark288">I PLAN FOR&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark289">I ASSIGNING&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;">I SERVICE ELEMENTS I</span></p>
<p><span class="font75"><a name="bookmark270"></a>I &quot; I</span></p>
<p><span class="font45" style="font-weight:bold;">I SERVICE I I SERVICE (&nbsp;I SERVICE |</span></p>
<p><span class="font45" style="font-weight:bold;">I ELEMENT 1 | | ELEMENT 2 I&nbsp;I ELEMENT M |</span></p>
<p><span class="font45" style="font-weight:bold;">I&nbsp;I I&nbsp;I&nbsp;I&nbsp;I</span></p>
<p><span class="font45" style="font-weight:bold;">FIGURE 21&nbsp;MULTIFACILITY STRUCTURE</span></p>
<p><span class="font45" style="font-weight:bold;">Data</span><span class="font45"> area:</span></p>
<p><span class="font45" style="font-weight:bold;">Each multifacility has a line in the MFAC matrix, which is defined as follows:</span></p>
<p><span class="font45">INTEGER MFAC</span></p>
<p><span class="font45">DIMENSION MFAC(&quot;MFACI&quot;,2)</span></p>
<p><span class="font45">The matrix's elements are used as follows:</span></p>
<p><span class="font45">MFAC(MFA<sub>t</sub>1) Count of occupied service elements</span></p>
<p><span class="font45">The count for the multifacility whose</span><span class="font45" style="font-weight:bold;"> type</span><span class="font45"> number</span><span class="font45" style="font-weight:bold;"> is </span><span class="font45">MFA is stored here.</span></p>
<p><span class="font45">MPAC(MFA,2) Capacity</span></p>
<p><span class="font45">This number tells how many service elements the multifacility has.</span></p>
<p><span class="font45">The MFAC matrix contains the parameters that describe a multi-facility as a whole. The SE matrix, on the other hand, contains the data relevant to its service elements. It is defined:</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION SE(*3R1»<sub>9</sub>3&gt;</span></p>
<p><span class="font45" style="font-weight:bold;">Its fields are used as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">SE(LSE<sub>9</sub>1) Occupation code</span></p>
<p><span class="font45" style="font-weight:bold;">This field shows which transaction occupies the serv-ice element. It also specifies whether or not the transaction is Interruptible (preemptible) or not. </span><span class="font44" style="font-weight:bold;font-variant:small-caps;">SE(LSE,1</span><span class="font45" style="font-weight:bold;">)sO The service element is free. </span><span class="font44" style="font-weight:bold;font-variant:small-caps;">SE(LSE<sub>9</sub>1)</span><span class="font48" style="font-variant:small-caps;">s</span><span class="font44" style="font-weight:bold;font-variant:small-caps;">L?X</span><span class="font45" style="font-weight:bold;"> The transaction whose line is</span><span class="font44" style="font-weight:bold;font-variant:small-caps;"> LTX</span><span class="font45" style="font-weight:bold;"> in</span></p>
<p><span class="font45" style="font-weight:bold;">the activation list occupies the service element; it is interruptible. SE(LS£<sub>9</sub>1)a-LTX The transaction whose line is LTX in</span></p>
<p><span class="font45" style="font-weight:bold;">the activation list occupies the ser-vice element; it is not interrupt« ible.</span></p>
<p><span class="font45" style="font-weight:bold;">SE(LSE<sub>9</sub>2) Preemption code</span></p>
<p><span class="font45" style="font-weight:bold;">The code shows whether or not a preemption is in progress.</span></p>
<p><span class="font45" style="font-weight:bold;">SE(LSE<sub>9</sub>2)sO A preemption is not in progress. The</span></p>
<p><span class="font45" style="font-weight:bold;">transaction at this service element is in its normal processing phase. SE(LSE<sub>f</sub>2)s1 A preemption is in progress.</span></p>
<p><span class="font48"><a name="bookmark290"></a>SE(LSE»3) Service</span><span class="font45" style="font-weight:bold;"> phase</span></p>
<p><span class="font45" style="font-weight:bold;">This field shows the service element's current service phase (see</span><span class="font44" style="font-weight:bold;font-variant:small-caps;"> 4.2.2): </span><span class="font45" style="font-weight:bold;">SE(LSE<sub>f</sub>3)*1 Setup </span><span class="font44" style="font-weight:bold;font-variant:small-caps;">SE(LSE<sub>t</sub>3)*2</span><span class="font45" style="font-weight:bold;"> Work </span><span class="font44" style="font-weight:bold;font-variant:small-caps;">SE(LSE<sub>9</sub>3)</span><span class="font48" style="font-variant:small-caps;">s</span><span class="font44" style="font-weight:bold;font-variant:small-caps;">3</span><span class="font45" style="font-weight:bold;">&nbsp;Knockdown</span></p>
<p><span class="font45" style="font-weight:bold;">Since each service element in the whole of GPSS-f has a line in the SE matrix<sub>9</sub> its &quot;SE1* dimension limits the number of serv-ice elements that a given model can simulate.</span><span class="font52" style="font-variant:small-caps;"> a</span><span class="font45" style="font-weight:bold;"> multifacility basis vector (MBV) divides up the SE matrix to show which lines belong to which multifacility. It is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER MBV</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION f!EV( &quot;fTFACI*)</span></p>
<p><span class="font45" style="font-weight:bold;">Each field in the vector has the following meaning:</span></p>
<p><span class="font45" style="font-weight:bold;">MBV(MFA) Pointer to the multifacility*s first service element</span></p>
<p><span class="font45" style="font-weight:bold;">A single multifacility's service elements have consecutive lines in the SE matrix. The multifacility whose number is MFA has the SE matrix lines starting with the one pointed to by this field.</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine INIT2 (see 2.6.3) assigns service elements to mul-tifacilities at simulation startup and initializes the basis vector. Figure 22 diagrams the structure that the basis vector imposes on the SE matrix.</span></p>
<p><span class="font50" style="font-weight:bold;">SB MATRIX</span></p>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font50" style="font-weight:bold;">HULTI- &lt; FACILITY | MFA m 1 |</span></p>
<p><span class="font50" style="font-weight:bold;">I SE(1,1) | SE(1,2)</span></p>
<p><span class="font77"><a name="bookmark291"></a>T</span></p>
<p><span class="font48"><a name="bookmark292"></a>I SB(1,3) |&lt;~</span></p>
<p><span class="font45" style="font-weight:bold;">—------- I</span></p>
<p><span class="font45" style="font-weight:bold;">I -</span><span class="font50" style="font-weight:bold;">«BY VECTOR I MBV(1)</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p><div>
<p><span class="font40">&lt;—</span></p>
<p><span class="font45" style="font-weight:bold;">I I I</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font45" style="font-weight:bold;">HULTI* &lt; FACILITY I MFA&nbsp;|</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">1</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">™| HBV(NFA)</span></p></div>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font50" style="font-weight:bold;">&lt;---1 MBV(&quot;ftFAC1&quot;) |</span></p>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font45" style="font-weight:bold;">MULTI« &lt; FACILITY I MFA « I -&quot;MFAC1&quot; —I</span></p>
<p><span class="font45" style="font-weight:bold;">FIGURE 22&nbsp;THE SE MATRIX AMD THE MULTIFACILITY BASIS VECTOR</span></p>
<p><span class="font45" style="font-weight:bold;">Not«:</span></p>
<p><span class="font45" style="font-weight:bold;">* The total number of service elements available to the user is set when the simulator is dimensioned (see appendix A3). A model may assign the available service elements to multifacilitles any way it sees fit. The model specifies each multifacility's capacity in Section 4 of the chassis by means of a direct entry in the MFAC matrix (see 2.6.1 and 11.5).</span></p>
<p><span class="font47" style="font-weight:bold;">5.2 Acquiring and Freeing a Multifacility</span></p>
<p><span class="font47" style="font-weight:bold;">HSEIZE acquires and MCLEAR frees a multifacility fer the ae-tive transaction. MWORK simulate» the time a transaction speeds being served.</span></p>
<p><span class="font45" style="font-weight:bold;">9.2.1 HSEIZE Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction tries to acquire a service element at a</span><span class="font47" style="font-weight:bold;"> mult</span><span class="font45" style="font-weight:bold;">if</span><span class="font47" style="font-weight:bold;">a-</span><span class="font45" style="font-weight:bold;">cllity by calling MSEIZE. The program looks to see if the</span><span class="font47" style="font-weight:bold;"> multl-</span><span class="font45" style="font-weight:bold;">facility has an element free. If so<sub>9</sub> the active transaction acquires it. When the element was the last one free<sub>9</sub> HSEIZE marks the aultlfacility inaccessible. If there are no free elements, the calling transaction is blocked and entered in the aultifacuity's queue.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL MSEIZE CftFA, ID,REP ,A 1005, &amp; 1006 ,IPRINT)</span></p>
<p><span class="font50" style="font-weight:bold;"><a name="bookmark293"></a>Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">The parameters whose descriptions differ essentially from those for subroutine SEIZE are REP and A1006.</span></p>
<p><span class="font45" style="font-weight:bold;">UFA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Yfultifacilities are identified by consecutive numbers. ID&nbsp;HSEIZE CALL'S statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If îtSEIZE blocks an arriving transaction, ID specifies the target where the transaction will continue its activity when it is re-activated. At that time, its activity should be to acquire a service element. Therefore, ID should specify the same CALL MSEIZE statement that caused the transaction to enter the queue. REP&nbsp;Repeat code</span></p>
<p><span class="font45" style="font-weight:bold;">Since a transaction that acquires a service element by means of MSEIZE can be preempted, REP provides a means of specifying whether the transaction must be boun4 to the element that began serving it, i.e. whether it must come back to that element when it is re-activated. REP s 0 The transaction need not be bound to its initial element; it may acquire any element when it is re-activated.</span></p>
<p><span class="font45" style="font-weight:bold;">REP s 1 The transaction must be bound to its initial element. §1005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction tries to acquire a multifacility that is fully occupied, it must be blocked. In that case transaction management must again receive control. </span><span class="font57" style="font-weight:bold;">MG06</span><span class="font45" style="font-weight:bold;"> Plan-error exit&nbsp;&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">If no plan is provided for this multifacility, or if no service element can be found, even though the multi-facility isn't fully occupied, then MSEIZE returns via</span></p>
<p><span class="font45" style="font-weight:bold;">this wit. It is reco</span><span class="font45" style="font-weight:bold;text-decoration:line-through;">mmend</span><span class="font45" style="font-weight:bold;">ed to terminate simulation la</span></p>
<p><span class="font45" style="font-weight:bold;">__ such eases.</span></p>
<p><span class="font45" style="font-weight:bold;">IPKirr Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPtltfT » 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">MSEIZE uses the net i vat ion list, the TX matrix <sub>9</sub> the MPAC matrix, the SE matrix and the state vector«</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">K « &quot;EFAC&quot; ♦ MFA</span></p>
<p><span class="font45" style="font-weight:bold;">The station number K is computed from the type number MFA.</span></p>
<p><span class="font45" style="font-weight:bold;">^Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 300 OK s 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(ftFAC(MFA<sub>f</sub>1).EQ.HFAC(MFA<sub>f</sub>2)) GOTO 300&nbsp;*</span></p>
<p><span class="font45" style="font-weight:bold;">The watchdog sniffs the arriving transaction to see whether or not it has been in the queue; If not<sub>9</sub> it must be blocked. Then the program checks whether or not the transaction can acquire, an element in the muitifacility. If the multifacility has any free elements, the program continues with &quot;Assign a service element according to the plan&quot;; otherwise it jumps to &quot;Block&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Assign a service element according to the plan&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,7).EQ.0) GOTO 100 LSE * TX(LTX<sub>f</sub>7) IF(SE(LSE,1) .NE.0) GOTO 200 GOTO 150 100 CALL FLA</span><span class="font39" style="font-style:italic;"> Hi</span><span class="font45" style="font-weight:bold;">(MFA ,&amp;400) IF(LSE.EQ.O) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction is coming back after having once been empted, MSEIZE asks whether the returner is bound to its original element. If so<sub>9</sub> only that element need to be tested; when it is occupied, the program jumps to &quot;Lock*. New arrivals and non-bound returners are assigned an element according to the plan responsible for this multifacility. If the plan's search is successful, it returns the element's line number, LSE. The program can then continue with &quot;Acquire*. If the plan can find no element, MSEIZE jumps to &quot;Lock&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Acquire&quot;</span></p>
<p><span class="font45">150 MFAC(MFA,1) s MFAC(MFA,1) v 1</span></p>
<p><span class="font45">IF(MFAC(MFA,1).E0.MFACC MFA,2)) STATE(K) = O SE(LSE,1) « LTX -TX(LTX<sub>f</sub>5) • ID</span></p>
<p><span class="font45" style="font-weight:bold;">' IP(REP.EQ.1) TX(LTX,7) » LSI TX(LTX,8) * 0 RETURN</span></p>
<p><span class="font47" style="font-weight:bold;">Ifi as a result of the acquisition, the aultifacility is fully occupied, MSEIZE sets the state vector to show it inaccessible. Then, SEIZE sets the acquiring transaction's line number, LTX, la SE(LSE,1), clears the transaction's bloek time and sets its re* peat code.</span></p>
<p><span class="font45" style="font-weight:bold;">•Lock&quot;</span></p>
<p><span class="font39" style="font-style:italic;">200</span><span class="font45" style="font-weight:bold;"> AL(LTX, 1) s ID&nbsp;.&nbsp;' ;</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) * - &quot;KEND&quot; - X IF(TX(LTX,8) .EQ.O) TX(LTX,8) * T RETURN I&nbsp;. - &quot; . •&nbsp;'^^^j</span><span class="font45" style="font-weight:bold;text-decoration:underline;">Kfm</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction is locked if the multifsieility haai free elements, but cannot assign one of them to the calling transaction. Such cases arise, e.g., when a preempted transaction tries to reacquire the element at which it started processing. (REPst), but that element isn't free. If the transaction wer$'merely blocked, Instead of being locked, the simulator would go into aij endless loop: since the multifacility is free, that transaction would be chosen over and over to acquire an element that actually unavailable.&nbsp;': J tC^? r^l^lS</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction leaves the multifacility* 1*&nbsp;happen</span></p>
<p><span class="font45" style="font-weight:bold;">to free precisely the element on which such a locked transaction is waiting. Hence, MCLSAR will have to place all locked transactions in the blocked state, each time an element is freed (see 5.2.3 &quot;Start the locked transactions&quot;).</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block&quot; '</span></p>
<p><span class="font45" style="font-weight:bold;">300 AL(LTX, t) s 10 AL(LTX,2) *</span><span class="font45" style="font-weight:bold;font-style:italic;"> X </span><span class="font45" style="font-weight:bold;">TX(LTX,8) s T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">.'•SEIZE blocks a transaction, if the multifacility has no free elements, or if the watchdog forbids acquisition.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Incorrect multifacility occupation&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">400 RETURN 2 END</span></p>
<p><span class="font45" style="font-weight:bold;">If there is no plan for this multifacility, or if</span><span class="font43" style="font-style:italic;"> no</span><span class="font45" style="font-weight:bold;"> element can be found, even though the multifacility isn't&quot; folly occupied, the program returns via the error exit.</span></p>
<p><span class="font47" style="font-weight:bold;">5+2.2 H WORK Purpose:</span></p>
<p><span class="font47" style="font-weight:bold;">By calling flWORK, the active transaction simulates the tine It spends being served at a multlfacility's service element. MWORK schedules the transaction to call It again after it has been served, then returns to flou management. At the end of its service phase, when the transaction calls MWORK again, the program recognises it and, leaving it active, returns normally to the statement following the call.</span></p>
<p><span class="font47" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font47" style="font-weight:bold;">CALL MWORK (WT,MFA,ID,IEX,41005,41006,IPRIHT)</span></p>
<p><span class="font47" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Work time</span></p>
<p><span class="font45" style="font-weight:bold;">The active transaction requests to be served for HT time units. If the simulator's clock shows time T, MWORK schedules the transaction to be re-activated at T ♦ WT. Multifacillty number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The multifacllities are identified by sequential numbers.</span></p>
<p><span class="font45" style="font-weight:bold;">MWORK CALL'S statement number</span></p>
<p><span class="font45" style="font-weight:bold;">MWORK targets the transaction to call it again at the end of its work phase. It does that by entering its own statement number, which is passed to it in ID, and the re-activation time in the activation list. Preemption code</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter specifies whether the active transaction may be preempted once it has acquired a service element. IEX * 0 The transaction may be preempted in case a higher-priority transaction desires to be served.</span></p>
<p><span class="font45" style="font-weight:bold;">IEX * 1 The transaction may not be preempted. Scheduling exit</span></p>
<p><span class="font45" style="font-weight:bold;">MWORIC deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another transaction. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine returns via this exit if a transaction</span></p>
<p><span class="font45" style="font-weight:bold;">tries to be served at a service element it doesn't occu</span><span class="font49">py.</span></p>
<p><span class="font45" style="font-weight:bold;">Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRIMT s 0.</span></p><div>
<p><span class="font45" style="font-weight:bold;">ІГГ</span></p>
<p><span class="font45" style="font-weight:bold;">MFA ID</span></p>
<p><span class="font47" style="font-weight:bold;">IEX</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">«1005</span></p>
<p><span class="font45" style="font-weight:bold;">A 1*006</span></p>
<p><span class="font45" style="font-weight:bold;">IPRIMT</span></p></div>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">MWORt uses the activation list, the TX matrix апф thé art! СОММОН/MFA/. .;' ***</span></p>
<p><span class="font39" style="font-style:italic;">Algorithm</span><span class="font48"> diterlptloa:</span></p>
<p><span class="font47" style="font-weight:bold;"><a name="bookmark294"></a>•Plod the transaction's strviet tltMnt&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">11&nbsp;a IfBV(MFA)</span></p>
<p><span class="font39" style="font-style:italic;">12&nbsp;</span><span class="font45" style="font-weight:bold;">s 11</span><span class="font39" style="font-style:italic;"> ♦ НГАС(ПГА<sub>9</sub>2У</span><span class="font45" style="font-weight:bold;"> ~ 1 00 100 LSB s II <sub>f</sub> 12 IF( IABS(SE(LSE<sub>t</sub>1)).EQ.LTX) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;">100 CONTINUE •&nbsp;ЩЩр RETURN 2</span></p>
<p><span class="font45" style="font-weight:bold;">First MVORK finds&nbsp;out which service eleeent the transaction occupies. If its search falls, it takes the error exit.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Serving decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">200 IF(SE(LSE,2).EQ.O)</span><span class="font39" style="font-style:italic;"> GOTO 250</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SE(LSE,3bBQ.1) TX(LTX,6) s ИТ/ RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">250 IF(SE(LSE<sub>t</sub>3).EQ.2) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">This section culls out returning or preempted transactions aiut issues a normal return when it finds them. If a preemption is In progress, SE(LSE,2) will be non-zero. If the transaction has Just completed its setup phase, SE(LSE,3) will be 1, in which ease -its remaining work time (TX(LTX,6)) is the entire time it would/;have been served, VT. Preempted transactions remain active and HV0RK returns to the statement following its call.</span></p>
<p><span class="font45" style="font-weight:bold;">If a preemption isn't in progress, the subroutine culls out transactions returning to report the end of their work phase; they will have a phase code of 2 in SB(LSE<sub>9</sub>3K Those transactions also remain active and WORK returns normally.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions at the start of their work phase fall through to the next section, if a preemption isn't in progress.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Serve&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IEX.EQ.O) SE(LSE,1&gt; a LTX IF(IEX.EQ.1&gt; SE(LSS<sub>t</sub>1) * - LTX SE(LSE<sub>f</sub>3) « 2</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,6).NE.0) GOTO 400&nbsp;v</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,1) a ID AL(LTX,2) a T ♦ VT RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">The service element's data area is set to show that it is in its work phase (S!£(LSE,3) a 2) and that its occupant is inter-ruptible or ^ot.Jtf the transaction was once preempted and hasn't yet been completely served, TX(LTX,6} will show how much time it has left to ярепЛ' in the work phase; J*W0RK jumps to &quot;Serve reacquiring transactions&quot;. Finally, if the calling transaction is being served from scratch, tfWORK schedules it by setting a time and target in its activation-list entry and then returns to flow management .</span></p>
<p><span class="font45" style="font-weight:bold;">dvrr« ruau4uiriiis wranaavwiuna</span></p>
<p><span class="font45" style="font-weight:bold;">300</span><span class="font45"> AL(LTX<sub>f</span><span class="font45" style="font-weight:bold;"></sub>1) « ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) s T ♦ TX(LTX,6) TX(LTX,6) «0 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">In a re-acquisition, MWOR* schedules the calling transaction to be served for the remainder of its processing time.</span></p><div>
<p><span class="font45" style="font-weight:bold;">EXIT 1</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">41006</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">IPRIMT</span></p></div>
<p><span class="font45" style="font-weight:bold;">5*2.3 MCLEAR Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">By calling MCLEAR, the active transaction frees the service element it occupies.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL MCLEAR (T1FA , EXIT1<sub>1</sub>A1006,1 PR I NT )</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">«FA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The multifacility*s identifying number is given here. Preemption exit</span></p>
<p><span class="font45" style="font-weight:bold;">MCLEAR takes this exit when the calling transaction is being preempted from the multifacility. If the user chooses, he may have the subroutine return to a section of his own code, so as to count preemptions or whatever. Then, since MCLEAR has blocked the preempted transac-tion, he must Jump to flow management. If the user need take no special action when a preemption occurs, he should code &amp;10Q5 here; then MCLEAR returns directly to ACTIV2. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">MCLEAR exits to this statement number when the active transaction doesn't occupy a service element in the multifacility it is trying to leave. Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT * 0* Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">MCLEAR uses the MFAC matrix, the state vector, the TX matrix, the SE matrix and the basis vector, MBV.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find the transaction's service element&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IT» MBV(MFA)</span></p>
<p><span class="font45" style="font-weight:bold;">tZ s II ♦ MFAC(MFA <sub>f</sub> 2) - 1</span></p>
<p><span class="font45" style="font-weight:bold;">DO 50 LSE s 11 , 12</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IABS(SE(LSE,1 )).EQ.LTX) GOTO 100 50 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span><span class="font39" style="font-style:italic;"> 2 ■</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">first</span><span class="font45" style="font-weight:bold;"> MCLEAR finds out vhich clmtot tlM transaction occupies, if its search fails, it takes the error exit. .</span></p>
<p><span class="font45" style="font-weight:bold;">•Free&quot;&nbsp;*</span></p>
<p><span class="font45" style="font-weight:bold;">100 DO 150 I » 1 , 3 150 SE(LSE,I) » 0</span></p>
<p><span class="font45" style="font-weight:bold;">HFACOlFA, 1 ) a f1FAC(HFA, 1 ) - 1</span></p>
<p><span class="font45" style="font-weight:bold;">The program clears the service element's data area and decrements the count of occupied elements.</span></p>
<p><span class="font45" style="font-weight:bold;">•Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">К ш &quot;EFAC&quot; ♦ MFA</span></p>
<p><span class="font45" style="font-weight:bold;">The station number К is co&lt;»pu&amp;4d fro« the type number MlFA.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Terminate the occupation&quot; .&nbsp;-л а</span><span class="font29" style="font-weight:bold;">Ш</span><span class="font45" style="font-weight:bold;">^^</span><span class="font29" style="font-weight:bold;">ШШ</span><span class="font45" style="font-weight:bold;">^^^</span><span class="font45" style="font-weight:bold;text-decoration:underline;">^^</span><span class="font29" style="font-weight:bold;text-decoration:underline;">МИ</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX<sub>f</sub> 6) .EÛ.0) GOTO ■ AL(LTX<sub>t</sub> 1) s TX(LTX,5) ^ &quot;</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) x - К&nbsp;-</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX<sub>f</sub>8) s T&nbsp;ЩШЁ Щ</span></p>
<p><span class="font39" style="font-style:italic;"><a name="bookmark295"></a>2oo</span><span class="font52" style="font-variant:small-caps;"> tx(ltx,5&gt; « a .&nbsp;gaégl■</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,6).EQ.0)</span><span class="font39" style="font-style:italic;"> TX(LTX,7) *</span><span class="font45" style="font-weight:bold;"> О</span></p>
<p><span class="font45" style="font-weight:bold;">If the calling transaction has been preempted, it belongs in the facility's queue again* since it has to come back to finish being served. MCLEAR recognizes preempted transactions from the fact that their residual-preecssing-time field <sub>r</sub> TX{LTX.,é), been filled in. The blocked transaction is targeted to the call to MPREEM that caused it to be preempted^ Transactions leaving the multifacility for good don't need the return code in TX(LTX,7l any more, so it is cleared.&nbsp;V'V '&nbsp;'</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark296">&quot;Start the locked transactions&quot;&nbsp;1</a></span></p>
<p><span class="font52" style="font-variant:small-caps;"><a href="#bookmark297">state(k) * 1&nbsp;tf :</a></span></p>
<p><span class="font45" style="font-weight:bold;">CALL UNLOCK (*C,IPR INT)</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark298">IF(TX(LTX,6).EQ.0) RETURN&nbsp;'</a></span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions locked in front of a multifacility are always waiting on a specific element, even though others may be free. When an element is freed by means of MCLEAR<sub>t</sub> the locked transactions must be given a chance to try to acquire the one on which they are waiting* They are given that chance by being started, i.e. by being placed in the blocked state.</span></p>
<p><span class="font42" style="font-weight:bold;font-style:italic;">preemption vorks</span><span class="font45" style="font-weight:bold;"> at nulti/*acllltl«3 pretty »uch Ilk* It does </span><span class="font42" style="font-weight:bold;font-style:italic;">at facilities: M PRE Et* cuts off a transaction's service</span><span class="font45" style="font-weight:bold;"> without </span><span class="font42" style="font-weight:bold;font-style:italic;">ceremony and starts it on</span><span class="font45" style="font-weight:bold;"> Its</span><span class="font42" style="font-weight:bold;font-style:italic;"> way</span><span class="font45" style="font-weight:bold;"> back to the qu«u«.</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">5*3* 1 MPRBEtt&nbsp;'</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">purpose: . v.'vV. /•</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">MPREEM acts like MSEIZE, except that it preempts</span><span class="font45" style="font-weight:bold;"> on« of a mul-</span><span class="font45" style="font-weight:bold;font-style:italic;">tifacility's current occupants, if the new arrival is important enough to warrant immediate service.</span></p>
<p><span class="font47">j/</span><span class="font70" style="font-style:italic;"> MPREEti</span><span class="font45" style="font-weight:bold;font-style:italic;"> finds a service element free,</span><span class="font47"> the calling transaction</span><span class="font45" style="font-weight:bold;font-style:italic;"> acquires it; if the multifacility runs</span><span class="font47"> out-Tree. elements as a</span><span class="font45" style="font-weight:bold;font-style:italic;"> result, it has become inaccessible.</span><span class="font47"> Since no,iprectt&amp;fc£oa occurs,</span><span class="font70" style="font-style:italic;"> MPREEM</span><span class="font45" style="font-weight:bold;font-style:italic;"> does exactly what</span><span class="font70" style="font-style:italic;"> MSEIZE</span><span class="font47"> would bave&nbsp;; </span><span class="font52" style="font-variant:small-caps;">1/7</span><span class="font47"> oc</span><span class="font45" style="font-weight:bold;font-style:italic;"> the other hand,</span><span class="font70" style="font-style:italic;"> MPREEti</span><span class="font45" style="font-weight:bold;font-style:italic;"> finds the</span><span class="font47"> booked </span><span class="font53" style="font-style:italic;">up,</span><span class="font45" style="font-weight:bold;font-style:italic;"> it lets a plan decide</span><span class="font53" style="font-style:italic;"> whether</span><span class="font45" style="font-weight:bold;font-style:italic;"> on*</span><span class="font53" style="font-style:italic;"> of</span><span class="font47"> tliè éould be </span><span class="font53" style="font-style:italic;">cleared</span><span class="font45" style="font-weight:bold;font-style:italic;"> to make vay</span><span class="font53" style="font-style:italic;"> for</span><span class="font45" style="font-weight:bold;font-style:italic;"> the new</span><span class="font53" style="font-style:italic;"> arrival</span><span class="font47"> and</span><span class="font53" style="font-style:italic;">, It,</span><span class="font47">one. </span><span class="font45" style="font-weight:bold;font-style:italic;">Then</span><span class="font53" style="font-style:italic;"> It calls the policy to let</span><span class="font47"> it decide wf^e^^ensaetion </span><span class="font53" style="font-style:italic;">should occupy the element chosen by</span><span class="font45" style="font-weight:bold;"> the</span><span class="font53" style="font-style:italic;"> plan,</span><span class="font45" style="font-weight:bold;"> tW policy ./decide*</span><span class="font45" style="font-weight:bold;font-style:italic;"> in</span><span class="font53" style="font-style:italic;"> favor, of</span><span class="font45" style="font-weight:bold;font-style:italic;"> the</span><span class="font53" style="font-style:italic;"> element's occupant, rf^^^</span><span class="font45" style="font-weight:bold;"> eiaply blobks </span><span class="font47">t/re</span><span class="font53" style="font-style:italic;"> calling transaction and returns to flov</span><span class="font47"> aariagefient. But if </span><span class="font53" style="font-weight:bold;font-style:italic;">the</span><span class="font53" style="font-style:italic;"> policy decides against the element -s</span><span class="font47"> ^HMEEM initi-</span><span class="font53" style="font-style:italic;">êtes a preemption: it blocks the arriripg</span><span class="font45" style="font-weight:bold;"> transaction, but it </span><span class="font53" style="font-style:italic;">cuts off the occupant's remaining serving- tiêéiï^ufiv</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;"><a name="bookmark299"></a>Calling sequence:&nbsp;' &gt; &quot;; SSSfeBl</span></p><div>
<p><span class="font45" style="font-weight:bold;">aBBI</span></p></div>
<p><span class="font53" style="font-style:italic;"><a name="bookmark300"></a>«U /«PJttffff (UFA,ID, REP,St 1005iSt 1006, 1 Parameters: '&nbsp;ot; .: v:-<sup>;</sup></span></p>
<p><span class="font45" style="font-weight:bold;">BBKf*'' '&quot;a.' ■ ' r <sup>v</sup> '' &quot;&nbsp;V&nbsp;;&nbsp;'&nbsp;'''.V&nbsp;• ^ .,'.&gt;J&nbsp;• V&nbsp;I *&nbsp;■ \ ffiH</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;"><a name="bookmark301"></a>The parameters uhose descriptions ditfy^] Otsi^iMlly frost those for subroutine</span><span class="font73" style="font-weight:bold;font-style:italic;"> PRBEVP</span><span class="font10" style="font-weight:bold;font-style:italic;"> are</span><span class="font73" style="font-weight:bold;font-style:italic;"> REP</span><span class="font10" style="font-weight:bold;font-style:italic;"> and</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;"><a name="bookmark302"></a>MFA ' Hultifacility number (Type number)</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;"><a name="bookmark303"></a>ffuitifacilities are identified by constculVr*</span><span class="font45" style="font-weight:bold;"> (lunbers*</span></p>
<p><span class="font10" style="font-weight:bold;font-style:italic;"><a name="bookmark304"></a>^ ' MPREEM CALL 'S statement number</span></p>
<p><span class="font73" style="font-weight:bold;font-style:italic;">If HPREEV blocks an arriving</span><span class="font45" style="font-weight:bold;"> tranwction, ID specifies tAe</span><span class="font73" style="font-weight:bold;font-style:italic;"> target uhere the transaction vi 11</span><span class="font45" style="font-weight:bold;"> continue its ac* </span><span class="font73" style="font-weight:bold;font-style:italic;">tifity when It is re-activatedt ilt that time,</span><span class="font45" style="font-weight:bold;"> its activity</span><span class="font73" style="font-weight:bold;font-style:italic;"> should be to acquire a service</span><span class="font45" style="font-weight:bold;"> element*;:</span><span class="font73" style="font-weight:bold;font-style:italic;"> Therefore <sub>9 </sub>- ID should specify the same</span><span class="font45" style="font-weight:bold;">&nbsp;that</span></p>
<p><span class="font73" style="font-weight:bold;font-style:italic;">caused the traiftfSctloh to</span></p>
<p><span class="font74" style="font-weight:bold;font-style:italic;">U| Repeat code v lilliftll^^M Since 9 transaction that acquires an</span><span class="font45" style="font-weight:bold;"> element by,Means of </span><span class="font74" style="font-weight:bold;font-style:italic;">MPREEti can be preempted, REP provides, a jteans'.ot, . sped« fying whether the transaction oust be</span><span class="font48"> fepund to the ele-</span></p>
<p><span class="font74" style="font-weight:bold;font-style:italic;">aent that began serving it,</span></p>
<p><span class="font45" style="font-weight:bold;">HEP » 1 The transaction «ust be bound to Its Initial element. A1005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">FfPREEW takes this exit whenever it blocks the arriving transaction. That occurs In every case, except when the. transaction acquires the facility.« &amp; 1006 Plan-error exit •&nbsp;. &gt;</span></p>
<p><span class="font45" style="font-weight:bold;">If no plan is provided for this aultifaeillty, or if no service element can be found, even though the multifacility isn't fully- occupied, then</span><span class="font48" style="font-variant:small-caps;">c</span><span class="font45" style="font-weight:bold;">'</span><span class="font48" style="font-variant:small-caps;">to</span><span class="font45" style="font-weight:bold;">^</span><span class="font29" style="font-weight:bold;">EM</span><span class="font45" style="font-weight:bold;"> returns via this exit. It is recommended to terminate simulation in such cases. •&nbsp;M&nbsp;<sup>r</sup> '.V<sup>;</sup>;&nbsp;W^m</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area: <sup>#</sup>&nbsp;' ,,.&quot;&gt;;:&nbsp;;;</span></p>
<p><span class="font45" style="font-weight:bold;">MPREEM uses the activation list* the TX matrix, ;WFAC matrix, the SE matrix and the state vector. -&nbsp;•</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">E * &quot;EPAC&quot; ♦ MFJt</span></p>
<p><span class="font45" style="font-weight:bold;">The station number K is computed from the type number ftFA.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark305"></a>K1 s 1&nbsp;V</span></p>
<p><span class="font45" style="font-weight:bold;">IF( WFAC(MFA , 1) . EQ.MFAC&lt;MFA ,2) ) COT^IjOO&nbsp;^</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>;</sup> v Ki * 0 ■ IF(OK.EO.O) GOTO 300 -0K V Q</span></p>
<p><span class="font45" style="font-weight:bold;">If there are no more free elements at thi$ multJ. facility, or if the watchdog barks, the above statements JM^p*^B1 ock••, setting K1 along the way, in order to show^ wHj^^lKf^S^^val is being blocked. . *&nbsp;:<sub>f</sub> ...&nbsp;Vj;'-:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find a free service element&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,7) .E0.0) GQÏ0 100&nbsp;-</span></p>
<p><span class="font45" style="font-weight:bold;">LSE s TX(LTX,7) IF(SE(LSE,1).NE.0) GOTO 200 GOTO 150 100 CALL PLANK MFA ,4400) IF(LSE.EO.O) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions reacquiring an element are weeded out, if t^Rey are bound to the. element they once had. If that element; is free at thç môment, they jump to &quot;Acquire&quot;;</span><span class="font45" style="font-weight:bold;font-style:italic;"> it</span><span class="font45" style="font-weight:bold;"> flot, they ' Jump to &quot;Lock&quot;. The multifacility's plan tries to find a free element for any remaining transactions. If it finds one, it returns the element's line number, LSE, and the program continues to &quot;Acquire*;</span></p>
<p><span class="font45" style="font-weight:bold;">Ж*</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark306"></a>otherwise, it jumps to &quot;Lock*.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Acquire<sup>11</sup>&nbsp;<sub>:</sub></span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark307"></a>150 MFAC(MFA<sub>f</sub>1) » MFAC(MFA.I) &gt; 1</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark308"></a>IF(MFAC(MFA,1).EQ.MFAC(MFA,2)) STATE(K) * 0 SE(LSE,1) s LTX TX(LTX,5) s ID</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark309"></a>IF(REP.EQ.I) TX(LTX,7) s LSE</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark310"></a>TX(LTX,8) * 0 V</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark311"></a>RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If<sub>f</sub> as a result of the acquisition, the multifacility is fully occupied<sub>9</sub> HSEIZE sets the state vector to show it inaccessible. Then<sub>9</sub> SEIZE sets the acquiring transaction's line number, LTX<sub>f</sub> in SE(LSE,1), clears, the transaction's block time and sets its repeat code.&nbsp;v</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lock&quot;'. ' &gt;</span></p>
<p><span class="font45" style="font-weight:bold;">200 AL(LTX, 1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">V.. AL(LTX<sub>f</sub>2) «* - &quot;KEND&quot; - K&nbsp;&quot;&nbsp;'</span></p>
<p><span class="font45" style="font-weight:bold;">. IF(TX(LTX,8).EQ.O) TX(LTX, 8 ) x T RETURN 1&nbsp;&quot;&nbsp;f/v*;</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction Is locked if the multifacility has free elements, but cannot assign one of them to the calling transaction. Such cases arise, e.g., when a preempted transaction tries to reacquire the element at which it started processing (REPsI), but that element isn't free. If the transaction were merely blocked, instead of being locked, the simulator would go into an endless loop: since the multifacility is free that transaction would be chosen oyer and over to acquire an element that is-actually unavailable.&nbsp;;&nbsp;w-</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction leaves the multifacility, it could happen to free precisely the element on which such a locked transaction is waiting. Hence, TtCLEAK will have to place all locked transactions in the blocked state*.each time an element is freed (see 5.2.3 &quot;Start the locked transaction&quot;).</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark312"></a>&quot;Block&quot;</span><span class="font29" style="font-weight:bold;">&nbsp;V <sub>;</sub>&nbsp;&quot;&quot;//:</span></p>
<p><span class="font45" style="font-weight:bold;">300 AL(LTX,1) = ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) = - . TX(LTX<sub>&gt;</sub>8) = T IF(Kl.EQ.O) RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If the watchdog blocks the arriving transaction, MPRESM takes the blocking e*it without further adieu. Otherwise, it continues on to the next -sectionv-T'.fe. ^</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find a preemption candidate&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">CALL PLAllO&lt; **FA, &amp;U 00 )</span></p>
<p><span class="font45" style="font-weight:bold;">IF(iSE.EfiJi0. OR. SE&lt; LSE, 1). LT.0;.AND.SE(LSE, 3).EQ.2) RETURN 1 IFISE(LSE-,3).EQ.3&gt; RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">First, the plan seeks an element it deems fit for preemption. If it cannot find anything, or if .the element it finds is in</span><span class="font47" style="font-weight:bold;"> a </span><span class="font45" style="font-weight:bold;">non-interruptible work phase or knockdown phase, this section suppresses the preemption.^</span></p>
<p><span class="font45" style="font-weight:bold;">•»Call the policy*</span></p>
<p><span class="font44" style="font-weight:bold;font-variant:small-caps;">P0LVECO) s IABS(SE(LSE, 1) &gt; POLC x 1</span></p>
<p><span class="font44" style="font-weight:bold;font-variant:small-caps;">DO 350 I s 1 <sub>f</sub> LAL IF(AL(I,2).NE.-K) GOTO 350 POLC s POLC ♦ 1 POLVEC(POLC) s I 350 CONTINUE</span></p>
<p><span class="font44" style="font-weight:bold;font-variant:small-caps;">CALL POLICY(K)</span></p>
<p><span class="font44" style="font-weight:bold;font-variant:small-caps;">IF(LTX.EQ.IABS(SE&lt; LSE,1))) RETURN 1&nbsp;;</span></p>
<p><span class="font45" style="font-weight:bold;">Here, the policy decides whether a preemption is called for or not. Just as in ACTIV2, MPREEM gathers in POLVEC the line numbers of all transactions waiting at the multifacility<sub>f</sub> inserting the chosen element's occupant as the first entry. Then it calls POLICY (see 3.3). which returns the line number of the transaction it selects -in LTX. If the policy has selected the element's occupant, no preemption is called for.</span></p>
<p><span class="font45" style="font-weight:bold;">•Preempt*</span></p>
<p><span class="font45" style="font-weight:bold;">LTX = IABS(SE(LSE,1)) SE(LSE,2) s 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SE(LSE,3).E0.1) RETURN I TX(LTX<sub>f</sub>6) = AL(LTX,2) ~ T -AL(LTX<sub>f</sub>2) x T&nbsp;'</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">First, we set the preemption code, so that MWORK will know what has happened. If the element's occupant is being set up, it may not be interrupted, but we set the preemption code, so that it will skip its work phase and go directly to its knockdown phase (if there is one) .</span></p>
<p><span class="font45" style="font-weight:bold;">if the occupant is in its work phase, MPREEM sets its remaining processing time in ?X(LTX,6) and schedules it to be reactivated immediately: we have cut off the occupant's service/Now the occupant will again call <sup>M</sup>W0RX, which recognizes it and returns to the next statement in the model/</span></p>
<p><span class="font45" style="font-weight:bold;">•Incorrect multifacility. occupation* ;&nbsp;^ .</span></p>
<p><span class="font45" style="font-weight:bold;">400 RETURN 2&nbsp;'&nbsp;pi'</span></p>
<p><span class="font45" style="font-weight:bold;">END&nbsp;. • ;;</span></p>
<p><span class="font45" style="font-weight:bold;">If there is no plan for this multifacility, or if no element jattl b« found, even though the multifacility isn't fully occupied, then the program return's via the error exit.</span></p>
<p><span class="font45" style="font-weight:bold;">5.3*2 Setup and Knockdown In Case of Preemption</span></p>
<p><span class="font45" style="font-weight:bold;">HSETUP and MKNOCK correspond to SETUP and KHOCKD. We shall describe only MSETUP, since HKHOCK differs from it only slightly.</span></p>
<p><span class="font45" style="font-weight:bold;">5.3.3 MSETUP</span></p>
<p><span class="font47" style="font-weight:bold;">V „ -</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">By .calling MSETUP, the active transaction simulates the time . it spends being set up at a multifacility's service element. MSETUP schedules the transaction to be activated at the end of its setup phase, targeting it to a specified statement number. During its setup phase, the transaction is not preemptible.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL MSETUP (ST,MFA,IDN,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">ST&nbsp;SetuJ&gt; time&nbsp;•</span></p>
<p><span class="font84" style="font-weight:bold;">£ The</span><span class="font45" style="font-weight:bold;"> active transaction requests to be set up for ST time units.</span></p>
<p><span class="font45" style="font-weight:bold;">MFA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The - multifacilities are identified by sequential numbers. I DM&nbsp;Target</span></p>
<p><span class="font45" style="font-weight:bold;">MSETUP targets the transaction to this statement number, where it is to continue its activities at the end of its setup phase. That will normally be a call to MW0RK.</span></p>
<p><span class="font45" style="font-weight:bold;">41005&nbsp;Scheduling exit</span></p>
<p><span class="font45" style="font-weight:bold;">MSETUP deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another «■W transaction.</span></p>
<p><span class="font45" style="font-weight:bold;">41006&nbsp;. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine returns via this exit if a transaction tries to be set up at a multifacility where it doesn't occupy a service element. IPRIHT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRIWT = 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">MSETUP uses the activation list, the TX matrix and the area </span><span class="font45">COrntON/MFA/.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark313"></a>A1 go r it hm ;;d £s c r i p t i o n:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find the transact ion's service element&quot;</span></p>
<p><span class="font45">. II s MBV(MFA)</span></p>
<p><span class="font45">12 r 11 ♦ MFAC(MFA.,2) - 1 DO 100 LSE r II , 12</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IABS(SE(LSE<sub>f</sub>1)).EQ.LTX) GOTO 200 100 CONTINUE RETURN 2</span></p>
<p><span class="font45" style="font-weight:bold;">First MSETUP finds out which service element the transaction occupies. If its search fails, it takes the error exit.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set up the service element*</span></p>
<p><span class="font45" style="font-weight:bold;">200 SÉ(LSE,t)&nbsp;s - LTX</span></p>
<p><span class="font45" style="font-weight:bold;">SE(LSE,3)&nbsp;= 1</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX<sub>t</sub>1)&nbsp;s IDN</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX<sub>f</sub>2)&nbsp;s T ♦ ST RETURN 1 END.</span></p>
<p><span class="font45" style="font-weight:bold;">We mark the&nbsp;multifacility's service element non-interruptible</span></p>
<p><span class="font45" style="font-weight:bold;">and setting up.&nbsp;Then we schedule thg^transaction and return to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">5:4 The Plan: Service-Element Management</span></p>
<p><span class="font45" style="font-weight:bold;">A multifacility needs a procedure that decides which of its service elements is to be acquired and;, during preemptions, which is to be cleared. That procedure is called a plan. When a transaction tries to acquire a service element, the plan-in decides which of the free ones it gets. Similarly, the plan-out decides which element should be cleared for a preempting transaction.</span></p>
<p><span class="font48">5.4.1 PLAN! and PLAWO Purpose:</span></p>
<p><span class="font48">PLAN! and PLAN0 select the plan that</span><span class="font45" style="font-weight:bold;"> decides,</span><span class="font48"> for a given multifacility, which of its elements is to be acquired or freed. GPSS-F provides for up to five different plans of each kind: in and out. Further, GPSS-F has two pre-programmed plans: LFIRST (a plan-in) and PRIOR (a plan-out). The user is free to write additional ones.. We describe only PLANI, since PLANO is similar.</span></p>
<p><span class="font48">Calling sequence:&nbsp;-. ;§</span><span class="font48" style="font-variant:small-caps;">t</span></p>
<p><span class="font48">CALL PLANT. (MFA ,FXIT1)</span></p>
<p><span class="font48">Parameters: '&nbsp;. v</span></p>
<p><span class="font48">MFA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font48">The number of the multifacility whose plan is to be se-. .lected. EXXT1 Plan-error exit</span></p>
<p><span class="font48">If no plan is provided for- the multifacility, or if no service element can be found, even though the multifacility isn't-fully occupied -<sub>9</sub> the program that called PLAHI should return to simulator termination.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font48">PLANI and PLANO use the plan matrix, PLAMA. Each multifacility has a line in the matrix, which specifies that multifacility</span><span class="font47">'s </span><span class="font48">plans. It is defined as follows:</span></p>
<p><span class="font48">INTEGER PLAMA</span></p>
<p><span class="font48">DIMENSION PLAMA( &quot;MFAC1* <sub>f</sub> 2 )</span></p>
<p><span class="font48">Its elements have the following meanings:</span></p>
<p><span class="font48">PLAMA(MFA,1) Plan-in</span></p>
<p><span class="font48">Each plan</span><span class="font45" style="font-weight:bold;font-style:italic;"> is denoted by</span><span class="font48"> a number. The user enters that number in the matrix in section 4 of the chassis, by which means he assigns each multifacility a specified plan-in.</span></p>
<p><span class="font48">PLAMA(MFA<sub>f</sub> 2) Plan-out</span></p>
<p><span class="font48">In the same way, the user assigns each multifacility a plan-out.</span></p>
<p><span class="font48">Algorithm description:&nbsp;-</span></p>
<p><span class="font54">.</span></p>
<p><span class="font48">&quot;Find the plan&quot;&nbsp;.</span></p>
<p><span class="font48">IF(PLA'4A(MFA, D.ME.O) GOTO 100 50 RETURN 1 100 IADDR = PLAMA(MFA,1)</span></p>
<p><span class="font48">GOTO (1,2,3,4,5) V IADDR</span></p>
<p><span class="font48">We find the multifacility's plan in the plan matrix and jump to the appropriate call.</span></p>
<p><span class="font48">&quot;Call the PLANI subroutine&quot;</span></p>
<table border="1">
<tr><td>
<p><span class="font48">1</span></p></td><td>
<p><span class="font48">CALL LFIRST(MFA,450)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;font-style:italic;">'t i:</span></p></td><td>
<p><span class="font48">CALL PLANI2(MFA)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font48">3</span></p></td><td>
<p><span class="font48">CALL PLANI3CMFA)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font48">4</span></p></td><td>
<p><span class="font48">CALL PLANI4(MFA)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font48">5</span></p></td><td>
<p><span class="font48">CALL PLANI5(KFA)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">RETURN</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font48">END</span></p></td></tr>
</table>
<p><span class="font48">The subroutine provides for five different jxlans. The plan-in whose number is 1 is assigned to the pre-programmed plan, LFIRST.</span></p>
<p><span class="font48">Noter •&nbsp;.&nbsp;:</span></p>
<p><span class="font48">* <sup>Ir the use</sup>r writes a plan, he gives it a number and a Fortran</span></p>
<p><span class="font48">name, Theq he enters its number in the appropriate linfcs in the</span></p>
<p><span class="font48">Plan matrix and its name in the appropriate CALL statements in PLANI and PLANO.</span></p>
<p><span class="font45" style="font-weight:bold;">5.4.2 LFIRST</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">LFIRST assigns a multifacility's service elements sequentially, It always begins its search for a free one from the beginning.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL LFIRST (MFA,EXIT1) Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">MFA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The number of the multifacility whose service element is to be acquired is specified. EXIT! Plan-error exit</span></p>
<p><span class="font45" style="font-weight:bold;">If LFIRST cannot find a free service element, even though the multifacility isn't yet fully occupied, the program that called it should exit to simulator termination.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">LFIRST uses the TX matrix and the area COMMON/MFA/. Algorithm description: &quot;Find a free service element&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">11&nbsp;= MBV(MFA)</span></p>
<p><span class="font45" style="font-weight:bold;">12&nbsp;= 11 ♦ MFAC(MFA,2) - 1 DO 100 LSE = 11 , 12 IF(SE(LSE, D.EQ.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">100 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">We find the first free service element.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Error&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">If no service element can be found, the error exit is taken.</span></p>
<p><span class="font45">5.4.3 PRIOR Purpose:</span></p>
<p><span class="font45">During preemptions, an out-plan decides which service element to clear. PRIOR selects the service element whose transaction has the lowest priority. It considers only transactions whose priority is. lower than the preempting transaction's and those which are marked preemptible.</span></p>
<p><span class="font45">Calling sequence:</span></p>
<p><span class="font45">CALL PRIOR(M<sup>p</sup>A)</span></p>
<p><span class="font45">Parameters:</span></p>
<p><span class="font45">MFA&nbsp;Multifacility number (Type number)</span></p>
<p><span class="font45">The number of the multifacility where the preemption is to take place is specified.</span></p>
<p><span class="font45">Data area:</span></p>
<p><span class="font45">PRIOR uses the TX matrix and the area COMMOM/MFA/.</span></p>
<p><span class="font45">Algorithm description:</span></p>
<p><span class="font45">&quot;Initialize the search&quot;</span></p>
<p><span class="font45">LSE = 0</span></p>
<p><span class="font45">PR = TX(LTX,4)</span></p>
<p><span class="font45">11&nbsp;= MBV(MFA)</span></p>
<p><span class="font45" style="font-weight:bold;">12&nbsp;r 11 ♦ MFAC(MFA</span><span class="font38" style="font-weight:bold;font-style:italic;">,2)</span><span class="font45" style="font-weight:bold;"> - 1</span></p>
<p><span class="font45">The search for the lowest-priority transaction runs through precisely that part of the SE matrix belonging to the multifacility whose type number is MFA. The active transaction's priority is set in PR.</span></p>
<p><span class="font45">&quot;Search out the service element&quot; DO 100 I s 11 , 12</span></p>
<p><span class="font45">IF(SE(I,1).LT.0.AMD.SE(I,3).EQ.2) GOTO 100 IF(SE(I,2).E0.1) GOTO 100 LTX1 = IABS(SE(I,1)) IF(TX(LTX1,4).GE.PR) GOTO 100 PR = TX(LTX1,J|) LSE = I 100 CONTINUE RETURN END</span></p>
<p><span class="font45">We seek out the element whose occupant has the lowest priority, counting only those with priorities even lower than the active transaction's. At the end of the search, that element's line number will be in LSE.</span></p>
<p><span class="font48">6 STORAGES</span></p>
<p><span class="font45" style="font-weight:bold;">6.1 The Structure of Storages</span></p>
<p><span class="font45" style="font-weight:bold;">Storages are characterized by their capacities and contents. Transactions acquire and free a specific number of storage spaces; those whose demands cannot yet be met<sub>9</sub> queue up to wait«</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">• The supervisor at a downtown parking garage assigns each car a space. When the garage Is full, arriving cars must wait in line.</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F has addressible and non-addressible storages. In a non-addressible storage, the elements are fully undifferentiated; a space is just a space. It distinguishes itself in no way from any other space, not even by its location in the storage. For such storages, GPSS-F keeps track of nothing more than their total capacity and present vacancy rate. There is no way to acquire a particular space in the storage.</span></p>
<p><span class="font45" style="font-weight:bold;">Addressible storages have elements that are distinguished from one another by their locations, called their addresses, and by their contents. GPSS-F keeps track of both. A transaction can request more than one element in an addressible storage. Procedures called strategies, which may vary from storage to storage, assign the spaces to requesting transactions.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* In a normal engagement at a mov*e theater, each seat is, from the management's point of view, like every other. The theater could be modelled by a non-addressible storage. Tickets are sold until the theater</span><span class="font42" style="font-weight:bold;font-style:italic;"> ir.</span><span class="font45" style="font-weight:bold;"> full and, finding a seat, the buyer fends for himself. For special engagements, the management sells reserved-seat tickets at various prices. The buyer sits in the seat he paid for. Here, the theater would be modelled by an addressible storage, since the sold seats have quite specific locations, which make a difference dear to management's heart. Each seat's location is its address.</span></p>
<p><span class="font45" style="font-weight:bold;">We shall use the terms &quot;storage elements&quot; and &quot;storage spaces&quot; interchangeably. By &quot;storage space&quot;, however, we shall mean one or more storage spaces, taken as a whole.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions waiting to acquire space at a storage wait in the locked state, not in the blocked state (see 2.2.2). The user specifies when they should again try to acquire space. That process is called a start and is occasioned by a call to UNLOCK (see 2.5.3). A3 a result of the start, ACTIV2 activates each transaction at a storage, one after the other, in the order determined by the policy; each tries its luck at getting its required space. When it doesn't get space, it is relocked to wait for the next start.</span></p>
<p><span class="font45" style="font-weight:bold;">It would not suffice, as with other stations, merely to activate the highest-priority in the queue, since lowerpriority transactions may have satisfiable space requirements, even if the first transaction selected doesn't. To put it differently, the wait condition at a storage contains transaction-specific parameters, namely their space requirements. Thus the condition must be tested for each waiting transaction (see 7.2.2).</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction comes to a storage, there are two possible courses of action: either we lock it immediately and place it in the queue, or we can let it try once to get its space. In the one case, the transaction waits for a start before it tries to acquire its space; following the start, it competes with other transactions for the space available. In the other case, the transaction tries once to get into the storage; if there is space enough for it, it acquires that space; otherwise it is locked and placed in the queue to wait on the next start.</span></p>
<p><span class="font45" style="font-weight:bold;">Each storage has a line in the storage matrix (STO matrix), which is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER STO</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION ST0(&quot;ST01&quot;,2)</span></p>
<p><span class="font45" style="font-weight:bold;">The individual elements have the following meanings:</span></p>
<p><span class="font45" style="font-weight:bold;">STO(NST,1) Content</span></p>
<p><span class="font45" style="font-weight:bold;">The total number of occupied spaces is specified for the storage whose number is NST.</span></p>
<p><span class="font45" style="font-weight:bold;">ST0(NST,2) Capacity</span></p>
<p><span class="font45" style="font-weight:bold;">The capacity specifies the total number of spaces in the storage. The number of vacant spaces is the storage's capacity minus its content.</span></p>
<p><span class="font45" style="font-weight:bold;">Unlike the data areas for facilities and multifacilities, the data areas for storages don't show which transactions occupy their elements. That opens the possibility of designing models in which transactions don't occupy the storage at all: instead, they just deposit items, which take up space, or they withdraw items, thereby freeing space.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">• At a hot-dog stand, the transactions are the delivery boy, who delivers cold hot dogs and the customers, who buy hot hot dogs. The delivery boy delivers two thousand dogs three times a day; the customers buy one to five at a shot. The stand could be modelled by a storage. Three times a day, at the right times, a transaction would be generated that &quot;acquires&quot; two thousand &quot;spaces&quot; at the storage; transactions are generated at random that &quot;free&quot; one to five of the &quot;spaces<sup><a name="footnote7"></a><a href="#bookmark314">7</a></sup>*.</span></p>
<p><span class="font45" style="font-weight:bold;">Since the transactions' only purpose is to raise or lower the number of hot dogs at the stand, they are annihilated as soon as they have acquired or freed space. In this model, they would not remain at the storage as the cars in the parking-garage model do.</span></p>
<p><span class="font45" style="font-weight:bold;">6.2 Non-Addressible Storages</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark315"></a>Non-addressible storages have&nbsp;only the S?0 matrix as data</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark316"></a>area. Space in them is acquired or&nbsp;freed by means of the subroutines ENTER and LEAVE.</span></p>
<p><span class="font45" style="font-weight:bold;">6.2.1 ENTER Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine ENTER tests whether there is enough vacant space in a given storage to fill an arriving transaction's demand. If there is<sub>t</sub> it raises the storage's total content by the requested amount and returns to the statement following the call. Since ENTER processes only non-addressible storages, it keeps no account of which spaces the transaction acquired. If there is not space enough to accommodate the arriving transaction's request, it is locked and placed in the queue.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ENTER (NST,NE,ID,LOCK,&amp;1005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Storages are numbered sequentially. The number given specifies from which storage the space is to be acquired. It must specify a non-addressible storage. NE&nbsp;Number of elements requested</span></p>
<p><span class="font45" style="font-weight:bold;">The transaction requests NE spaces. ID&nbsp;ENTER CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction must be locked or blocked, it is given this statement number as target; when it is re-activated, it continues its activity at the statement whose number this is. Normally, that would be the call to ENTER that originally caused the transaction to be locked. LOCK Lock flag</span></p>
<p><span class="font45" style="font-weight:bold;">The lock flag specifies whether the transaction should be locked immediately when it first arrives at the storage, or whether it should try to acquire its space. LOCK = 0 The transaction should try to acquire its space.</span></p>
<p><span class="font45" style="font-weight:bold;">LOCK = 1 The transaction should be locked immediately when it first arrives. &amp;1005 Locking and blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">If there is not space enough for the transaction, it must be locked. Then flow management should regain control, whence statement number 1005 is always be specified here. The exit is also taken when a new arrival should be given a chance to try to get its space: the</span></p>
<p><span class="font45" style="font-weight:bold;">transaction is blocked first (see notes). I PRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT = 0.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark317"></a>Data area:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark318"></a>ENTER uses the activation list, the TX matrix and the STO matrix.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark319"></a>Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark320"></a>&quot;Determine the station number*<sup>9</sup></span></p>
<p><span class="font45" style="font-weight:bold;">K s &quot;EMFAC&quot; ♦ NST</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark321"></a>The station number K is computed from the type number NST.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark322"></a>&quot;Watchdog<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 10 OK S 0</span></p>
<p><span class="font45" style="font-weight:bold;">ENTER recognizes by means of 0K<sub>f</sub> whether a transaction is trying for the very first time to get space, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated. If the transaction is arriving for the first time, it is sent to &quot;First acquisition attempt&quot;,</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test the space request&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(ST0(NST,1)+NE.GT.ST0(NST,2)) GOTO 20</span></p>
<p><span class="font45" style="font-weight:bold;">If the requested space is available, the program proceeds to &quot;Acquire&quot;; otherwise, it jumps to &quot;Lock&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Acquire&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">ST0(NST,1) = ST0(NST,1) ♦ NE</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX,8) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">The acquisition consists of raising the content counter by the number of spaces the transaction acquires. In case the transaction comes from the queue, its lock time is cleared.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;First acquisition attempt&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">10 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">IF(LOCK.GT.O) GOTO 20 AL(LTX,1) = ID AL(LTX,2) = - K TX(LTX,8) = T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction is arriving at a storage for the first time, it can choose to be locked immediately, or to try its luck at getting its required space. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">If LOCK is 0, the transaction is given a chance to acquire its required storage. But first, it competes for that space with any</span></p>
<p><span class="font47">transactions that have Just been started (see notes): it la thrown In among the started transactions, if there are</span><span class="font50" style="font-weight:bold;"> any,</span><span class="font47"> by being blocked (not locked) and placed in the queue.</span></p>
<p><span class="font47">Now, since storages are not directly under transaction manage« ment's supervision, they are always marked free, ACTIV2 finds the station free with at least one blooked transaction waiting; it begins undertaking conditioned activations/ activating the blocked transactions at the station, one after the other, until all of them (which may be just the new arrival) have either acquired space or been relocked. This time, when the new arrival is activated, it is routed to the &quot;Test the space request* section, since it has been in the queue (0Ks1),</span></p>
<p><span class="font47">&quot;Lock&quot;</span></p>
<p><span class="font47">20 AL(LTX, V) * ID</span></p>
<p><span class="font47">AL(LTX,2) * - &quot;KEND&quot; - K IF(TX(LTX,8).FQ.O) TX(LTX,8) s T RETURN 1 END</span></p>
<p><span class="font47">A transaction executes this section when its storage request isn't satisfiable or when it is required to be locked immediately when it first arrives. A lock code is set in its activation-list entry.</span></p>
<p><span class="font47">Notes:</span></p>
<p><span class="font47"><sup>9</sup> Flow management will not, of course, activate locked transactions. Before it can activate them, to let them try to get space, the user must block them by means of a start, i.e. by calling UNLOCK.</span></p>
<p><span class="font47">•&nbsp;There are several ways a transaction can arrive for the first time at a storage where a start has just taken place. The most plausible situations would be in models where each transaction that leaves a storage calls UNLOCK, giving the waiting transactions a chance to acquire the space it has Just freed. Following the start, for example, a transaction barred at a gate (see chapter 7) could be sent to the storage, if the start causes the gate's wait condition to be fulfilled.</span></p>
<p><span class="font47">•&nbsp;When an arriving transaction tries immediately to acquire space, it calls</span><span class="font45" style="font-weight:bold;"> ENTER</span><span class="font47"> twice in a row. The first time, ENTER blocks it and returns control to flow management. Flow management takes no special notice of what has happened, but it fihds (at least) the new arrival blocked at the storage. Since storages are always marked accessible, ACTIV2 activates whichever transaction the storage's policy selects; the transaction is, of course, targeted to call</span><span class="font45" style="font-weight:bold;"> ENTER.</span><span class="font47"> Its first call to ENTKR merely created a situation in which it could be given</span><span class="font48"> a</span><span class="font47"> chance to acquire its space by means of a second call to ENTER.&nbsp;11188</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;ENTER</span><span class="font47"> deals only with</span><span class="font45" style="font-weight:bold;"> non</span><span class="font47">-addrcssiblo storages. The user should take care not to specify the storage number of an address-ible storage in calls to this routine. Non-addressible storages</span></p>
<p><span class="font47">have</span><span class="font45"> no entries under their line numbers in the strategy matrix (see 6.5.1)•</span></p>
<p><span class="font45">• Addressible and non-addressible storages are stations of the same type: they are numbered consecutively without regard to ad-dressibillty; both kinds are jumbled together in the</span><span class="font45" style="font-weight:bold;"> STO</span><span class="font45"> matrix.</span></p>
<p><span class="font45">6.2.2 LEAVE Purpose:</span></p>
<p><span class="font45">LEAVE frees a specified number of spaces at a storage. Since LEAVE deals only with non-addressible storages, it does no bookkeeping on the locations of the freed spaces. If the transaction tries to free more spaces than the total number currently held, a special exit is taken to give the user the opportunity to take any special actions.</span></p>
<p><span class="font45">Calling sequence:</span></p>
<p><span class="font45">CALL LEAVE (NST,NE,EXIT1,IPRINT)</span></p>
<p><span class="font45">Parameters:</span></p>
<p><span class="font45">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45">Storages are numbered sequentially. NST specifies the. storage in which spaces are to be freed; it must specify a non-addressible storage. NE&nbsp;Number of elements to be freed</span></p>
<p><span class="font45">The transaction frees NE spaces. EXIT1 Aborted-freeing exit</span></p>
<p><span class="font45">When a transaction tries to free more space than is currently occupied, this exit is taken. IPRINT Trace flag</span></p>
<p><span class="font45">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45">Data area:</span></p>
<p><span class="font45">LEAVE uses the STO matrix.</span></p>
<p><span class="font45">Algorithm description:</span></p>
<p><span class="font45">&quot;Free*</span></p>
<p><span class="font45">IF(ST0(NST,1).LT.NE) GOTO 10 ST0(NST,1) = ST0(NST,1) - NE RETURN 10 RETURN 1 END</span></p>
<p><span class="font45">When the transaction t^ies to free more space than is currently occupied,</span><span class="font48" style="font-variant:small-caps;"> leave</span><span class="font45"> takes its abort exit. Otherwise, it reduces the content counter by the amount of space to be freed and returns normally; the active transaction remains active and continues its activity with the statement following the call.</span></p>
<p><span class="font45">Notes:</span></p>
<p><span class="font48">* When LEAVE takes its abort exit, the user must decide what to do next. If the model has made a mistake, he should jump to statement 1006 to break off simulation. Certain models could conceivably have built-in aborted freeings, for instance at a storage like the hot-dog stand, where the stand has just sold out or at a store, where the clerk must check the stock to see if he can fill an order. In those cases, the model's design dictates what should happen next: relock the transaction and let it try its freeing request again later, or perhaps forget the freeing request altogether, or whatever.</span></p>
<p><span class="font48">6.3 Strategies</span></p>
<p><span class="font48">Addressible storage is acquired and freed by a multitude of strategies. They depend even more strongly on the problem to be solved than do policies. A bird's-eye view of the simplest ones follows. Strategies that fill up storage are called allocation strategies (a-strategies); those that free it, freeing strategies (f-strategies).</span></p>
<p><span class="font48">Example:&nbsp;.</span></p>
<p><span class="font48">* A mail-order company's warehouse is organized, by means of an a-strategy, to minimize access time to the highest-turnover items.</span></p>
<p><span class="font48">* At a warehouse for highly perishable foods, an f-strategy sees to it that orders are filled with those items closest to their sale-limit dates.</span></p>
<p><span class="font48">Don't confuse policies with strategies. Policies determine in which order started transactions try their luck at getting space. Strategies decide which storage spaces are acquired or freed. Each storage has a policy and two strategies; the former administers its queue, the latter, its space.</span></p>
<p><span class="font48">6.3-1 Storage Acquisition</span></p>
<p><span class="font48">An a-strategy fulfils two tasks: first, it decides whether or not to fill a request for space and, assuming there is space enough, it decides which storage elements to allocate. If there is not space enough to meet its request, a transaction waits in the queue.</span></p>
<p><span class="font48">6.3.2 First-fit</span></p>
<p><span class="font48">First-fit selects the first space it finds large enough to meet the request. The strategy doesn't consider how well the request fits in the free area. As a result, odd-sized holes arise, scattered throughout the storage, which is then said to be fragmented. The strategy's advantage is its low search time.</span></p><img src="Untitled.FR10_files/Untitled.FR10-7.jpg" style="width:93pt;height:15pt;"/>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font52" style="font-variant:small-caps;">v</span></p><div>
<p><span class="font45" style="font-weight:bold;">1*1 Ml</span></p>
<p><span class="font45" style="font-weight:bold;">I «1</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">I I***; I2|2 </span><span class="font68">I 1***1</span></p></div><div>
<p><span class="font44">1***1 </span><span class="font45" style="font-weight:bold;">I 2 | 1***1</span></p></div><div>
<p><span class="font47">I 3 I</span></p></div>
<p><span class="font52" style="font-variant:small-caps;">storage</span></p>
<p><span class="font46"><a name="bookmark323"></a>1***1 |*|#**»«| |</span></p>
<p><span class="font48">I 2 | 2 |1| 3 I 2 I </span><span class="font45" style="font-weight:bold;">l*#*l 1*1*****1 |</span></p><div style="border-left:solid;">
<p><span class="font41">*******</span></p>
<p><span class="font41">*******</span></p>
<table border="1">
<tr><td>
<p></p></td><td>
<p><span class="font10">***</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">2</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">2</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font10">***</span></p></td></tr>
</table></div><div>
<p><span class="font41">*********</span></p></div>
<p><span class="font48">FIGURE 23&nbsp;THE FIRST-FIT STRATEGY</span></p>
<p><span class="font48">Figure 23 depicts a partially filled storage. The starred fields represent occupied areas; the clear fields, free areas. First-fit fills a request for three storage elements from the first area large enough to handle it. In the example shown, it generates a free remainder, 2 spaces long.</span></p>
<p><span class="font48">6.3-3 Best-fit</span></p>
<p><span class="font48">Best-fit is similar to first-fit, except that it doesn't necessarily fill the request from the first free space large enough to handle the request. Instead, it finds the free space where the request fits most snugly.</span></p>
<p><span class="font48">Best-fit's disadvantage is its longer search time; its advantage is better use of the storage. Figure 2M shows the same example as figure 23» except that best-fit allocates the space.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">■ A shipping-company's warehouse is divided into equal-area parcels, each identified numerically. The parcels are the smallest units assigned to a given shipment. On demand, the warehouse manager assigns a contiguous space large enough to accommodate a shipment. Using a first-fit strategy, he would assign the space nearest the warehouse door. Using best-fit, he would assign the space where the shipment fits best.</span></p>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font48"><a name="bookmark324"></a>V</span></p>
<table border="1">
<tr><td>
<p><span class="font48">1***1</span></p></td><td>
<p></p></td><td>
<p><span class="font48">1*1</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font29" style="font-weight:bold;">1</span></p></td><td>
<p></p></td><td rowspan="3">
<p><span class="font24" style="font-weight:bold;">|*.*|</span></p>
<p><span class="font29" style="font-weight:bold;">1 2 | I***!</span></p></td></tr>
<tr><td>
<p><span class="font29" style="font-weight:bold;">1</span><span class="font48"> 2 |</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">2</span></p></td><td>
<p><span class="font48">111</span></p></td><td>
<p><span class="font48">5</span></p></td><td>
<p><span class="font48">1 5 1</span></p></td><td>
<p><span class="font48">3</span></p></td><td>
<p><span class="font48">1 1</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">2</span></p></td></tr>
<tr><td>
<p><span class="font48">1***1</span></p></td><td>
<p></p></td><td>
<p><span class="font48">1*1</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p><span class="font29" style="font-weight:bold;">1</span></p></td><td>
<p></p></td></tr>
<tr><td colspan="2">
<p><span class="font48">STORAGE</span></p></td><td>
<p><span class="font78">4</span></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font29" style="font-weight:bold;">| r** |</span></p></td><td>
<p></p></td><td>
<p><span class="font48">1*1</span></p></td><td>
<p></p></td><td>
<p><span class="font29" style="font-weight:bold;">|««*»***** j</span></p></td><td>
<p><span class="font39">*****</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">1 *******</span></p></td><td>
<p><span class="font48">1</span></p></td><td>
<p></p></td><td rowspan="2">
<p><span class="font29" style="font-weight:bold;">1***1 </span><span class="font48">1</span><span class="font29" style="font-weight:bold;"> 2 |</span></p></td></tr>
<tr><td>
<p><span class="font29" style="font-weight:bold;">1</span><span class="font48"> 2 |</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">2</span></p></td><td>
<p><span class="font48">Ml</span></p></td><td>
<p><span class="font48">5</span></p></td><td>
<p><span class="font48">1 5 1</span></p></td><td>
<p><span class="font48">3</span></p></td><td>
<p><span class="font48">I 4</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">2</span></p></td></tr>
<tr><td>
<p><span class="font29" style="font-weight:bold;">| **« |</span></p></td><td>
<p></p></td><td>
<p><span class="font48">l«l</span></p></td><td>
<p></p></td><td>
<p><span class="font29" style="font-weight:bold;">|********* j</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">*****</span></p></td><td>
<p><span class="font29" style="font-weight:bold;">1 *******</span></p></td><td>
<p><span class="font48">1</span></p></td><td>
<p></p></td><td>
<p><span class="font29" style="font-weight:bold;">|*»*|</span></p></td></tr>
</table>
<p><span class="font45" style="font-weight:bold;">FIGURE 24&nbsp;THE BEST-FIT STRATEGY</span></p>
<p><span class="font48">6.3.4 Conditioned Storage Assignment</span></p>
<p><span class="font48">This class of strategies allocates storage space on the basis of the type of item being stored. For example: as a precaution</span></p>
<p><span class="font48">against fire,&nbsp;a warehouse stores important or expensive items so that they can be removed quickly.</span></p>
<p><span class="font48">6.3.5 Segmenting</span></p>
<p><span class="font48">It is easy to optimize the use of storage, if incoming items need not be stored together, that is if they can be divided up and distributed over free areas of whatever size. Dividing up a block of items is called segmenting. The disadvantage of the method is that it takes a lot of bookkeeping. Figure 25 shows an allocation by a segmenting a-strategy. The request for 8 storage elements is broken up into requests for 2 and 5 elements and a single element.</span></p>
<p><span class="font83" style="font-weight:bold;">6.3.6</span><span class="font48"> Collecting Free Space</span></p>
<p><span class="font48">In strategies without segmenting, the items in a storage may have to be shifted together from time to time, to make room for new requests. The mechanism</span><span class="font43" style="font-style:italic;"> fry</span><span class="font48"> means of which the Items are shoved together is variously called shifting or collecting free space (see figure 26).</span></p>
<p><span class="font85"><a name="bookmark325"></a>I <sub>:</sub> J</span></p>
<p><span class="font69"><a name="bookmark326"></a>I 2 I 5 Ml</span></p>
<p><span class="font77">&quot;&quot;</span><span class="font73" style="font-weight:bold;font-style:italic;">1</span><span class="font77"> I II</span></p>
<p><span class="font22"><a name="bookmark327"></a>| ------- |</span></p>
<p><span class="font11"><a name="bookmark328"></a>----- | |</span></p>
<p><span class="font52" style="font-variant:small-caps;">v&nbsp;v&nbsp;v</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark329"></a>(•••I |.|&nbsp;I •••••»»••!&nbsp;(••«.«••I I»»«I</span></p>
<p><span class="font45" style="font-weight:bold;">I 2 | 2 11 I 5 I 5 I3I t |2|2| !••«( |.| | ........| |***|</span></p>
<p><span class="font45" style="font-weight:bold;">(•••I•{•«**«*»•*( *•**»*•••|*| |***««««| 1***1</span></p>
<p><span class="font45" style="font-weight:bold;">I 2 | 2 |1| 5 I 5 Ml 2 | 4 | 2 | 2 | ,...<sub>t</sub>.,*««...... ......|***|</span></p>
<p><span class="font48">FIGURE 25 SEGMENTING</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark330"></a>I ***I 1*1&nbsp;|••»•»»*»*, || |«*«|</span></p>
<p><span class="font45" style="font-weight:bold;">I 2 | 2 11 | 5 I 5 131 * |2|2| |»| |*««**•**» | |•••«•*•j |«*«|</span></p><div>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font47">V</span></p></div>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font45" style="font-weight:bold;">I&nbsp;|2</span></p><div>
<p><span class="font71">2 |1|</span></p></div><div>
<p><span class="font16" style="font-weight:bold;">12</span></p></div>
<p><span class="font45" style="font-weight:bold;">FIGURE 26 COLLECTING FREE SPACE</span></p>
<p><span class="font45" style="font-weight:bold;">6.3*7 Freeing Space</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction requests that specific items be removed from a storage, no f-strategy need decide which spaces to free. F-strategies are needed only when the request doesn't specify which items to remove.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;At a railway station, a traveller takes her suitcase from the storage locker uniquely identified by her key number. No f-strat-egy is needed.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;A widget manufacturer keeps a large stock, against a sudden run on widgets. When an order arrives, even though it specifies the color, an f-strategy has to decide precisely which widgets to send, or, in other words, which warehouse spaces to free.</span></p>
<p><span class="font45" style="font-weight:bold;">The established names for f-strategies are identical with policies' names. The usage is justified, in that the selection procedures are similar; it is confusing, in that policies and f-strategies pull different objects from different bins. Policies select transactions from queues and strategies select spaces from storages. Since policies' selection procedures have already been explained (chapter 3)» the parallel procedures for strategies are not set out again here.</span></p>
<p><span class="font45" style="font-weight:bold;">6.4 Addressible Storages</span></p>
<p><span class="font45" style="font-weight:bold;">Addressible storages keep track of filled locations and their contents. Each location has a unique, identifying number, called its address. Locations are numbered consecutively, starting with 1, just as in a one-dimensional Fortran array.</span></p>
<p><span class="font45" style="font-weight:bold;">For addressible storages, we shall use the terms &quot;spaces*, &quot;elements&quot; and &quot;locations&quot; interchangeably. We shall also use &quot;location&quot; synonymously with &quot;address&quot;, where no confusion could arise.</span></p>
<p><span class="font45" style="font-weight:bold;">6.4.1 The Structure of Addressible Storages</span></p>
<p><span class="font45" style="font-weight:bold;">The STO matrix suffices to describe non-addressible storages, but addressible storages require tne SM (segment) matrix as well. Every storage location in every addressible storage in the model has a line in the SM matrix, which depicts the storages' contents,&nbsp;- - ; .^^^^HB^B</span></p>
<p><span class="font45" style="font-weight:bold;">In order to administer storages more easily, we group together, all consecutive, free locations or consecutive locations that were allocated simultaneously. Those groups of consecutive locations are called segments. The length of a segment, whether free or occupied, is stored in the SM-matrix line belonging to the first space in the segment.</span></p>
<p><span class="font48">SM MATRIX</span></p><div>
<p><span class="font45" style="font-weight:bold;">I I</span></p>
<p><span class="font48">SECTION &lt; FOR STORAGE | NST s 1&nbsp;j</span></p></div>
<p><span class="font48">SM(1,1) | SH(1,2) |&lt;~ SBV VECTOR</span></p>
<p><span class="font48">---| SBV(1)</span></p><div><img src="Untitled.FR10_files/Untitled.FR10-8.jpg" style="width:132pt;height:276pt;"/></div><div>
<p><span class="font45" style="font-weight:bold;">SECTION FOR STORAGE NST</span></p></div>
<p><span class="font20">&lt;—</span></p>
<p><span class="font45" style="font-weight:bold;">&lt;----1 SBV(&quot;ST01<sup>M</sup>) |</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">SECTION&nbsp;&lt;</span></p>
<p><span class="font45" style="font-weight:bold;">FOR STORAGE | NST = &quot;ST01<sup>H</sup> |</span></p>
<p><span class="font45" style="font-weight:bold;">SM MATRIX AND STORAGE BASIS VECTOR</span></p>
<p><span class="font45">The segment matrix is defined as follows: INTEGER SM</span></p>
<p><span class="font45">DIMENSION SM(&quot;SMI<sup>M</sup>,2)</span></p>
<p><span class="font45">The individual elements have the following meanings:</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 27</span></p></div>
<p><span class="font45">Segment length</span></p>
<p><span class="font45">A segment consists of one or more contiguous locations that are either free or that were allocated together. If line number LSM belongs to the first location in a segment, this element specifies the number of locations in the segment; otherwise, it contains zero.</span></p><div>
<p><span class="font45">SM(LSM,1)</span></p></div>
<p><span class="font45" style="font-weight:bold;">SM(LSM,2) Code</span></p>
<p><span class="font48">Each segment has a code. GPSS-F marks this element for the first location in a free segment with the code, •1. The first location in an occupied segment is marked with any code the user specifies (see 6.4.2).</span></p>
<p><span class="font48">Subroutine INIT3 (see 2.6.4) subdivides the segment matrix into sections, each belonging to a particular storage, and each containing as many lines as the storage has locations. The line number of the first line in each section is stored by INIT3 in the storage basis vector (SBV). The storage basis vector divides the segment matrix into sections as shown in figure 27. It is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER SBV DIMENSION SBV(&quot;ST01&quot;)</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Space in addressible storages is always acquired and freed</span><span class="font48"> in </span><span class="font45" style="font-weight:bold;">segments, i.e. in groups of consecutive locations.</span><span class="font48"> A</span><span class="font45" style="font-weight:bold;"> segment</span><span class="font48"> is </span><span class="font45" style="font-weight:bold;">characterized by its beginning location, its length and its code.</span></p>
<p><span class="font45" style="font-weight:bold;">V Sections of the segment matrix are not to be confused with segments. The segment matrix is divided up into sections, each belonging to a specific, addressible storage. Each section is further subdivided into segments, each representing a free area or an area that was allocated all at one time. The beginning of each section in the segment matrix is noted in the storage basis vector. The beginning of each segment is noted in the segment matrix itself by the segment's length entry, SM(LSM<sub>f</sub>1), all subsequent locations in the segment being marked zero.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;When part of a free segment is allocated, the segment is divided into two: an allocated segment with a user-specified code and a free segment with the standard free code, -1.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Only the first line in a segment is marked with its code and length.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The total number of storage locations available to the user is fixed when the simulator is dimensioned (see appendix</span><span class="font48"> A3).</span><span class="font45" style="font-weight:bold;"> Building a model, the user may assign the available storage locations to individual storages any way he sees fit. He must specify each storage's capacity in section 4 of the chassis by means of a direct entry in the STO matrix (see 2.6.1 and 11.6).</span></p>
<p><span class="font45" style="font-weight:bold;">6.4.2 ALLOC Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">ALLOC tests whether there is enough vacant space in a given storage to fill the calling transact ion's request. If there is, it assigns the space in the form of a segment and returns to the statement following the call. Since ALLOC deals only with ad-dressible storages, ;it keeps account in the segment matrix of which spaces the transaction acquired. The calling transaction is locked and placed In the queue, if there is not space enough to accommodate its request.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ALLOC (NST,NE,MARK,ID,LINE,LOCK,41005,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">The parameters whose descriptions differ essentially from</span></p>
<p><span class="font45" style="font-weight:bold;">those in subroutine ENTER are: MARK, LINE and 41006.</span></p>
<p><span class="font45" style="font-weight:bold;">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Storages are numbered sequentially. NST denotes the storage where the calling transaction requests space. It must specify an addressible storage.</span></p>
<p><span class="font45" style="font-weight:bold;">NE&nbsp;Number of elements requested</span></p>
<p><span class="font45" style="font-weight:bold;">The transaction requests NE spaces.</span></p>
<p><span class="font45" style="font-weight:bold;">MARK Segment code</span></p>
<p><span class="font45" style="font-weight:bold;">All segments receive a positive integer as code when they are allocated; this parameter specifies the code for the segment allocated to the active transaction.</span></p>
<p><span class="font45" style="font-weight:bold;">ID&nbsp;ALLOC CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction must be locked or blocked, it is given this statement number as target; when it is reactivated, it will continue its activity at the statement whose number this is. Normally, that would be the call to ALLOC that originally caused the transaction to be locked.</span></p>
<p><span class="font45" style="font-weight:bold;">LINE Storage address</span></p>
<p><span class="font45" style="font-weight:bold;">In this parameter, ALLOC passes the address of the first location of the segment it assigns back to the caller.</span></p>
<p><span class="font45" style="font-weight:bold;">LOCK Lock flag</span></p>
<p><span class="font45" style="font-weight:bold;">The lock flag specifies whether the transaction should be locked immediately when it first arrives at the storage, or whether it should try to acquire its space. LOCK s 0 The transaction should try to acquire its space.</span></p>
<p><span class="font45" style="font-weight:bold;">LOCK = 1 The transaction should be locked immediately when it first arrives.</span></p>
<p><span class="font45" style="font-weight:bold;">41005&nbsp;Locking exit</span></p>
<p><span class="font45">If there is not space enough for the</span><span class="font45" style="font-weight:bold;"> transaction, it </span><span class="font45">must be locked. Then flow management must</span><span class="font45" style="font-weight:bold;"> receive con</span><span class="font45">trol again, whence statement number</span><span class="font45" style="font-weight:bold;"> 1005 is always spec</span><span class="font45">ified here. The exit is also taken when a</span><span class="font45" style="font-weight:bold;"> new arrival is </span><span class="font45">to be given a chance to get its space: the</span><span class="font45" style="font-weight:bold;"> transaction </span><span class="font45">is blocked first (see notes).</span></p>
<p><span class="font45" style="font-weight:bold;">41006&nbsp;</span><span class="font45">Error exit</span></p>
<p><span class="font45">If</span><span class="font57" style="font-weight:bold;"> NST</span><span class="font45"> specifies a non-addressible storage,</span><span class="font45" style="font-weight:bold;"> subroutine </span><span class="font45">STRATA prints an error message. Then</span><span class="font45" style="font-weight:bold;"> ALLOC takes this </span><span class="font45">exit to termination.</span></p>
<p><span class="font45">1PRINT Trace flag</span></p>
<p><span class="font45">Trace printouts are suppressed when</span><span class="font45" style="font-weight:bold;"> IPRINT ? 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">ALLOC uses the activation list, the TX matrix and the areas COMMON/STO/ and COMMON/SBV/.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark331"></a>Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark332"></a>&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark333"></a>K s &quot;EMFAC&quot; ♦ NST</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark334"></a>The station number K is computed from the type number NST.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark335"></a>&quot;Watchdog&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 50 OK s 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(NE.LE.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">ALLOC recognizes by means of OK, whether a transaction is requesting space for the first time, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated. If the transaction is arriving for the first time, it is sent to &quot;First acquisition attempt&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Storage-space assignment by the strategy&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">CALL STRATA(NST,NE,&amp;70) IF(LSH.EQ.O) GOTO 60</span></p>
<p><span class="font45" style="font-weight:bold;">The strategy responsible for this storage finds a segment to allocate; it is called by means of the call to STRATA (see 6.5.1). The strategy sets the value of the system variable, LSM, which is in the area COMMON/SBV/, with the line number of the first location in the segment it assigns, or zero, if it cannot assign any space.</span></p>
<p><span class="font45" style="font-weight:bold;">If NST specifies a non-addressible storage, STRATA takes an addressed exit to statement &amp;70, the section labelled &quot;Storage error&quot;. If no space could be assigned, the program jumps to &quot;Lock&quot;; otherwise, execution continues with the section below.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the segment matrix&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SM(LSM,1).NE.O) GOTO 30 DO 100 1=1, &quot;SM1&quot; J = LSM - I</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SM(J, U.NE.0) GOTO 20 100 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">20 SM(LSM,1) = SM(J,1) - I SM(J,1) s I</span></p>
<p><span class="font45" style="font-weight:bold;">It is possible for a particular a-strategy to assign a segment from the middle of a free segment, so that free remainders are left both ahead of and behind the allocated segment. Here ALLOC finds the beginning of the free segment from which the assignment was made, which may coincide with the start of the assigned seg-</span></p>
<p><span class="font39" style="font-style:italic;"><a name="bookmark336"></a>men</span><span class="font45" style="font-weight:bold;">t. If there is a residual free one<sub>9</sub> it is marked free*</span></p>
<p><span class="font45" style="font-weight:bold;">30 IF(SM(LSM<sub>f</sub> D.EQ.NE) GOTO U0 J s LSM + ME</span></p>
<p><span class="font45" style="font-weight:bold;">SM(J<sub>9</sub>1) = SM(LSM, 1) - NE SM(J,2) = - 1</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark337"></a>Then the residual free segment marked, assuming there is one.</span></p><div>
<p><span class="font45" style="font-weight:bold;">segment ahead of&quot; the assigned</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">at the end of the assignment is</span></p></div>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark338"></a>40 SM(LSM,1) s NE</span></p>
<p><span class="font45" style="font-weight:bold;">SM(LSM,2) s MARK</span></p>
<p><span class="font45" style="font-weight:bold;">ST0(NST,1) s ST0(NST,1) ♦ NE</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX<sub>f</sub>8) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">LINE s LSM - SBV(NST) ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">ALLOC marks the segment with its length and the user's code. Then it raises the content counter by the number of spaces acquired. In case the transaction comes from the queue, its locking time is cleared. Finally ALLOC sets the LINE parameter to show the starting address of the segment acquired.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;First acquisition attempt&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">50 IF(HE.LE.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">IF(LOCK.GT.O) GOTO 60 AL(LTX<sub>9</sub>1 ) = ID AL(LTX,2) = - К TX(LTX,8) = T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction is arriving at a storage for the first time, it can choose to be locked immediately, or to try its luck at getting its required space. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">If LOCK is 0, the transaction is given a chance to acquire its required storage. But first, it competes for that space with any transactions that have just been started (see notes for subroutine ENTER): it is thrown in among the started transactions, if there are any, by being blocked (not locked) and placed in the queue.</span></p>
<p><span class="font45" style="font-weight:bold;">Now, since storages are not directly under transaction management's supervision, they are always marked free. ACTIV2 thus finds the station free with at least one blocked transaction waiting; it begins undertaking conditioned activations, activating the blocked transactions at the station, one after the other, until all of them (which may be just the new arrival) have either acquired space or been relocked. This time, when the new arrival is activated, it is routed to the &quot;Storage-space assignment&quot; section, since it has been in the queue (0K=1).</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lock&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">60 AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX <sub>f</sub> 2) r - <sup>W</sup>KEND&quot; - K IF(TX(LTX<sub>f</sub>8)•EO.O) TX(LTX<sub>f</sub>8) s T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction executes this section, if its storage request isn't satisfiable, or if it is required to be locked immediately when it first arrives. A lock code is set in its activation-list entry.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Storage error&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">70 RETURN 2 END</span></p>
<p><span class="font45" style="font-weight:bold;">If NST denotes a non-addressible storage, ALLOC takes the error exit, cutting off simulation.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The notes for subroutine ENTER apply, with appropriate modification, to subroutine ALLOC.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Addressible storages are distinguished from non-addressible by having an entry in the STRAMA matrix, which specifies at least an a-strategy for the storage. The user must specify, for each storage, which strategies are responsible for its management (see 2.6.1 and 6.5.1).</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>§</sup> The segment's code, MARK, could be</span><span class="font42" style="font-weight:bold;"> U3ed</span><span class="font45" style="font-weight:bold;"> to give an f-strategy a selection criterion. It could, for example, specify the allocation time or the acquiring transaction's identifying number (from TX(LTX, 1)) or similar information. If the user need not code his entries in the storage, he can specify any value at all for MARK.</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>*</sup>&nbsp;Each occupied segment is uniquely identified by its storage number and its starting address in that storage. It is not uniquely identified by its starting address (LINE) alone, unless there is only one storage.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;If storage locations are always occupied one at a time, all of the segments will be of length 1. This special case is, of course, handled automatically by the algorithm for the more general case.</span></p>
<p><span class="font45">6.4.3 FREE Purpose :</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>p</sup>REE</span><span class="font45"> frees a specified number of spaces from a specified segment in a storage. Since FREE processes only addressible storages, bookkeeping is involved in the operation. If the transaction tries, to free more spaces than are in the segment specified, a special exit is taken to give the user the opportunity to take any special actions.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark339"></a>Calling sequence</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark340"></a>CALL FREE (NST, NB, KEY <sub>9</sub> LIKE, EXIT1, &amp;1006,IPRINT) Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark341"></a>The parameters whose descriptions differ essentially from those of subroutine LEAVE are: KEY<sub>f</sub> LINE and &amp;1006.</span></p>
<p><span class="font45" style="font-weight:bold;">Storage number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Storages are numbered sequentially. NST specifies from which storage the space is to be freed; it must specify an addressible storage. Number or elements to be freed</span></p>
<p><span class="font45" style="font-weight:bold;">The number of storage spaces to be freed is given. Freeing key</span></p>
<p><span class="font45" style="font-weight:bold;">The key specifies from which segment the space is to be freed. It is used differently in storages with and without f-strategies. In storages without, there is no need for a strategy * hat decides which locations to free; KEY specifies the beginning address of the segment in which space is to be freed. The area freed is from KEY to KEY+NE-1. In storages with f-strategies, KEY* means nothing at all to subroutine FREE; it is merely passed along to the f-strategy, which uses it, in any way deemed fit, to find a segment from which FREE frees the first NE locations. Remainder address</span></p>
<p><span class="font45" style="font-weight:bold;">If the segment is longer than NE spaces, FREE divides it into two: the first free and the remainder still occupied. The starting address of the remainder is returned to the caller in LINE. Aborted-freeing exit</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction tries to free more space than the segment identified by KEY contains, this exit is taken. The exit is also taken when the f-strategy (assuming there is one) cannot find a segment identified by the KEY parameter. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">This exit is taken when NST specifies a non-addressible storage. In that case, simulation is terminated. Trace flag*</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT = 0.</span></p><div>
<p><span class="font45" style="font-weight:bold;">NST</span></p>
<p><span class="font45" style="font-weight:bold;">NE KEY</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">LINE</span></p>
<p><span class="font45" style="font-weight:bold;">EXIT1</span></p></div><div>
<p><span class="font69">&amp;1006</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT</span></p></div>
<p><span class="font45" style="font-weight:bold;">Data area:&nbsp;.</span></p>
<p><span class="font45" style="font-weight:bold;">FREE uses the areas C0MM0N/ST0/, COMMON/SBV/ and C0MM0N/STR/</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine LSM&quot;</span></p>
<p><span class="font45">IF(STRAMA(HST,</span><span class="font45" style="font-weight:bold;">1)•EQ.0)</span><span class="font45"> GOTO</span><span class="font45" style="font-weight:bold;"> 50 </span><span class="font45">LStt s KEY ♦ SBV(NST</span><span class="font45" style="font-weight:bold;">) - 1</span></p>
<p><span class="font45">IF(STRAMA(NST,2).NE.O)</span><span class="font45" style="font-weight:bold;"> CALL STRATF(NST,KEY,4 1 ) </span><span class="font45">IF(LSM.EQ.O) GOTO 40</span></p>
<p><span class="font45" style="font-weight:bold;">The variable LSM specifies the starting location of the area to be freed. If the storage has no f-strategy, LSH is computed directly from the value of KEY. If the storage has an f-atrategy (see 6.5.1), FREE calls it. The strategy sets the value of LSM, which is in COHHON/SBV/. If LSH has been set to zero, no area could be found. In this case, or in case the storage is non-ad-dressible, FREE jumps to the addressed-exit section.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Mark remainder&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">LINE x 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SM(LSM, D.LT.NE) GOTO 40 IF(SH(LSM,1).EQ.NE) GOTO 10 J = LSH + NE</span></p>
<p><span class="font45" style="font-weight:bold;">SM(J,1) = SM(LSM,1) - NE SM(J,2) = SM(LSM,2) LINE = J - SBV(NST) ♦ 1 SM(LSM,1) s NE</span></p>
<p><span class="font45" style="font-weight:bold;">If the segment is longer than ME spaces, FREE divides it into two: the first free and the remainder still occupied. The free segment is always built from the first part of the original and the remainder from the last part. The starting address of the remainder is returned to the caller in LINE.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Free the storage area<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">10 SM(LSM,2) = -1</span></p>
<p><span class="font45" style="font-weight:bold;">ST0(NST,1) = ST0(NST,1) - NE</span></p>
<p><span class="font45" style="font-weight:bold;">The freed area is marked free and the total storage content is decremented by the number of freed locations.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lump contiguous free segments into one segment*<sup>1</sup></span></p>
<p><span class="font45" style="font-weight:bold;">J = LSM ♦ SM(LSM,1)</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SM(J,2).NE.-1.0R.J.GE.SBV(NST)+ST0(NST,2)) GOTO 20 SM(LSM,1) r SM(LSM,1) ♦ SM(J,1) SM(J,1) = 0 SM(J,2) = 0 20 IF(LSM.EQ.SBV(NST)) RETURN DO 100 1=1, &quot;SMI&quot; J = LSM - I</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SM(J,1).NE.0) GOTO 30 100 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">30 IF(SM(J,2).NE.-1) RETURN SM(J,1) = SM(LSM,1) ♦ I SM(LSM,1) = 0 SM(LSM,2) = 0 RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">The freeing^ of an area can yield two or even three contiguous free segments, which should be concatenated into one long segment. The algorithm insures that, if they occur, contiguous free segments fore and aft are both swallowed into the new segment.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Special exits<sup>19</sup></span></p>
<p><span class="font45" style="font-weight:bold;">40 BETURN 1 50 BETURN 2 EXD</span></p>
<p><span class="font45" style="font-weight:bold;">The appropriate special exits are taken: EXIT1<sub>f</sub> if the trans* action tried to free more space than is currently occupied; 41006, if the storage is non-addressible.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;For storages without an f-strategy, KEY must specify the beginning address of the segment to be freed. Subroutine ALLOC passed this address back to the user in the LINE parameter, when it allocated the space.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;An f-strategy could use KEY to identify the segment from which space is to be freed. It could, for example, take the first segment where KEY matches the segment code set by ALLOC's MARK parameter.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;«hen only part of a segment is to be freed, FREE always frees the first part; it is incapable of freeing a chunk from the middle of a segment. If such freeings are needed in a particular model, the user must write the program for them himself.</span></p>
<p><span class="font0" style="font-style:italic;">u</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>11</sup> The note for subroutine LEAVE (see 6.2.2) concerning the abort exit applies here too.</span></p>
<p><span class="font45" style="font-weight:bold;">6.5 GPSS-F Strategies</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS—F knows both addressible and non-addressible storages. Only the former need strategies, since no account is kept for the latter of filled locations. Addressible storages need at least an a-strategy and in addition<sub>9</sub> an f-strategy, if freeing requests do not specify locations unambiguously (see 6.3*7).</span></p>
<p><span class="font45" style="font-weight:bold;">Each addressible storage must be assigned an allocation strategy and, if need be, a freeing strategy. Since strategies are especially problem-dependent, the user has the opportunity to write his own. These can be added easily to GPSS-F. Two pre-written allocation strategies are provided: first-fit and best-fit.</span></p>
<p><span class="font45" style="font-weight:bold;">6.5-1 STRATA and STRATF Purpose :</span></p>
<p><span class="font57" style="font-weight:bold;">STRATA</span><span class="font45" style="font-weight:bold;"> and STRATF select the strategy</span><span class="font48"> that decides, for a giv</span><span class="font45" style="font-weight:bold;">en storage, which locations are</span><span class="font48"> to</span><span class="font45" style="font-weight:bold;"> be</span><span class="font48"> acquired or freed. GPSS-F </span><span class="font45" style="font-weight:bold;">provides for up to five different a</span><span class="font48">-strategies and f-strategies. </span><span class="font45" style="font-weight:bold;">Furthermore, two allocation strategies are</span><span class="font48"> already pre-program-</span><span class="font45" style="font-weight:bold;">med:</span><span class="font57" style="font-weight:bold;"> r FIT</span><span class="font45" style="font-weight:bold;"> (first-fit) and BFIT (best-fit).</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark342"></a>In the following documentation, only STRATA la</span><span class="font47"> described* </span><span class="font45" style="font-weight:bold;">STRATF is similar.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark343"></a>Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL STRATA (NST,NE,EXIT1)</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark344"></a>Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The number of the storage whose strategy is to be selected•</span></p>
<p><span class="font45" style="font-weight:bold;">NE&nbsp;Number of locations requested</span></p>
<p><span class="font45" style="font-weight:bold;">The number of storage locations being requested is specified. EXIT1 Strategy-error exit</span></p>
<p><span class="font45" style="font-weight:bold;">If no strategy is provided for this storage, then STRATA returns via this exit to the calling program, which should, in turn exit to simulator termination.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">STRATA and STRATF use the strategy matrix, STRAMA. Each storage, whether addressible or not, has a line in this matrix, which may specify an a-strategy and, if need be, an f-strategy for that storage. If there is neither an a-strategy nor and f-strategy for the storage numbered NST, it is non-addressible; if there is only an a-strategy<sub>f</sub> it is addressible, but freeing requests are always specified unambiguously. The STRAMA matrix is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER STRAMA DIMENSION STRAMA(&quot;ST01&quot;,2)</span></p>
<p><span class="font45" style="font-weight:bold;">The individual elements have the following meanings:</span></p>
<p><span class="font45" style="font-weight:bold;">STRAMA(NST,1) A-strategy</span></p>
<p><span class="font45" style="font-weight:bold;">Each strategy is denoted by a number. The user enters that number in the matrix in section 4 of the chassis. In this manner, he assigns each addressible storage a specific a-strategy.</span></p>
<p><span class="font45" style="font-weight:bold;">STRAMA(NST,2) F-strategy</span></p>
<p><span class="font45" style="font-weight:bold;">In the same way, the user assigns an f-strategy to each storage that needs it.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find the strategy&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">Ir(STRAMA(NST,1&quot;)</span><span class="font45"> . NE</span><span class="font45" style="font-weight:bold;"> • 0 ) GOTO 100 RETURN 1 100 IADDR = STRAMA(NST,1)</span></p>
<p><span class="font45" style="font-weight:bold;">GOTO (1,2,3,4,5) • IADDR</span></p>
<p><span class="font45" style="font-weight:bold;">The storage's strategy is found in the strategy matrix and the appropriate call is jumped to.</span></p>
<table border="1">
<tr><td>
<p><span class="font45" style="font-weight:bold;">•Call</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">the STRAA subroutine</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">1</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">CALL FFIT(MST.NE)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">2</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">CALL BFIT(NST.NE)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">3</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">CALL STRAA3(NST,NE)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font27">|</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">CALL STRAA4(NST,NE)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">5</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">CALL STRAA5(NST,NE)</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p></td></tr>
<tr><td>
<p></p></td><td>
<p><span class="font45" style="font-weight:bold;">END</span></p></td></tr>
</table>
<p><span class="font45" style="font-weight:bold;">The subroutine provides for five different strategies. The a-strategies whose numbers are 1 and 2 are already assigned to the pre-programmed strategies, FFIT and B^IT.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">• If the user writes a strategy, he gives it a number and a Fortran name. Then he enters its number in the appropriate lines in the strategy matrix and its name in the appropriate CALL statements in STRATA and STRATF.</span></p>
<p><span class="font45" style="font-weight:bold;">6.5.2 FFIT Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine searches free space according to the first-fit strategy.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL FFIT (NST,NE)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">The storage number is used to find the section of the segment matrix belonging to the storage. NE&nbsp;Number of elements to be acquired</span></p>
<p><span class="font45" style="font-weight:bold;">The first free segment that can accomodate a request for NE locations is found.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">FFIT uses the areas COMMON/SBV/ and COMMON/STO/. Algorithm description: &quot;Initialize the search&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">LSM r 0 I s SBV(NST)</span></p>
<p><span class="font45" style="font-weight:bold;">IB « I ♦ STO(NST,2) - 1</span></p>
<p><span class="font45" style="font-weight:bold;">The program searches only that section of the segment matrix belonging to the storage numbered NST.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find a segment&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">10 IF(SM(I,2).NE.-1 ) GOTO 20 IF(SM(I,1).GE.NE) GOTO 30 20 I s I ♦ SH(I,1)</span></p>
<p><span class="font45" style="font-weight:bold;">IF(I.LE.TE) GOTO 10 RETURN 30 LSM = I RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">Among the segments marked free (—1), we find the first that Is at least NE locations long. The system variable, LSM, is set to the beginning address of this segment, or zero, if there is none.</span></p>
<p><span class="font45">6.5.3 BFIT Purpose:</span></p>
<p><span class="font45">This subroutine searches free space according to the best-fit strategy.</span></p>
<p><span class="font45">Calling sequence:</span></p>
<p><span class="font45">CALL BFIT (NST,NE)</span></p>
<p><span class="font45">Parameters:</span></p>
<p><span class="font45">NST&nbsp;Storage number (Type number)</span></p>
<p><span class="font45">The storage number is used to find the section of the segment matrix belonging to the storage. NE&nbsp;Number of elements to be acquired</span></p>
<p><span class="font45">The free segment is found that can best accomodate a request for NE locations.</span></p>
<p><span class="font45">Data area:</span></p>
<p><span class="font45">BFIT uses the areas C0MM0N/SBV/ and C0MM0N/ST0/. </span><span class="font45" style="font-weight:bold;">1 &quot; ' &gt; \ ,&quot; . ■</span></p>
<p><span class="font45">Algorithm description: •'Initialize the search&quot;</span></p>
<p><span class="font67" style="font-weight:bold;">1</span></p>
<p><span class="font45" style="font-weight:bold;">LSM = 0</span></p>
<p><span class="font45" style="font-weight:bold;">D r ST0(NST,2)</span></p>
<p><span class="font45" style="font-weight:bold;">I r SBV(NST)</span></p>
<p><span class="font45" style="font-weight:bold;">IE s I + ST0(NST,2) - 1</span></p>
<p><span class="font45">, The program searches only that section of the segment matrix belonging to the storage numbered NST.</span></p><img src="Untitled.FR10_files/Untitled.FR10-9.jpg" style="width:118pt;height:131pt;"/>
<p><span class="font45" style="font-weight:bold;">&quot;Find a segment&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">10 IF(SM(I,2).NE.-1) GOTO 20 1F(SM(I,1).LT.NE) GOTO 20 IF(SM(I, U-NE.GE.D) GOTO 20 D * SM(I,1) - NE LSM s I 20 I s I ♦ SM(I,1)</span></p>
<p><span class="font45" style="font-weight:bold;">IF(I.LE.IE) GOTO 10</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">Among the segments marked free (-1), all those are found that are at least NE locations long. Then, among those, the one is found whose allocation would leave the least remainder, D. The system variable, LSM, is set to the beginning address of this segment, or zero, if there is none.</span></p>
<p><span class="font47" style="font-weight:bold;">COORDINATING</span></p><div>
<p><span class="font76" style="font-weight:bold;">7</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">TRANSACTIONS</span></p></div>
<p><span class="font45" style="font-weight:bold;">The two mechanisms 'Branch on Condition' and 'Wait on Condition' suffice to coordinate the movement of tasks through a discrete system. One speaks of 'branching on condition', at points where a task can be sent through one of various processing paths, depending on the system's state. 'Waiting on condition' means that tasks are held at some point, until the system's state changes to meet specific conditions.</span></p>
<p><span class="font45" style="font-weight:bold;">In GPSS-F, tasks can branch or wait at any point in the model. The user specifies the condition under which branching or waiting occurs by means of a logical expression.</span></p>
<p><span class="font45" style="font-weight:bold;">7.1 Branching on Condition</span></p>
<p><span class="font45" style="font-weight:bold;">We shall distinguish two kinds of branching: the first, deterministic, by reason of the system state; the second, stochastic, by reason of a random variable.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;In a pariticular model, if there are already ten transactions waiting at a station, no more are accepted into the queue. The rerouting of transactions is deterministic and occurs only when the system fulfils specific criteria. Each arriving transaction can test the criteria to see whether they are fulfilled; the answer determines its subsequent path through the model.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;In an assembly line, eight from every thousand items are found defective and sent back for repairs. The rerouting occurs stochastically. The probability that an item will be sent to the repair station is 0.008.</span></p>
<p><span class="font45" style="font-weight:bold;">7.1.1 Deterministic Branching</span></p>
<p><span class="font45" style="font-weight:bold;">No subroutine is needed to effect a branch by reason of the system state. Such branching is easily implemented using a Fortran logical IF statement. The statement has the following form:</span></p>
<p><span class="font45" style="font-weight:bold;">IF(logexp) command,</span></p>
<p><span class="font45" style="font-weight:bold;">where 'logexp' is a logical expression and 'command' is a Fortran command, such as ' a GOTO. If the logical expression's value is .TRUE., the command is executed. To implement a deterministic branch, the user would code a logical IF statement whose expression tests the system state and whose command jumps to the part of the program to be executed when the state obtains.</span></p>
<p><span class="font48">7.1.2 Stochastic Branching: TRANSF Purpose:</span></p>
<p><span class="font48">From among the transactions that call subroutine TRANSF,</span><span class="font45" style="font-weight:bold;"> some are</span><span class="font48"> picked at random to be sent to a specified statement in</span><span class="font45" style="font-weight:bold;"> the </span><span class="font48">model. The remainder continue their activity with the statement following the call to TRANSF.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL</span><span class="font45" style="font-weight:bold;"> TRANSF (RATIO,EXIT1,RNUM,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">RATIO Selection probability</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter specifies the probability with which transactions are sent to the statement number given by the parameter EXIT1. RATIO must be a real number between 0 and 1.</span></p>
<p><span class="font45" style="font-weight:bold;">EXIT1 Exit for the selected transactions</span></p>
<p><span class="font45" style="font-weight:bold;">The selected transactions continue their^activity at this statement number.</span></p>
<p><span class="font45" style="font-weight:bold;">RNUM Random number generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter specifies which random number generator shall be used to decide whether the transaction is to be selected (see chapter 9).</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">TRANSF requires only the random number generated by the random number generator RNUM.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description :</span></p>
<p><span class="font45">Z = RN(RNUM)</span></p>
<p><span class="font45">IF(Z.LE.RATIO.AND.RATIO.GT.O) GOTO 100 RETURN 100 RETURN 1 END</span></p>
<p><span class="font45">The function, RN (see 9.4.1), generates a random number between 0 and 1, which is set in the variable Z. If Z is less than RATIO, the transaction is selected, i.e. the addressed exit is taken. Otherwise, TRANSF returns to the statement following the call.</span></p>
<p><span class="font45">7.2 Waiting on Condition</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F</span><span class="font45"> provides stations, called gates, at which transactions wait until the system is in a specified state. The state that determines whether transactions are to wait at the gate is described in a logical expression. We shall say that the expression</span></p>
<p><span class="font45" style="font-weight:bold;">represents the gate's wait condition: when the condition obtains, a transaction can proceed; otherwise, it must wait. A gate is said to be op^n or closed, according as it lets a transaction pass or not.</span></p>
<p><span class="font45" style="font-weight:bold;">From time to time, a waiting transaction tries the gate again to see if it is now open. If the expression's value has become .TRUE., it proceeds; otherwise it waits and tries again later.</span></p><div>
<p><span class="font45">; they do not have ac-ion leaves the sta-the expression to see</span></p></div>
<p><span class="font45" style="font-weight:bold;">7.2.1 Trying the Gate</span></p>
<p><span class="font45" style="font-weight:bold;">There are two procedures for deciding when waiting transactions shall try the gate again: either the user supervises the gates by specifying when they should be retried, or flow management supervises their retrial automatically. Gates subject to the user's supervision are of type 1; those supervised by flow management are of type 2.</span></p>
<p><span class="font45" style="font-weight:bold;">Waiting transactions should retry their gates each time the system's state changes in some way that could affect the value of the gate's expression. The points in the model at which it makes sense to let waiting transactions retry a gate are usually made clear by the model's design. If so, the user can supervise the gate himself: each time the system's state changes in any way relevant to the gate, he can call for it to be retried. Here, he would use a type-1 gate.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions waiting at a type-1 gate wait normally in the locked state, not in the blocked state (see 2.2.2). Locked transactions do not have access to their gates; they must be placed in the blocked state by means of a call to UNLOCK (see 2.5.3) before flow management can activate them to try the gate. The user calls for a gate's retrial by such a call to UNLOCK, called a start, specifying the gate he wants retried. The transactions locked at the gate are thereby blocked.</span></p>
<p><span class="font45" style="font-weight:bold;">As a result of the start, the blocked transactions are activated, one after the other, in the order determined by the gate's policy. Each tries the gate in its turn. Transactions for which the gate is closed are relocked and placed back in the queue to wait for the next start.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45">* In a certain model, some transactions arrive at a facility via one path and others via a second. That would occur when they all acquire the facility using the same CALL SEIZE statement, but arrive at the CALL from different parts of the program. In our model, transactions arriving via the second path are to be held at a type-1 gate, unless the station's queue is empty.</span></p>
<p><span class="font45">In GPSS-F, the contents of queues can be tested by use of the BIN matrix (see 10.1), so our gate's logical expression would be:</span></p>
<p><span class="font45">BIN(NBN,1).EQ.O</span></p>
<p><span class="font45">Normally, waiting transactions are locked cess to the gate. But each time a transact tion's queue, it makes sense to re-evaluate </span><span class="font45" style="font-weight:bold;">whether Its value has changed. That Is accomplished by means of</span><span class="font47"> a </span><span class="font45" style="font-weight:bold;">start: locked transactions are given access to the gate by being blocked. Flow management vill then activate a blocked transaction which tries the gate.</span></p>
<p><span class="font4">%</span></p>
<p><span class="font45" style="font-weight:bold;">The user can supervise his gates in most situations, especially where only a small number of system changes can affect the value of the gate's expression. But if a gate's expression is complex, state changes abound that could alter its value to .TRUE.. It may be easier or more comfortable, under the circumstances, to let GPSS-F supervise the gate. Here, a type-2 gate would be used.</span></p>
<p><span class="font45" style="font-weight:bold;">When GPSS-F supervises a gate, it is tried nearly every time flow management receives control: ACTIV2 lets a waiting transaction try the gate each time it is called, assuming some state change has taken place since the last time it was called. Transactions waiting at a type-2 gate always wait in the blocked state. The gate is sometimes accessible to blocked transactions, sometimes not: ACTIV2 switches its state back and forth by juggling its entry in the state vector (see 3.4).</span></p>
<p><span class="font45" style="font-weight:bold;">7.2.2 Local and Global Parameters</span></p>
<p><span class="font45" style="font-weight:bold;">The system's state is given by the values of its parameters, private and relational. A gate's expression will contain variables referring to one or more parameters, so that its value, .TRUE, or .FALSE., depends on the current parameter values.</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters pertaining to the transaction trying the gate shall be called local; those not pertaining to it, global. Obviously, given a particular systea state, an expression that tests only global parameters will have the same value, no matter which transaction tries the gate, and an expression that tests any local parameter could have different values for different transactions trying the gate. Global parameters are those pertaining to other transactions or to stations or to the relation between any two or more system components, excluding the transaction trying the gate.</span></p>
<p><span class="font48">At a gate whose logical expression tests any local parameter, each waiting transaction should try the gate each time the relevant parameters change. The gate could be open to some transactions and closed to others.</span></p>
<p><span class="font48">The situation is different at gates whose logical expression contains only global parameters. When a transaction finds the gate closed, it makes no sense to let other waiting transactions try it until the relevant parameters have changed. For a given system state, if such a gate is closed to one, it will be closed to all. If the gate is open, though, waiting transactions can try it, one after the other, until they are all gone, or until the gate closes.</span></p>
<p><span class="font48">Examples :</span></p>
<p><span class="font48">* When the gate is down at a railroad crossing, arriving cars must wait. In a GPSS-F model, the gate's logical expression would</span></p>
<p><span class="font45" style="font-weight:bold;">be the Fortran equivalent of: there is no train.^ The expression tests one global parameter, the train's approach or presence at the crossing. If the gate is down, it bars all waiting cars from proceeding; if it is up<sub>9</sub> waiting cars can proceed, one by one, until they are all gone, or until the gate recloses.</span></p>
<p><span class="font45" style="font-weight:bold;">* Transactions arriving at a storage must wait until there is room for then (see chapter 6). If we think of the storage as a gate, its logical expression would be: there is room enough to accomodate the requesting transaction. The expression's value depends on two parameters, namely the transaction's request for space (a local parameter) and the availability of so much space in the storage (a global parameter). Thus each waiting transaction must try the gate each time storage space is freed, since the expression could be true for some transactions, but not for others. At * a storage, the loading strategy takes the place of a logical expression.</span></p>
<p><span class="font45" style="font-weight:bold;">7.3 Gates</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F provides both types of gates. To try a type-1 gate, the active transaction calls GATE1; to try a type-2 gate, GATE2.</span></p>
<p><span class="font45" style="font-weight:bold;">7.3.1 GATE1 </span><span class="font48">Purpose:</span></p>
<p><span class="font48">When a transaction calls GATE1, the subroutine evaluates a specified logical expression. If its value is .FALSE., the transaction is locked and placed in the gate's queue; GATE1 returns to flow management. If the expression's value is .TRUE., the transaction remains active and GATE1 returns to the statement following the call.</span></p>
<p><span class="font48">For arriving transactions, the user can specify whether the gate is accessible for an initial trial. If so, the arriving transaction tries the gate immediately; otherwise, it is locked and placed in the queue. The gate is under initiated supervision, i.e. waiting transactions gain access to it each time the user calls UNLOCK for this gate.</span></p>
<p><span class="font48">For waiting transactions, the user can specify whether the gate's expression depends on local parameters. If so, each waiting transaction is given a chance to to try the gate, regardless whether the gate is open or closed to the others. Otherwise, waiting transactions try the gate until one of them finds it closed; then the remaining transactions are relocked to wait for the next start.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL GATE1 (</span><span class="font45">LOGEXP,GLOBAL,NGATE,ID,LOCK,h 1005,1PRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">LOGEXP Wait condition</span></p>
<p><span class="font45" style="font-weight:bold;">The logical expression is evaluated. If its value is .TRUE., the active transaction remains active and GATE1 returns to the statement following the call: the gate is open. If the expression's value is .FALSE., the transaction is locked.</span></p>
<p><span class="font45" style="font-weight:bold;">GLOBAL Parameter code</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter specifies whether all waiting transactions should try the gate, one by one, or only until one of them finds the gate closed.</span></p>
<p><span class="font45" style="font-weight:bold;">GLOBAL = 0 The logical expression contains local parameters. Every waiting transaction should try the gate.</span></p>
<p><span class="font45" style="font-weight:bold;">GLOBAL s 1 The logical expression contains only global parameters.</span></p>
<p><span class="font45" style="font-weight:bold;">NGATE Type-1 gate number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Type-1 gates are numbered sequentially.</span></p>
<p><span class="font45" style="font-weight:bold;">ID&nbsp;GATE1 CALL'S statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction must be locked or blocked, it is given this statement number as target; when it is re-activated to try the gate again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATE1 that originally caused the transaction to be locked.</span></p>
<p><span class="font45" style="font-weight:bold;">LOCK Lock flag</span></p>
<p><span class="font45" style="font-weight:bold;">The lock flag specifies whether the transaction should be locked immediately when it first arrives at the gate or whether it should try the gate. LOCK s 0 The transaction should try the gate. LOCK = 1 The transaction should be locked immediately when it first arrives.</span></p>
<p><span class="font45" style="font-weight:bold;">&amp;1005 Locking and blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction is locked or blocked, flow management must be called; hence statement number 1005 should always be specified here.</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">GATE1 uses the activation list and the TX matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot; K s &quot;ESTO&quot; ♦ NGATE The station number K is computed from the type number NGATE.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Watchdog&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 10 </span><span class="font31">OK</span><span class="font43"> S</span><span class="font31"> o</span></p>
<p><span class="font45" style="font-weight:bold;">queue to be activated. If the transaction is arriving for the first time<sub>9</sub> it is sent to &quot;Mew arrival&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Locking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(.NOT.LOGEXP) GOTO 20</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX<sub>t</sub>8) s 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction isn't a new arrival, and if the expression's value is .TRUE., the transaction is to be allowed to pass.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;New arrival&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">10 IF(LOCK.GT.O) GOTO 30 AL(LTX,1) s ID AL(LTX,2) * - K TX(LTX,8) s T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">A new arrival can choose to be locked immediately, or to try the gate. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock the active transaction&quot;.</span></p>
<p><span class="font45" style="font-weight:bold;">If LOCK is 0, the transaction is given a chance to try the gate. But first, it competes with any transactions that have just been started (see notes): it is thrown in among the started transactions, if there are any, by being blocked (not locked) and placed in the queue. Then GATE1 returns control to flow management .</span></p>
<p><span class="font45" style="font-weight:bold;">Now, since gates are not directly under transaction management's supervision, they are always marked accessible in the STATE vector. ACTIV2 thus finds the station accessible with at least one blocked transaction waiting. It undertakes a conditioned activation, activating one of the transactions blocked at the station, which may include only the new arrival. This time, the new arrival executes the &quot;Locking decision&quot; section, since it has been in the queue (0Ks1).</span></p>
<p><span class="font66">4ft</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test the parameter code&quot; 20 IF(GLOBAL.GT.O) GOTO 40</span></p>
<p><span class="font45" style="font-weight:bold;">The user initiates the testing of a gate by starting the locked transactions waiting there. ACTIV2 finds them blocked at the gate and activates the one selected by the gate's policy. The activated transaction's target is the CALL GATE1 statement, which evaluates the logical expression to decide whether the transaction should pass or not.</span></p>
<p><span class="font45" style="font-weight:bold;">Now if the expression's value depends only on global parameters, and if the gate is closed, then all of the started transactions are to be relocked immediately in the section &quot;Lock all started transactions&quot;. If, however, the expression's value depends on local parameters, just the one transaction Is relocked In the following section*</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lock the active transaction&quot;</span></p>
<p><span class="font4">%</span></p>
<p><span class="font39" style="font-style:italic;">30</span><span class="font45" style="font-weight:bold;"> AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) s - &quot;KEND&quot; - K IF(TX(LTX,8).EQ.O) TX(LTX,8) s T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction is locked by giving it a lock code, -&quot;KEND&quot;-K.</span></p>
<p><span class="font45" style="font-weight:bold;">It can try the gate again only by being started.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lock all started transactions&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">40 AL(LTX,1) s ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) = - &quot;KEND&quot; -</span><span class="font39" style="font-style:italic;"> K </span><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).EQ.O) TX(LTX,8) s T DO 100 I s 1 <sub>f</sub> LAL</span></p>
<p><span class="font45" style="font-weight:bold;">IF(AL(I,2).EQ.-K) AL(I,2) r - &quot;KEND&quot; - K</span></p>
<p><span class="font45" style="font-weight:bold;">100 CONTINUE RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">This section is executed when the transaction must be relocked and when the value of the gate's expression depends only on global parameters. When that is the case, the above loop relocks all other started transactions as well. The initiated trial of the gate is over.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;If GLOBAL r 1, type-1 gates behave exactly like type-2 gates, except that they are under the user's supervision: locked transactions must be started by calling UNLOCK. Started transactions try the gate one by one until one of them finds it closed. Then any remaining blocked transactions are relocked to wait for the next start.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;When the user calls UNLOCK, he must specify the gate's station number. He can calculate the station number from the type number, NGATE, by considering the state vector's construction (see appendix A2).</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>9</sup> Storages behave like type-1 gates with GLOBAL = 0, whose logical expression is: space is available to fill a given request. In this sense, there is a close parallelism between subroutines ALLOC and GATE1.</span></p>
<p><span class="font45" style="font-weight:bold;">When a newly arriving transaction is to be permitted to try the gate, it usually calls GATE1 twice in a row. The first time, it is blocked and GATE1 returns control to flow management. Flow management takes no special notice of what has happened, but it finds (at least) the new arrival blocked at the gate. Since gates are always accessible to blocked transactions, the transaction selected by the gate's policy is activated and calls GATE1. The</span></p>
<p><span class="font45" style="font-weight:bold;">first call to GATB1 merely creates a situation in which the new arrival is given a chance to try the gate by means of</span><span class="font47" style="font-weight:bold;"> a</span><span class="font45" style="font-weight:bold;"> second call to GATE1.</span></p>
<p><span class="font45" style="font-weight:bold;">The new arrival doesn't get its chance to try the gate If GLOBAL s 1 and the policy selects a blocked transaction ahead of it that happens to close the gate.</span></p>
<p><span class="font45" style="font-weight:bold;">7.3.2 GATE2</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction calls GATE2<sub>t</sub> the subroutine evaluates a specified logical expression. If its value is .FALSE., the transaction is locked; GATE2 returns control to flow management. If the expression's value is .TRUE., the transaction remains active and GATE2 returns to the statement following the call.</span></p>
<p><span class="font45" style="font-weight:bold;">The gate is under automatic supervision, i.e. waiting transactions try the gate each time ACTIV2 receives control. Waiting transactions try the gate one by one until one of them fails to pass; then the gate is inaccessible again until the next time ACTIV2 receives control.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL GATE2 (LOGEXP,NGATE,ID,&amp;1005<sub>f</sub>IPRINT) Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Wait condition</span></p>
<p><span class="font45" style="font-weight:bold;">The logical expression is evaluated. If its value is .TRUE., the active transaction remains active and GATE2 returns to the statement following the call: the transaction has been allowed to pass. If the expression's value is .FALSE.<sub>t</sub> the transaction is blocked. Type-2 gate number (Type number) Type-2 gates are numbered sequentially. GATE2 CALL's statement number</span></p><div>
<p><span class="font45" style="font-weight:bold;">LOGEXP</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">NGATE ID</span></p></div>
<p><span class="font45" style="font-weight:bold;">If a transaction must be blocked</span></p>
<p><span class="font45" style="font-weight:bold;">is given this statement number as target; when it is re-activated to try the gate again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATE2 that originally caused the transaction to be blocked. Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction is blocked, flow management must called; hence statement number 1005 should always specified here. Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p><div>
<p><span class="font45" style="font-weight:bold;">it</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">41005</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">be be</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">IPRINT</span></p></div>
<p><span class="font45" style="font-weight:bold;">Data area</span></p>
<p><span class="font45" style="font-weight:bold;">CATE2 uses the activation list and the TX matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">К « &quot;EGATE&quot; ♦ NGATE&nbsp;<sup>%</sup></span></p>
<p><span class="font45" style="font-weight:bold;">The station number К is computed from the type number NGATE.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(OK.EQ.O) GOTO 250 OK * 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(.NOT.LOGEXP) GOTO 200 100 TX(LTX,8) s 0 IT = 0 RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">GATE2 recognizes by means of OK, whether a transaction is just now trying the gate for the first time, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated.</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction is arriving for the first time,_it is always blocked immediately, before it tries the gate. If the transaction isn't a new arrival, and if the expression's value is •TRUE., the transaction is to be allowed to pass.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Mark the gate inaccessible&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">200 STATE(K) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">The gate, which ACTIV2 marked inaccessible (see notes and </span><span class="font82" style="font-weight:bold;">2.3.3),</span><span class="font45" style="font-weight:bold;"> is made accessible again, as soon as it has been tried and found closed. Note that this statement is not executed when the gate is open.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">250 AL(LTX,1) r ID AL(LTX,2) =1- К</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).EQ.0) TX(LTX,8) = T</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction finds the gate closed, it is blocked in the section above. The block time should be set only when the transaction is a new arrival, i.e. when it doesn't yet have a block time. If it was selected from the queue to try the gate, it will already have a block time, which it keeps.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;GATE2 uses the same two-pass algorithm for newly arriving transactions already described in the notes to subroutine GATE1.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Each type-2 gate has an element in the state vector, where it is marked accessible or inaccessible to blocked transactions. If</span></p>
<p><span class="font45" style="font-weight:bold;">it Is inaccessible, the following holds: STATE(&quot;EGATE1&quot;*NGATE) s 0</span></p>
<p><span class="font45" style="font-weight:bold;">Each time a transaction undertakes state changes and returns control to flow management, ACTIV2 marks the gates accessible in the loop:</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I s &quot;BGATE2&quot; , &quot;EGATE2<sup>M </sup>100 STATE(I) s 1</span></p>
<p><span class="font45" style="font-weight:bold;">Then a transaction is activated to try each type-2 gate. If the transaction finds that the gate's expression comes out .TRUE., it remains active, undertakes further state changes and the gate remains accessible. Then another transaction waiting at the gate (if there is one) is activated and the procedure continues. The first transaction that cannot pass, because the expression's value now comes out .FALSE., marks the gate inaccessible to the rest by zeroing its state-vector element.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;This behaviour means that GATE2's algorithm takes no notice of the expression's dependence on local and global parameters: there is no provision for letting all waiting transactions try the gate, regardless of the success or failure of previous trials.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Facilities exhibit behaviour in some respects similar to type-2 gates. A call to SEIZE is analogous to a call to GATE2 with the logical expression: the facility is available.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The type-2 gates are tried each and every time an activated transaction completes its activity and returns control to flow management. Since they are tried so often, their use can be extremely time-consuming. This is the reason why they don't provide for a distinction between expressions depending on local and global parameters. Type-2 gate's should be used as sparingly as possible.</span></p>
<p><span class="font45" style="font-weight:bold;">7.3-3 The IT Mechanism</span></p>
<p><span class="font45" style="font-weight:bold;">If, after the system's state has changed, a waiting transaction tries a type-2 gate and finds it closed, it is reblocked. Then flow management regains control and marks all the type-2 gates accessible again. The transaction that just finished trying the gate could now be the first transaction selected for a conditioned activation, even though no state change has occurred in the meantime. The transaction would again call GATE2 and GPSS-F would go into an endless loop, were it not for the IT mechanism.</span></p>
<p><span class="font45" style="font-weight:bold;">The system's variable, IT, prevents trial of the type-2 gates twice at the same clock time, if no state change has taken place since the last trial. The variable is initially zero. Bach time ACTIV2 marks the type-2 gates available, it sets the time, T, in IT. Then by means of the statement:</span></p>
<p><span class="font45" style="font-weight:bold;">IF(IT.EQ.T) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark345"></a>ACTIV2 jumps around its gate-trial loop, If IT * T. Each time a subroutine changes the system state, It sets 17 » 0<sub>f</sub> so the gates can be tried again.</span></p>
<p><span class="font45" style="font-weight:bold;">7*4 Cather Stations</span></p>
<p><span class="font45" style="font-weight:bold;">By the use of gates, completely general wait conditions can be programmed into a model. There are, however, certain kinds of gates that are often used to build models, whose functions and logical expressions are fixed. GPSS-F offers three specialized gates: gather stations, user chains and trigger stations.</span></p>
<p><span class="font45" style="font-weight:bold;">7.4.1 Coordinating Transactions in one Processing Path</span></p>
<p><span class="font45" style="font-weight:bold;">The coordination task that occurs most frequently in one processing path in a model consists of letting transactions collect at a station until some specified number have arrived and then letting them proceed.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;In a medieval castle, the kindly old lady politely refuses to conduct tours until at least ten tourists are assembled. The first nine tourists have to wait until there is a tenth.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;A firm's mail department doesn't distribute the mail until some quantity has arrived. Only then is the clerk sent around to deliver it.</span></p>
<p><span class="font45" style="font-weight:bold;">Stations that collect transactions before letting them proceed are called gather stations. They are of two types, depending on whether they pay attention to the transactions' family membership (see chapter 8) or not. In this chapter, we shall only consider those that don't. They are said to be of type 2 and are handled by subroutine GATHR2.</span></p>
<p><span class="font45" style="font-weight:bold;">7.4.2 GATHR2 Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions calling subroutine GATHR2 are locked until a certain number, specified by the user, have arrived. When that has happened, the gather station is opened and the transactions proceed, one by one, until they are all gone. GATHR2 pays no attention to the transactions' family membership.</span><span class="font45"> GPSS-F</span><span class="font45" style="font-weight:bold;"> supervises the gather station.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence :</span></p>
<p><span class="font45" style="font-weight:bold;">CALL GATHR2 (NG,NGATH,</span><span class="font45">ID,&amp; 1005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NG&nbsp;Number of transactions to collect</span></p>
<p><span class="font45" style="font-weight:bold;">The number of transactions to be gathered is specified. NGATH Type-2 gather station number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Type-2 gather stations are numbered sequentially. ID&nbsp;GATHR2 CALL<sup>#</sup>s statement number</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;If a transaction must be blocked, it is given this</span></p>
<p><span class="font45" style="font-weight:bold;">statement number as target; when it is re-activated to try the gather station again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATHR2 that originally caused the transaction to be locked. &amp;1005 Locking exit</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction, is locked, flow management must be called; hence statement number 1005 should always be specified here. IPRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">GATHR2 uses the actuation list, the TX matrix and the state vector. Further, GATHR? needs a counter that specifies, for each gather station, how many transactions have already arrived. It is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER GATHT DIMENSION GATHT(&quot;GATHT1<sup>11</sup> )</span></p>
<p><span class="font45" style="font-weight:bold;">Each gather station has an element in the vector corresponding to its type number, NGATH.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description :</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Clear the blocking time&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).EQ.O) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX,8) s 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">When the process of letting gathered transactions past the station has begun, each of them tries the gather station. Here, GATHR2 recognizes such transactions by the presence of a block time, which it zeroes, and lets them pass. If a transaction has no block time, it is a new arrival and must be locked.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 K</span><span class="font43" style="font-style:italic;"> s</span><span class="font45" style="font-weight:bold;"> &quot;EGATHF&quot; £ NGATH</span></p>
<p><span class="font45" style="font-weight:bold;">The station number, K, is computed from NGATH.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Lock*&nbsp;H</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,1) = ID</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,2) r - &quot;KEND&quot; - K TX(LTX,8) s T</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark346"></a>CATHT(NGATH) s GATHT(NGATH) ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark347"></a>New arrivals at the gather station are alwayft locked. At the sane time, the count of locked transactions is incremented.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark348"></a>&quot;Test the count&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark349"></a>IF(GATHT(NGATH).LT.NG) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark350"></a>If the new arrival raised the count of gathered transactions to the limit, the subroutine continues to &quot;Start the gathered transactions&quot;. Otherwise, it returns to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark296"></a>&quot;Start the gathered transactions&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">CALL UNL0CK(K,IPRINT) GATHT(NGATH) = 0 RETURN 1 200 CONTINUE RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">When the desired number of transactions has been gathered, they are started by calling UNLOCK. ACTIV2 activates them, one after the other, in the order determined by the station's policy, to try the gather station. Since they all now have block times, they will all find the gather station open.</span></p>
<p><span class="font45" style="font-weight:bold;">7.5 User Chains and Trigger Stations</span></p>
<p><span class="font45" style="font-weight:bold;">By the use of user chains and trigger stations, it is possible to gather transactions in one processing path, and to free them from a parallel processing path.</span></p>
<p><span class="font45" style="font-weight:bold;">7.5.1 Coordinating Transactions in Parallel Paths</span></p>
<p><span class="font45" style="font-weight:bold;">Arriving transactions are gathered at a user chain. Transactions arriving at. a trigger station can, on demand, open the user chain to let a specified number of waiting transactions past. The trigger station is also opened to the triggering transaction.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* Town-bound passengers wait for a cab at the airport's taxi stand. Each arriving cab picks up some number of passengers. If there are no passengers, the cabs wait. After each trip into town, a cab returns to the stand (see figure 28).</span></p>
<p><span class="font45" style="font-weight:bold;">PASSENGERS</span></p>
<p><span class="font28">---------r</span><span class="font45" style="font-weight:bold;">~HM I—</span></p>
<p><span class="font64" style="font-weight:bold;">----------ft |</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">V</span></p>
<p><span class="font45" style="font-weight:bold;">Ï * &quot;l I USER CHAIN |</span></p>
<p><span class="font45" style="font-weight:bold;">I&nbsp;I</span></p>
<p><span class="font76" style="font-weight:bold;">J</span></p>
<p><span class="font45" style="font-weight:bold;">PROCESSING PATH 1</span></p>
<p><span class="font45" style="font-weight:bold;">CABS</span></p>
<p><span class="font45" style="font-weight:bold;">— I Itll &lt;-----</span></p>
<p><span class="font45" style="font-weight:bold;">I ft----------</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font49"><a name="bookmark351"></a>v</span></p>
<p><span class="font65"><a name="bookmark352"></a>ï Ï </span><span class="font45" style="font-weight:bold;">| TRIGGER&nbsp;|</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark353"></a>j STATION&nbsp;j</span></p>
<p><span class="font28">r</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark101"></a>PROCESSING PATH 2</span></p>
<p><span class="font45" style="font-weight:bold;">USE OF USER CHAINS AND TRIGGER STATIONS TO SIMULATE A TAXI STAND</span></p>
<p><span class="font45" style="font-weight:bold;">User chains are each paired with a specific trigger station. Each pair has adjoining elements in the state vector. A user chain's state-vector element shows it inaccessible when transactions are being gathered to be activated by a trigger station. Its trigger station has the next element in the state vector. It shows the trigger station inaccessible when a transaction is waiting there for a specified number of transactions to be gathered at the user chain. Each user chain has, in addition, an element in the UCHT matrix, which is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER UCHT</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION UCHT(<sup>l,</sup>UCHT1<sup>lf</sup> ,2)</span></p>
<p><span class="font45" style="font-weight:bold;">The individual elements have the following meanings:</span></p><div>
<p><span class="font45" style="font-weight:bold;">UCHT(NUCHN,1)</span></p></div>
<p><span class="font45" style="font-weight:bold;">Number of transactions gathered</span></p>
<p><span class="font45" style="font-weight:bold;">The number of transactions already gathered at the user chain is specified. A transaction arriving at a trigger station can check to see whether its requisite number of transactions is already there.</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 28</span></p></div>
<p><span class="font45" style="font-weight:bold;">Number of transactions When a trigger station transactions activated one. GPSS-F needs a cou along It is in the act many transactions are 1 chain. The counter is station (UNLIN2) and de transaction let past until it reaches zero.</span></p><div>
<p><span class="font45" style="font-weight:bold;">UCHT(NUCHN,2)</span></p></div>
<p><span class="font45" style="font-weight:bold;">already activated wants a certain number of , they are activated one by nter that tells it how far ivation procedure, i.e. how eft to be let past the user initialized by the trigger cremented by one for each by the user chain (LINK2),</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark354"></a>7.5.2 LINK2</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark355"></a>Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction that calls LINK2 is blocked <sup>%</sup>and placed in the user chain's queue. At the same time, LINK2 occasions a check to see whether the trigger station's requisite number of transactions has arrived. If so, a transaction-removal procedure begins.</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction removal begins when LINK2 marks the user chain accessible. Plow management begins activating blocked transactions, which then call LINK2 again. LINK2 recognizes them and lets them pass, one by one, until the desired number has been let through. Then the user chain is marked inaccessible again.</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F supervises the user chains automatically. This program pays no attention to a transaction's family membership.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL LINK2 (NUCHN,ID,41005,IPRINT) -</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NUCHN Type-2 user chain number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Type-2 user chains are numbered sequentially. Thte number is the same as the number of the trigger station that belongs to this user chain.-ID&nbsp;LINK2 CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions activated by a trigger station are to try the user chain again where there wait; they execute the CALL LINK2 statement bearing the number here specified. 41005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">When an arriving transaction is blocked, flow management must receive control again. IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT = 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">LINK2 uses the activation list, the TX matrix, the state vector and the UCHT matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">K s &quot;EUCHF&quot; ♦ 2 « NUCHN - 1</span></p>
<p><span class="font45" style="font-weight:bold;">The station number, K, is computed from NUCHN. The station number of the corresponding trigger station will be K+1.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).NE.O) GOTO 100 UCHT(NUCHN,1) = UCHT</span><span class="font57" style="font-weight:bold;">(NUCHN<sub>t</span><span class="font45" style="font-weight:bold;"></sub>1</span><span class="font57" style="font-weight:bold;">) *</span><span class="font45" style="font-weight:bold;"> 1 IF(UCHT(NUCHN,2).GT.0) GOTO 50 STATE(K) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">50 ALCLTX,1) s ID AL(LTX,2) * - K TX(LTX<sub>f</sub>8) s T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">Here, LINK2 recognizes, by the presence of a block time, the transactions being removed. If the calling transaction has a block time, it jumps to &quot;Remove&quot;. If a transaction has no block time, it is a new arrival and must be blocked. At the same time, the count of waiting transactions is incremented by one.</span></p>
<p><span class="font45" style="font-weight:bold;">Since there is now one more transaction at the user chain, a transaction waiting at the trigger station should be activated to try its station again; the requisite number of user-chain transactions may now be available. The user chain's trigger station is therefore marked accessible. In case the user chain is still accessible from the last removal procedure, it is marked inaccessible.&nbsp;<sub>#</sub>&nbsp;'</span></p>
<p><span class="font45" style="font-weight:bold;">Neither the user chain's nor the trigger station's present state may be disturbed, if a removal procedure is in progress. That is the case when UCHN(NUCHN,2) is non-zero. In that case, the new arrival just quietly takes its place among the waiting.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Remove&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 UCHT(NUCHN,1) = UCHT(NUCHN,1) - 1 UCHT(NUCHN,2) = UCHT(NUCHN,2) - 1 IF(UCHT(NUCHN,1).EQ.O) UCHT(NUCHN,2) s 0&nbsp;»</span></p>
<p><span class="font45" style="font-weight:bold;">IF(UCHT(NUCHN,2).GT.O) GOTO 150 STATE(K) = 0&nbsp;/</span></p>
<p><span class="font45" style="font-weight:bold;">STATE(K+1) = 1 150 TX(LTX,8) s 0 RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">This section is reached only by transactions being let past the user chain in a removal. The removal counters are decremented. (The removal counter has been set initially by UNLIN2 to show the maximum number of transactions it wants.) If there simply are no more transactions to remove, the removal counter is zeroed. The triggering transaction is assured of removing the minimum number of transactions it requires, since the removal procedure doesn't even begin until there are at least that many. Transactions arriving during a removal will be taken too, if the maximum hasn't been reached before they arrive.</span></p>
<p><span class="font45" style="font-weight:bold;">If the removal is over (UCHT(NUCHN,2)=0), the user chain is marked inaccessible. The trigger station is, however, made accessible again, since transactions could have arrived during the removal and still be left over. The next transaction to try the trigger station could perhaps remove them.</span></p>
<p><span class="font45" style="font-weight:bold;">The block time is cleared for all transactions being allowed to pass.</span></p>
<p><span class="font45" style="font-weight:bold;">T-5,3 UHLIH2</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark356"></a>Purpose:</span></p>
<p><span class="font2">%</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction calls UNLIN2, the subroutine checks the </span><span class="font84" style="font-weight:bold;">number</span><span class="font45" style="font-weight:bold;"> of transactions waiting at the associated user chain. If it is at least as large as the minimum number thç calling transaction wants, a removal procedure is initiated.If, on the other hand, there are fewer transactions at the user chain than the requisite minimum, the transaction is blocked. New arrivals are also blocked, if there is already another transaction waiting at the trigger station. Each time another transaction arrives at the user chain, the trigger station is made accessible for trial again.</span></p>
<p><span class="font45" style="font-weight:bold;">UNLIN2 pays no attention to a transaction's family membership. GPSS-F supervises the trigger stations.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL UNLIN2 (NUCHN,NUMIN,NUMAX,ID,&amp;1005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NUCHN Type-2 user chain number</span></p>
<p><span class="font45" style="font-weight:bold;">The trigger station's number is the same as that of its user chain. NUCHN gives the user chain's line in the UCHT matrix. NUHIN Minimum request</span></p>
<p><span class="font45" style="font-weight:bold;">A removal can be initiated when there are at least so many transactions waiting at the user chain. NUMAX Maximum request</span></p>
<p><span class="font45" style="font-weight:bold;">A removal will allow no more than so many transactions to pass the user chain. ID&nbsp;UNLIN2 CALL<sup>#</sup>s statement number</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions waiting at a trigger station are waiting for a certain number of transactions to have gathered at the user chain. Each time one arrives there, the trigger station is made accessible again to its waiting transactions. When they are activated, they execute the CALL UNLIN2 statement bearing this number. 41005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction whose requisite number of transactions has not yet been gathered at the user chain is blocked. Then flow management must receive control again. IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">UNLIN2 uses the activation list, the TX matrix, the state vector and the UCHT matrix.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark357"></a>Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark358"></a>&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark359"></a>K * &quot;EUCHF&quot; ♦ 2 • NUCHN - 1</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark360"></a>The user chain's station number, K, is computed from NUCHN. The trigger station's station number is K+1,</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark361"></a>&quot;Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark362"></a>IF(UCHT(NUCHN, 1) .GE.NUMIN.AND.STATE(K+1).EQ. 1) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark363"></a>If the trigger station has been made accessible, and if the calling transaction's minimum request is available at the user chain<sub>9</sub> the program jumps to &quot;Start a removal procedure&quot;. Otherwise, the calling transaction is blocked in the next section.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark364"></a>&quot;Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">STATE(K+1) s 0 AL(LTX,1) s ID AL(LTX,2) s - (K + 1) IF(TX(LTX,8).EQ.O) TX(LTX,8) = T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">The trigger station is only marked accessible by LINK2. That happens when a new transaction arrives at the user chain, or at the end of the removal procedure. Here, the trigger station is marked inaccessible as soon as it has been tried. The calling transaction is blocked to wait for LINK2 to mark its trigger station accessible again. Its block code is -(K+1).</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Start a removal procedure&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 UCHT(NUCHN,2) = NUMAX STATE(K+1) = 0 STATE(JC) = 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(UCHT(NUCHN<sub>f</sub>1).EQ.O) UCHT(NUCHN,2) s 0</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX,8) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font48">At start of the removal,</span><span class="font45" style="font-weight:bold;"> UNLIN2</span><span class="font48"> sets the removal count</span><span class="font45" style="font-weight:bold;"> to the </span><span class="font48">maximum number of transactions it wants to remove, regardless whether there are that many available or not. Subroutine</span><span class="font45" style="font-weight:bold;"> LINK2 </span><span class="font45">decrements</span><span class="font48"> the counter until the request is satisfied, or its </span><span class="font45">supply of</span><span class="font48"> transactions is depleted.</span></p>
<p><span class="font45">Mo new</span><span class="font48"> arrival at the trigger station is allowed to disturb a </span><span class="font45">removal</span><span class="font48"> procedure until it is over: The trigger station is marked </span><span class="font45">inaccessible,</span><span class="font48"> for the time being. At the end of the removal, LINK 2 will mark it accessible again. The user chain must now be marked accessible, in order to initiate the removal.</span></p>
<p><span class="font48">The triggering transaction's block time is cleared and it is allowed to proceed on its way.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font47" style="font-weight:bold;">•&nbsp;A</span><span class="font45" style="font-weight:bold;"> newly arriving transaction is always blocked, if there</span><span class="font47" style="font-weight:bold;"> is </span><span class="font45" style="font-weight:bold;">another waiting, even if it requests fewer*transactions from the user chain than the waiting transaction. If need be, the user can alter this behaviour.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;In terms of accessibility for trial, a trigger station behaves like a type-2 gate: waiting transactions try it one by one, until one of them finds it closed; then it is made inaccessible for further trial. It will be made accessible again the next time a transaction arrives at the user chain.</span></p>
<p><span class="font55" style="font-weight:bold;">8</span><span class="font45" style="font-weight:bold;"> FAMILIES</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark365"></a>Some simulations require that several transactions belong together. They shall be said to form a family.</span></p>
<p><span class="font45" style="font-weight:bold;">8.1 Kindred Tasks</span></p>
<p><span class="font45" style="font-weight:bold;">Family members are distinct from one another, but they carry extra codes or names that mark as being akin to one another.</span><span class="font50" style="font-weight:bold;"> A </span><span class="font45" style="font-weight:bold;">transaction's duplicate number is its first name; its family number, which takes the place of an ordinary transaction number, is its last namfe. Families are useful whenever different groups of transactions travelling the same path must be processed differently.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* Two high-school classes spend the afternoon in the Smithsonian's Museum of Technology. The students are for the most part on their own, except that they are to gather, by class, at the start of the printing exhibit at 2:00 and at the collection of musical instruments at 4:00.</span></p>
<p><span class="font45" style="font-weight:bold;">8.2 Data Areas for Families</span></p>
<p><span class="font45" style="font-weight:bold;">A parent transaction begets offspring by calling SPLIT, which generates the requested number of new transact ions, using the parent's transaction number as family number. Duplicate numbers are assigned sequentially and entered in the progeny's TX(LTX,2) field. Each family member can, in turn, beget more kinsmen.</span></p>
<p><span class="font45" style="font-weight:bold;">The parameters that characterize a family are kept in the FAM matrix, which is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER FAM</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION FAM(*FAM1<sup>H</sup>,3)</span></p>
<p><span class="font45" style="font-weight:bold;">The FAM matrix has as many lines as the TX matrix, because in the worst case,</span><span class="font44" style="font-style:italic;"> every</span><span class="font45" style="font-weight:bold;"> transaction could be a family unto itself.</span></p>
<p><span class="font45" style="font-weight:bold;">When the active transaction happens to be a family member, the variable LFAM is set to point to its line in the FAM matrix. The individual elements of the matrix have the following meanings:</span></p>
<p><span class="font45" style="font-weight:bold;">FA<sup>M</sup>(LFA!t, 1) Family number</span></p>
<p><span class="font45" style="font-weight:bold;">All family members have the same family number, assigned to them at birth by subroutine SPLIT. A parent's transaction number becomes it3 family number. If this field is zero, the line in the FAM- matrix is free.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark366"></a>Number of present kinsmen</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark367"></a>The number of family members in the system is given. The count is raised or lowered when new members are generated or old are annihilated.</span></p>
<p><span class="font45" style="font-weight:bold;">Last duplicate number</span></p>
<p><span class="font45" style="font-weight:bold;">The next duplicate number assigned will be one larg~ er than the number stored here.</span></p><div>
<p><span class="font45" style="font-weight:bold;">PAM(LFAM,2)</span></p>
<p><span class="font45" style="font-weight:bold;">FAH(LFAM,3)</span></p></div>
<p><span class="font45" style="font-weight:bold;">8.3 The Birth and Death of Kinsmen</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions are split into family members or reassembled into single transactions again by running through splitting and assembling stations. A transaction begets offspring by calling SPLIT, which splits it into some specified number of family members. By calling ASSEMB, family members can reassemble themselves into one entity.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Aircraft engines are dismounted from time to time for a major overhaul. After being dismantled, the parts are adjusted, inspected and reassembled, one stage at a time, with reliability tests at each stage.</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>#</sup>&nbsp;A job in a multi-tasking computing system splits into two concurrently active tasks with equal priority. ~he operating system treats both as equals, except that they must pull themselves together again before terminating. If not, the computer's operating system terminates the job abnormally.</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions that aren't family members run through assembly stations untoutched: transactions that were never disassembled using subroutine SPLIT can never be assembled using ASSEMB. Many real-world assembly procedures assemble components that were never disassembled from a single entity; families are not especially well-suited to simulate them. But procedures that assemble transactions that aren't kinsmen can be modelled easily using programming techniques like those in ASSEMB.</span></p>
<p><span class="font45" style="font-weight:bold;">8.3-1 SPLIT Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction that calls SPLIT begets a specified number of offspring. The parent remains active and SPLIT returns to the statement following the call; the offspring are all scheduled to be activated at the current clock time. If the parent is not a family member, a family is established by setting up a line for it in the FAM matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SPLIT (NDUP,DUPADD,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NDUP Number of duplicates</span></p>
<p><span class="font45" style="font-weight:bold;">The number of offspring Is given. DUPID Target statement number for offspring</span></p>
<p><span class="font45" style="font-weight:bold;">The offspring are all scheduled to be activated immediately and given this statement number as target. 41006 List-overrun exit</span></p>
<p><span class="font45" style="font-weight:bold;">This exit is taken when either the family or the transaction matrix is full and no new entry can be made. It is recommended to break off the simulation. IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SPLIT uses the activation list, the TX matrix and the FAM matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description: &quot;Test&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(NDUP.EQ.O) RETURN IF(LFAM.NE.O) GOTO 300</span></p>
<p><span class="font45" style="font-weight:bold;">If no offspring are to be generated, SPLIT returns on the spot. If the parent is not a family member, a family must be founded. Otherwise, the family merely grows.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Found a family&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 LFAM = 1 , &quot;FAM1&quot; IF(FAM(LFAM,1).EQ.0) GOTO 200 100 CONTINUE RETURN 1 200 FAM(LFAM,1) = TX(LTX,1) FAM(LFAM,2) z 1 FAfKLFAM, 3) = 1 TX(LTX,2) = 1</span></p>
<p><span class="font45" style="font-weight:bold;">A free line is found for the family in the FAM matrix and the number is set in LFAM. If no line can be found, the list-overrun exit is taken. At the moment, the family consists of nothing more than the parent. This state of affairs is noted in the second and third elements of the family's FAM-matrix entry. The parent is assigned the duplicate number 1.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Beget&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">300 DO 3^0 1 = 1, NDUP</span></p>
<p><span class="font45" style="font-weight:bold;">FAM(LFAM,2) = FAM(LFAM,2) ♦ 1 FAM(LFAM, 3) • FAfKLFAM,3) ♦ 1 DO 310 IA = 1 , &quot;TX1&quot; IF(TX(IA,1).EQ.0) GOTO 320 310 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN 1 320 LTXD x IA</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTXD,1) * TX(LTX,1) TX(LTXD,2) s FAM(LFAM,3) TX(LTXD,3) * T DO 330 JC * 4 , »TX2&quot; </span><span class="font39" style="font-style:italic;">330</span><span class="font45" style="font-weight:bold;"> 7X(LTXD,JC) s TX(LTX,JC)</span></p>
<p><span class="font45" style="font-weight:bold;">This section finds and fills in lines in the TX matrix for the newly begotten transactions. Each time through the outer loop<sub>9 </sub>the family's counters are Incremented.</span></p>
<p><span class="font45" style="font-weight:bold;">The inner loop looks for a free line in the TX matrix. When It finds one, it keeps the line number in LTXD; if it finds none, it returns via the overrun exit. The parameters of the father are visited upon the son, not counting first name and birth time.</span></p>
<p><span class="font45" style="font-weight:bold;">IF(LTXD.GT.LAL) LAL r LTXD AL(LTXD,1) s DUPADD AL(LTXD,2) = T 340 . CONTINUE RETURN END</span></p>
<p><span class="font3">•</span></p>
<p><span class="font45" style="font-weight:bold;">Each new transaction is scheduled to be activated at the present clock time, with the specified statement number as target. If need be, the activation-list list-end pointer, LAL, is reset.</span></p>
<p><span class="font45" style="font-weight:bold;">8.3.2 ASSEMB Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Family members that call ASSEMB specify an assembly station where they are to be fused into one transaction. If the specified station is not already assembling members of the caller's family, an assembly is begun: the station notes how many members from this family are to be fused together.</span></p>
<p><span class="font45" style="font-weight:bold;">Once an assembly is in progress, kinsmen arriving at the station are annihilated one by one, until the desired number is reached, except that the last arrival remains alive and active. It travels on to serve as the newly assembled unit.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ASSEMB (NUMASS,NASSEM,41005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NUMASS Assembly station number (Type number).</span></p>
<p><span class="font45" style="font-weight:bold;">Assembly stations are numbered sequentially. NASSEM Number of transactions to be assembled</span></p>
<p><span class="font45" style="font-weight:bold;">The number of family members to be fused together is specified. 41005 Annihilation exit</span></p>
<p><span class="font45" style="font-weight:bold;">This exit is taken each time a family member is annihilated; the subroutine must return to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">ASSEMB uses the FAM and TX matrices. It needs a further data area, the ASM matrix, to keep track of assemblies in progress. Here it counts down the number of kinsmen to go, until the as« sembly is complete. Each station can assemble members concurrently from different families. Hence the ASM matrix is defined as fo 11 o ws:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER ASM</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION ASft(<sup>W</sup>FAM1 * ,*ASM1<sup>n</sup>)</span></p>
<p><span class="font45" style="font-weight:bold;">Each station has as many elements in its column as there are families and each family has as many elements in its line as there are assembly stations.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test for family membership&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(LFAM.EO.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">ASSEMB ignores transactions that don't belong to any family.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Initiate an assembly&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(ASM(LFAM,NUMASS).EQ.0) ASM(LFAM,NUMASS) = NASSEM</span></p>
<p><span class="font45" style="font-weight:bold;">If the&nbsp;assembly count for the caller's family and specified</span></p>
<p><span class="font45" style="font-weight:bold;">station is&nbsp;zero, an assembly is begun by setting the count to NASSEM.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Decrement&nbsp;the count&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">ASM(LFAM,NUMASS) = ASM(LFAM,NUMASS) - 1</span></p>
<p><span class="font45" style="font-weight:bold;">Each arriving kinsman decrements the count of transactions to be fused together.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Fuse&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(ASM(LFAM,NUMASS).GT.O) GOTO 200 IF(FAM(LFAM,2).GT.1) GOTO 150 RETURN 150 CONTINUE RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">When the assembly count reaches zero, the transaction is not annihilated. Instead, it remains active and ASSEMB returns to the statement following the call.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark368"></a>* Annihilate<sup>19</sup></span></p>
<p><span class="font39" style="font-style:italic;"><a name="bookmark369"></a>200</span><span class="font45" style="font-weight:bold;"> CALL TERMIN(4250 ,1PRINT) 250 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark370"></a>All arrivals except the last are annihilated. ASSEMB returns to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">8.4 Coordinating Family Members</span></p>
<p><span class="font45" style="font-weight:bold;">Type-2 gather stations, user chains and trigger stations are used to coordinate transactions without regard to family membership. GPSS-F provides type-1 stations that perform the same tasks, except that family members are gathered together.</span></p>
<p><span class="font45" style="font-weight:bold;">8.4.1&nbsp;Gather Stations for Families</span></p>
<p><span class="font45" style="font-weight:bold;">The new gather stations behave like the simple ones (see 7.4), with the proviso that:</span></p>
<p><span class="font27">.</span></p>
<p><span class="font45" style="font-weight:bold;">a)&nbsp;transactions that aren't family members run through the station without being gathered at all. and</span></p>
<p><span class="font45" style="font-weight:bold;">b)&nbsp;family members are sorted and gathered according to family.</span></p>
<p><span class="font45" style="font-weight:bold;">The number of members to be gathered is specified individually for each family. When that many kinsmen have arrived, they are permitted to proceed.</span></p>
<p><span class="font45" style="font-weight:bold;">8.4.2&nbsp;GATHR1</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions calling subroutine GATHR1 are locked until a certain number of their kinsmen, specified by the user, have arrived. When that has happened, the gather station is opened and the family reunion proceeds, one member at a time. GPSS-F supervises the gather stations automatically.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL GATHR1 (NG,NGATH,ID,41005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Number of transactions to collect</span></p>
<p><span class="font45" style="font-weight:bold;">The number of kinsmen to be gathered is specified. Type-1 gather station number (Type number) Type-1 gather stations are numbered sequentially. GATHR1 CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction must be locked, it is given this statement number as target; when it is re-activated to try</span></p><div>
<p><span class="font45" style="font-weight:bold;">NG</span></p>
<p><span class="font45" style="font-weight:bold;">NGATH</span></p>
<p><span class="font45" style="font-weight:bold;">ID</span></p></div>
<p><span class="font45" style="font-weight:bold;">the gather station again, It will continue its activity at the statement whose number this is. Normally, that would be the call to GATHR1 that originally caused the transaction to be locked. 61005 Locking exit</span></p>
<p><span class="font45" style="font-weight:bold;">If the transaction, is locked, flow management must be called; hence statement number 1005 should always be specified here. IPRINT Trace flag</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT = 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">GATHR1 uses the activation list, the TX matrix and the state vector. Each type-1 gather station has an entire section of the state vector to itself, one element for each family, since the gather station can be open to one family and at the same time closed to others. The gather station for families whose type number is NGATH has the state-vector elements from</span></p>
<p><span class="font45" style="font-weight:bold;">STATE(&quot;EGATE2&quot;*(NGATH-1)*&quot;FAM11)</span></p>
<p><span class="font45" style="font-weight:bold;">to</span></p>
<p><span class="font45" style="font-weight:bold;">STATE(&quot;EGATE2&quot;*(NGATH-1)*&quot;FAM1&quot;+&quot;FAM1&quot;)</span></p>
<p><span class="font45" style="font-weight:bold;">Further, a gather counter is needed for each family that specifies how many kinsmen have already arrived. It is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER GATHF</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION GATHF(&quot;FAM1&quot;,&quot;GATHF1&quot;)</span></p>
<p><span class="font45" style="font-weight:bold;">Each gather station has a column in the matrix corresponding to its type number, NGATH, and each column has an element for each family.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test for family membership&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(LFAM.EQ.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If the calling transaction is not a family member, return immediately.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Clear the blocking time&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).EQ.O) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX,8) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">When the process of letting a family reunion past the station has begun, each kinsman tries the gather station. Here, GATHR1 recognizes such transactions by the presence of a block time, which it zeroes, and lets them pass. If a transaction has no block time, it is a new arrival and must be locked.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark371"></a>100 K « &quot;EGATE2&quot; ♦ &quot;FAM1&quot; • (NGATH ~ tl ♦ LFAH The station number, K, is computed from NGATH. &quot;Lock*</span></p>
<p><span class="font45" style="font-weight:bold;">AL(LTX,1) s ID AL(LTX,2) = - &quot;KEND&quot; - K TXCLTX,8) S T</span></p>
<p><span class="font45" style="font-weight:bold;">GATHF(LFAM,NGATH) s GA THF(LFAM <sub>t</sub> HGA TH) ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">New arrivals at the gather station are always locked. At the same time, the count of locked kinsmen is incremented.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test the count&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(GATH<sup>P</sup>(LFAM,NGATH).LT.NG) GOTO 200</span></p>
<p><span class="font45" style="font-weight:bold;">If the new arrival raised the count of gathered kinsmen to the limit, the subroutine continues to &quot;Start the gathered transactions&quot;. Otherwise, it returns to flow management.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Start the gathered transactions&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">CALL IJNL0CK(K, IPRINT) GATHF(LFAM<sub>f</sub>NGATH) s 0 RETURN 1 200 CONTINUE RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">When the desired number of kinsmen has been reunited, they are started by calling UNLOCK. ACTIV2 activates them, one after the other, in the order determined by the station's policy, to try the gather station. Since they all now have block times, they will all find the gather station open.</span></p>
<p><span class="font45" style="font-weight:bold;">8.^.3 User Chains and Trigger Stations for Families</span></p>
<p><span class="font45" style="font-weight:bold;">The families' user chains-and trigger stations behave like the old ones (see 7.5), with the proviso that:</span></p>
<p><span class="font45" style="font-weight:bold;">a)&nbsp;transactions that aren't family members run through the stations completely untoutched and</span></p>
<p><span class="font45" style="font-weight:bold;">b)&nbsp;family members are sorted and gathered according to family.</span></p>
<p><span class="font45" style="font-weight:bold;">A family member arriving at a trigger station requests that a group of its kinsmen be let past the user chain. It cannot request members of another family. The kinsmen gathered at a user chain are let past only in case there are enough of them to cover &quot;he trigger station's request.</span></p>
<p><span class="font45" style="font-weight:bold;">Each user chain and each trigger station has an entire area of the the state vector to itself, one element for each family, since the station can be open to one family and at the same time closed to others. The type-1 user chain and trigger station whose type number is NUCHN have the state-vector elements from</span></p>
<p><span class="font45" style="font-weight:bold;">STATE( &quot;EGATHT&quot;* (NUCHN-1) •2*<sup>I,</sup>FAM1 1)</span></p>
<p><span class="font45" style="font-weight:bold;">to</span></p>
<p><span class="font45" style="font-weight:bold;">STATE( &quot;EGATHT&quot;* (NUCHN-1) »2+<sup>N</sup>FAM1 &quot;♦2»<sup>M</sup>FAH1<sup>11</sup>)</span></p>
<p><span class="font45" style="font-weight:bold;">Just as for their type-2 analoga, type-1 user chains and trigger stations have adjoining elements in the state vector. If the Kth element belongs to a user chain, the (K+1)th element belongs to its trigger station.</span></p>
<p><span class="font45" style="font-weight:bold;">There is-furthermore a UCHF matrix, corresponding to the UCHT matrix for type-2 user chains and trigger stations (see 7.5.1). Because all counters must be accumulated separately for each family, the matrix must be three-dimensional. It is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;">INTEGER UCHF</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION UCHF(&quot;FAM1&quot;,&quot;UCHF1&quot;,2)</span></p>
<p><span class="font45" style="font-weight:bold;">8.4.4 LINK! Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">A family member that calls LINM is blocked and placed in the user chain's queue. At the same time, LINK1 occasions a check to see whether the number of kinsmen being requested at the trigger station has arrived. If so, a kinsman-removal procedure begins.</span></p>
<p><span class="font45" style="font-weight:bold;">A kinsman removal begins when LIMK1 marks the user chain accessible to a particular family. Flow management begins activating blocked kinsmen, which then call LINK 1 again. LINK1 recognizes them and lets then pass, one by one, until the desired number has been let through. Then the user chain is marked inaccessible again.</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-<sup>P</sup> supervises the user chains automatically. Transactions that aren't family members are completely ignored.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL LIHK1 (NUCHN,ID,41005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NUCHN Type-1 user chain number (Type number)</span></p>
<p><span class="font45" style="font-weight:bold;">Type-1 user chains are numbered sequentially. The number is the same as the number of the trigger station that belongs to this user chain. ID&nbsp;LXNK1 CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions activated by a trigger station are to try the user chain again where there wait; they execute the CALL LINK1 statement bearing the number here specified.</span></p>
<p><span class="font45" style="font-weight:bold;">41005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">Vhen an arriving transaction is blocked, flow management must receive control again.</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">LINK1 uses the activation list, the TX matrix, the state vector and the UCHF matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test for family membership<sup>99 </sup>IF(LFAM.EQ.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If the calling transaction is not a family member, return immediately.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Determine the station number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">K s &quot;EGATHT&quot; ♦ 2 • &quot;FAM1&quot; « (NUCHN - 1) ♦ 2 <sup>41</sup> LFAM - 1*</span></p>
<p><span class="font45" style="font-weight:bold;">The station number, K, is computed from NUCHN. The station number of the corresponding trigger station will be K+1.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TX(LTX,8).NE.0) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">UCHF(LFAM,NUCHN,1) r UCHF(LFAM,NUCHN,1) ♦ 1 IF(UCHF(LFAM,NUCHN,2).GT.O) GOTO 50 STATE(K) s 0 STATE(K+1) s 1 50 AL(LTX,1) = ID AL(LTX,2) ? - K TX(LTX,8) = T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">Here, LINK1 recognizes, by the presence of a block time, the transactions being removed. If the calling transaction has a block time, it jumps to &quot;Remove&quot;. If a transaction has no block time, it is a new arrival and must be blocked. At the same time, the count of waiting kinsmen is incremented by one.</span></p>
<p><span class="font45" style="font-weight:bold;">Since there is now one more kinsman at the user chain, a transaction waiting at the trigger station should be activated to try its station again; the requisite number of kinsmen may now be available at the user chain. The user chain's trigger station is therefore marked accessible. In case the user chain is still accessible from the last removal procedure, it is marked inaccessible.</span></p>
<p><span class="font45" style="font-weight:bold;">Neither the user chain's nor the trigger station's present state may be disturbed, if a removal procedure is in progress. That is the case when UCHF(NUCHN,2) is non-zero. In that case, the new arrival just quietly takes its place among the waiting.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark372"></a>&quot;Remove&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 UCHF(LFAM,NUCHN,1) s UCHF(LFAH,NUCHN,1) - 1 UCHF(LFAM,NUCHN,2) s UCH<sup>I?</sup>(LFAM,NUCHN,2) - 1 IF(UCHF(LFAM,NUCHN,1).EQ.O) UCHF(LFAM,NUCHN,2) s 0 IF(UCHF(LFAM<sub>t</sub>NUCHN,2).GT.O) GOTO 150 STATE(K) s 0 STATE(K+1) s 1 150 TX(LTX,8) s 0 RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">This section is reached only by transactions being let past the user chain in a removal. The family's removal counters are decremented. (The removal counter has been set initially by UNLIN1 to shôw the maximum number of transactions being requested.) If there simply are no more transactions to remove, the removal counter is zeroed. The triggering transaction is assured of removing the minimum number of transactions it requires, since the removal procedure doesn't even begin until there are at least that many. Transactions arriving during a removal will be taken too, if the maximum hasn't been reached before they arrive.</span></p>
<p><span class="font45" style="font-weight:bold;">If the removal is over (UCHF(NUCHN,2)=0), the user chain is marked inaccessible. The trigger station is, however, made accessible again, since transactions could have arrived during the removal. The next transaction to try the trigger station could perhaps remove them.</span></p>
<p><span class="font45" style="font-weight:bold;">The block time is cleared for all transactions being allowed to pass.</span></p>
<p><span class="font45" style="font-weight:bold;">8.4.5 UNLIN1 Purpose :</span></p>
<p><span class="font45" style="font-weight:bold;">When a transaction calls UNLIN1, the subroutine checks the number of its kinsmen waiting at the associated user chain. If there are at least as many as the minimum number the calling transaction wants, a removal procedure is initiated. If, on the other hand, there are fewer kinsmen at the user chain than the requisite minimum, the transaction is blocked. New arrivals are also blocked, if there is already another transaction waiting at the trigger station. Each time another transaction arrives at the user chain, the trigger station is made accessible for trial again.</span></p>
<p><span class="font45" style="font-weight:bold;">UNLIN1 pays no attention to transactions that aren't family members. GPSS-F supervises the trigger stations.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL UNLIN1 (NUCHN,NUMIN<sub>f</sub>NUMAX,ID,41005,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NUCHN Type-1 user chain number</span></p>
<p><span class="font45" style="font-weight:bold;">The trigger station's number is the same as that of its user chain. NUCHN gives the user chain's line in the UCHF matrix. NUMIN Minimum request</span></p>
<p><span class="font45" style="font-weight:bold;">A removal can be initiated when there are at least so many of the caller's kinsmen waiting at the user chain. NUMAX Maximum request</span></p>
<p><span class="font45" style="font-weight:bold;">A removal will allow no more than so many transactions to pass the user chain. ID&nbsp;UNLIN1 CALL's statement number</span></p>
<p><span class="font45" style="font-weight:bold;">Transactions waiting at a trigger station are waiting for a certain number of their kinsmen to have gathered at the user chain. Each time any family member arrives there, the trigger station is made accessible again to its waiting transactions. When they are activated, they execute the CALL UNLIN1 statement bearing this number. 41005 Blocking exit</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction whose requisite number of kinsmen has not yet been gathered at the user chain is blocked. Then flow management must receive control again. IPRINT Trace control</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINT s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">UNLIN1 uses the activation list, the TX matrix, the state vector and the UCHF matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">••Test for family membership<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">IF(LFAM.EQ.O) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If the calling transaction is not a family member, return immediately.</span></p>
<p><span class="font45" style="font-weight:bold;">••Determine the station number&quot;</span></p>
<p><span class="font1">%</span></p>
<p><span class="font45" style="font-weight:bold;">K r &quot;EGATHT&quot; ♦ 2 * &quot;FAM1&quot; * (NUCHN - 1) ♦ 2 * LFAM - 1</span></p><div>
<p><span class="font45" style="font-weight:bold;">NUCHN.</span></p></div>
<p><span class="font45" style="font-weight:bold;">The user chain's station number, K, is computed from The trigger station's station number is £+1.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Blocking decision&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(UCHF(LFAM<sub>t</sub>NUCHN,1).GE.NUMIN.AND.STATE(K+1).EQ.1) GOTO 1</span></p>
<p><span class="font45" style="font-weight:bold;">If the trigger station has been made accessible, and if the bailing transact ion's minimum request is available at the user </span><span class="font45">c.t</span><span class="font45" style="font-weight:bold;"> ' the program jumps to &quot;Start a removal procedure&quot;. Other-wi</span><span class="font45" style="font-weight:bold;font-style:italic;"> rhe</span><span class="font45" style="font-weight:bold;"> calling transaction is blocked in the next section.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Block<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">STATE(K+1) s 0 AL(LTX,1) s ID AL(LTX<sub>f</sub>2) » « (K ♦ 1) IF(TX(LTX,8).EQ.O) TX(LTX<sub>f</sub>8) = T RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">The trigger station is only marked accessible by LINK1. That happens when any family member arrives at the user chain, or at the end of a removal procedure. Here, the trigger station is marked inaccessible as soon as it has been tried. The calling transaction is blocked to wait for LINK1 to mark its trigger station accessible again. Its block code is -CK+1)»</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Start a removal procedure&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">100 UCHF(LFAM,NUCHN,2) = NUMAX STATE(K) s 1 STATE(K+1) s 0</span></p>
<p><span class="font45" style="font-weight:bold;">IF(UCHF(LFAM,NUCHN, 1) .EQ.O) UCHF(LFAM,NtJCHN<sub>f</sub>2) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">TX(LTX,8) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">At start of the removal, IJNLIN1 sets the removal count to the maximum number of kinsmen it wants to remove, regardless whether there are that many available or not. Subroutine LINK1 decrements the counter until the request is satisfied, or its supply of kinsmen is depleted.</span></p>
<p><span class="font45" style="font-weight:bold;">No new arrival at the trigger station is to be allowed to disturb a removal procedure until it is over. For that reason, the trigger station is marked inaccessible, for the time being; at the end of the removal, LINK1 will mark it accessible again. The user chain must now be marked accessible, in order to initiate the removal.</span></p>
<p><span class="font45" style="font-weight:bold;">The triggering transaction's block time is cleared and it is allowed to proceed on its way.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;A newly arriving transaction is always blocked, if there is another waiting, even if it requests fewer transactions from the user chain than the waiting transaction. If need be, the user can alter this behaviour.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;In terms of accessibility for trial, a trigger station behaves like a type-2 gate: waiting transactions try it one by one, until one of them finds it closed; then it is made inaccessible for further trial. It will be made accessible again the next time a family member arrives at the user chain.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark373"></a>9 RANDOM SEQUENCES</span></p>
<p><span class="font48">Random numbers Help to simulate stochastic systems (see 1.1.2): unpredictable sequences of numbers determine when or how the system's unpredictable events occur. With careful rigging, this contrivance will model any randomly recurring event. We shall call a sequence of numbers random, when it fulfils two criteria:</span></p>
<p><span class="font47">a)</span><span class="font48">&nbsp;the sequence's terms recur with a given frequency and</span></p>
<p><span class="font48">b)&nbsp;there is no relation between the terms. Example:</span></p>
<p><span class="font48">* The digits in the sequence 11 1 1 12222233333</span></p>
<p><span class="font48">are not random. They satisfy the first requirement, but not the second: each digit occurs with equal frequency in the whole sequence, but there is an obvious relation between its terms.</span></p>
<p><span class="font48">The first part of this chapter (through 9.3.6) hopes to illuminate the generation and use of random sequences in modelling, but a thorough introduction belongs in a book of its own. Random sequences are a kaleidoscope and the trick is to know which kind to use and when. For simple models, a couple of broad rules and a lot of common sense will suffice; for highly complicated models, the choice can be crucial. If you hate mathematics, read this chapter looking past the formulas. If you enjoy math look into (ft) or (8).</span></p>
<p><span class="font45" style="font-weight:bold;">9.1 Random Number Generators</span></p>
<p><span class="font45" style="font-weight:bold;">To say that a system is stochastic</span><span class="font48"> is</span><span class="font45" style="font-weight:bold;"> just another</span><span class="font48"> way of say</span><span class="font45" style="font-weight:bold;">ing that one or more of the system's parameters is</span><span class="font48"> a</span><span class="font45" style="font-weight:bold;"> random</span><span class="font48"> vari</span><span class="font45" style="font-weight:bold;">able: it takes on Values unpredictably, except that</span><span class="font48"> it</span><span class="font45" style="font-weight:bold;"> may</span><span class="font48"> tend </span><span class="font45" style="font-weight:bold;">to prefer certain values. A. random variable</span><span class="font48">'s behaviour is deter</span><span class="font45" style="font-weight:bold;">mined by a distribution function that specifies which</span><span class="font48"> values it </span><span class="font45" style="font-weight:bold;">prefers and how much; its behaviour is modelled by</span><span class="font48"> a sequence of </span><span class="font45" style="font-weight:bold;">numbers that obeys the same distribution. Any manner</span><span class="font48"> of stochas</span><span class="font45" style="font-weight:bold;">tic event can be simulated, assuming random sequences</span><span class="font48"> of the re</span><span class="font45" style="font-weight:bold;">quired distribution can be gotten.</span></p>
<p><span class="font45" style="font-weight:bold;">A random sequence is distributed uniformly on an interval, if each of its terms is just as likely to turn up in one subinterval as in any other, disjoint subinterval of equal length; i.e. the sequence doesn't prefer any part of the interval. Uniform random Sequences are easily pressed into any distribution you please, </span><span class="font45">&quot;bus</span><span class="font45" style="font-weight:bold;"> the basis of stochastic simulation is a program that grinds </span><span class="font45">out a</span><span class="font45" style="font-weight:bold;"> uniform random sequence.</span></p>
<p><span class="font45" style="font-weight:bold;">b3 Random number generators usually build each tern In the sequence according to a specific algorithm. The algorithmic method has two advantages. First, it is easily put on a computer. Second, it yields repeatable sequences: if the generator is put back In its Initial state, it manufactures the same sequence every time.</span></p>
<p><span class="font45" style="font-weight:bold;">A computerized random number generator should fulfil the following requirements as well:</span></p>
<p><span class="font45" style="font-weight:bold;">a)&nbsp;It should be simple and run fast. This requirement is usually fulfilled when the algorithm generates each random number R(j+1) using nothing more than the previous one R(j).</span></p>
<p><span class="font45" style="font-weight:bold;">b)&nbsp;If it generates a repeating sequence, its period of repetition should be as large as possible.</span></p>
<p><span class="font45" style="font-weight:bold;">9.2 Uniformly Distributed Random Sequences</span></p>
<p><span class="font45" style="font-weight:bold;">Various methods generate pleasingly uniform random sequences. Only the multiplicative-congruence procedure will be discussed here, since it is used in GPSS-F. It computes terms in a random sequence from the equation:</span></p>
<p><span class="font45" style="font-weight:bold;">X(i*1) s (DFACT*X(i)+DCONST) mod DMODUL</span></p>
<p><span class="font45" style="font-weight:bold;">where DFACT, C and DMODUL must be chosen so as to guarantee randomness. According to (4), the following rules should be observed:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;If DMODUL is a power of two, DFACT should satisfy the relation:</span></p>
<p><span class="font45" style="font-weight:bold;">DFACT mod 8=5</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The relation between DMODUL and DFACT should satisfy:</span></p>
<p><span class="font45" style="font-weight:bold;">SORT( DMODUL) . LT. DFACT. LT. (DMODUL-SORT(DMODUL) )</span></p>
<p><span class="font45" style="font-weight:bold;">where DMODUL is as large as possible. It is further desirable that:</span></p>
<p><span class="font45" style="font-weight:bold;">DFACT.GT.DMODUL/100</span></p>
<p><span class="font45">*&nbsp;The additive constant C should be odd, if DMODUL is a power of two. In addition, C should be a multiple of 5, if DMODUL</span><span class="font45" style="font-weight:bold;"> is</span><span class="font45"> a power of 10.</span></p>
<p><span class="font45">*&nbsp;The relation between DMODUL and C should satisfy:</span></p>
<p><span class="font45">DCONST/DMODUL = 1/2-1/6*SQRT(3) = 0.211</span></p>
<p><span class="font45">In GPSS-F*s random number generators, the values of DFACT, and DMODUL were chosen to meet the above requirements. Furthermore, they were tested for randomness according to the following tests (all (4)):</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;Spectral test following Coveyou and MacPherson</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark374"></a>•&nbsp;Chi-squared test</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;Kolmogorov-Smirnov test</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;Gap test</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>11</sup> Permutation test</span></p>
<p><span class="font45" style="font-weight:bold;">The results are given in the listing for subroutine INIT1 (appendix A5).</span></p>
<p><span class="font48">9-3</span><span class="font45" style="font-weight:bold;"> Arbitrarily Distributed Random Sequences</span></p>
<p><span class="font45" style="font-weight:bold;">There are various methods for redistributing a uniform random sequence to meet a prescribed distribution. The techniques used in GPSS-F are reviewed below. They are described elsewhere in more detail, e.g. in (5).</span></p>
<p><span class="font45" style="font-weight:bold;">The next section (9.3*1) discusses a standard redistribution technique. The subsequent three sections (9.3.2 -to 9.3.ft) describe four distributions used often in modelling. Each •section defines the circumstances under which that kind of randomness occurs, giving typical examples, followed by some brief notes on its computation. Finally, sections 9.3.5 and 9.3.6 discuss special topics in the use of GPSS-F's random number generators.</span></p>
<p><span class="font45" style="font-weight:bold;">Further techniques are easy to find in books on simulation or in standard scientific-subroutine packages.</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.1 Using the Inverse Cumulative-Distribution ^unction</span></p>
<p><span class="font45" style="font-weight:bold;">A random sequence's distribution is determined by its density function f(X), or by its cumulative-distribution function F(X), called its cdf for short. Very roughly speaking, a random sequence prefers intervals (i.e. occurs most densely) where its density function is highest. Figures 29 through 31 show some typical density functions.</span></p>
<p><span class="font45" style="font-weight:bold;">A random sequence's cdf can be computed from its density function using the integral calculus. It is only worth the trouble, because an inverse-cdf redistributes a uniform sequence to match its own density function. If R(i) is the ith term in a random sequence distributed uniformly on the interval from 0 to 1, a second sequence X(i), whose cdf is, say F(X), can be won from it by taking:</span></p>
<p><span class="font45" style="font-weight:bold;">X(i) r F (R(i) )&nbsp;0 &lt;= R(i) &lt;= 1</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* We want a sequence of exponentially distributed random numbers. The sequence's density function is:</span></p>
<p><span class="font45" style="font-weight:bold;">~f(X) * ALPHA*exp(-ALPHA*X )</span></p>
<p><span class="font45" style="font-weight:bold;">IT 1</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark375"></a>so its cdf is:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark376"></a>X</span></p>
<p><span class="font44" style="font-weight:bold;font-variant:small-caps;">r</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark377"></a>P(X) « i ALPHA*exp(-ALPHA*T)dT s 1-exp(-ALPHA*X) * R 0</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark378"></a>and its inverse-cdf is: • 1</span></p>
<p><span class="font45" style="font-weight:bold;">F (X) s -1/ALPHA*ln(t-R) s R</span></p>
<p><span class="font45" style="font-weight:bold;">Assuming R(i) is uniformly random<sub>9</sub> we get our exponentially distributed sequence X(i) from the equation:</span></p>
<p><span class="font45" style="font-weight:bold;">X(i) = -1/ALPHA*ln( 1-R(i))</span></p>
<p><span class="font45" style="font-weight:bold;">But if R is uniformly distributed, so is (1-R), whence we take:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark379"></a>X(i) = -1/ALPHA*ln R(i)&nbsp;f^BH^^H</span></p>
<p><span class="font45" style="font-weight:bold;">The inverse-cdf method works well only when the cdf is symbolically integrable. If the cdf cannot be integrated using standard non-numeric tecniques, some other method must be used to redistribute the uniform sequence.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* A Gauss-distributed sequence is to be generated. Its density function with mean of zero and standard deviation of one is:</span></p>
<p><span class="font45" style="font-weight:bold;">f(X) s 1/SQRT(2*PI)*exp(-1/2*X**2)</span></p>
<p><span class="font45" style="font-weight:bold;">Its cdf is:&nbsp;- :</span></p>
<p><span class="font45" style="font-weight:bold;">X</span></p>
<p><span class="font45" style="font-weight:bold;">r</span></p>
<p><span class="font45" style="font-weight:bold;">F(X) s 1/SQRT(2*PI)* I exp(-1/2*U**2)dU</span></p>
<p><span class="font45" style="font-weight:bold;">-oo</span></p>
<p><span class="font45" style="font-weight:bold;">The cdf can be integrated only by numeric techniques, not by symbolic or analytic methods. Hence, the inverse-cdf method can't be applied.</span></p>
<p><span class="font45" style="font-weight:bold;">9*3.2 Exponential and Erlang Distributions</span></p>
<p><span class="font45" style="font-weight:bold;">When the probability of an event's occurrence in a small interval is very small and when its occurrence 13 Independent of all other events of the same kind, the time until the next occurrence is exponentially distributed. There are surprisingly many real systems in which the time between occurrences is exponential. Among them are all arrival phenomena where the arrivals are independent, or virtually so.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;The intervals between accidents in a factory, or between many types of component failures, are exponentially distributed.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;The time between the arrival of orders at a company, of patients at a hospital, of telephone calls at a switchboard or of airplanes at an airport is likewise exponential. Though the. arrival times themselves are distributed some other way, the intervals between stochastic arrivals are almost always distributed exponentially.</span></p>
<p><span class="font45" style="font-weight:bold;">Exponential distributions have a density function whose general form is:</span></p>
<p><span class="font45" style="font-weight:bold;">f(X) s ALPHA*exp(-ALPHA*X)</span></p>
<p><span class="font45" style="font-weight:bold;">in which ALPHA determines, as usual In statistics, the shape of the function's curve. It is, however, standard practice specify the shape of this distribution in terms of its mean or expectation:</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN = 1/ALPHA</span></p>
<p><span class="font45" style="font-weight:bold;">The smaller the mean, the more sharply the curve drops off from its peak.</span></p>
<p><span class="font45" style="font-weight:bold;">Erlang distribution is a generalized form of the exponential. It can be pictured as the distribution arrising from a process consisting of k identical, exponential processes occurring in sequence. If, for example, an exponential sequence gives the time till an event's next occurrence (arrival), the corresponding Erlang sequence would give the time until its kth-next occurrence.</span></p>
<p><span class="font45" style="font-weight:bold;">The Erlang distribution has the following density function:</span></p>
<p><span class="font45" style="font-weight:bold;">f(X) s (ALPHA*«k*X*«(k-1)*exp(-ALPHA*X))/fac(k-1)</span></p>
<p><span class="font45" style="font-weight:bold;">where fac is the factorial function.</span></p>
<p><span class="font45" style="font-weight:bold;">fac(k) r 1*2* . . . »(k-1) * k&nbsp;■ <sup>:</sup> ^^^^</span></p>
<p><span class="font45" style="font-weight:bold;">Its mean or expectation, which determines the shape of the curve is:</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN = k/ALPHA</span></p>
<p><span class="font45" style="font-weight:bold;">Again, for a given k, the smaller the mean, the sharper the curve's peak. Further, when k is 1, the Erlang distribution reduces to the exponential, its often-used special case. The Erlang distribution is itself a special case of the gamma distribution. The gamma distribution*s density function is generalized to let k </span><span class="font84" style="font-weight:bold;">be any</span><span class="font45" style="font-weight:bold;"> positive real number.</span></p>
<p><span class="font18">• ft</span></p><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">OOO k = 1 </span><span class="font45" style="font-weight:bold;font-style:italic;">♦♦♦ k * 2 </span><span class="font45" style="font-weight:bold;">Mf k s 5</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div>
<p><span class="font45" style="font-weight:bold;">0</span></p><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0+ ♦0 * 0</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 • ft</span></p>
<p><span class="font45" style="font-weight:bold;">»0 • 0</span></p>
<p><span class="font11">ft ft ft</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font11">♦</span></p></div><div>
<p><span class="font11">ft ft</span></p>
<p><span class="font11">ft ft</span></p>
<p><span class="font10">ft *</span></p>
<p><span class="font12">♦ «</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font11">ft ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div>
<p><span class="font11">ft ft ft</span></p><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div>
<p><span class="font45" style="font-weight:bold;">o * ♦ 0 « ♦ 0 « + 0 ♦ *0</span></p>
<p><span class="font11">ft</span></p><div>
<p><span class="font11">ft ft ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0</span></p></div><div>
<p><span class="font11">♦</span></p>
<p><span class="font45" style="font-weight:bold;">»III</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font11">ft ft</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 ft</span></p></div><div>
<p><span class="font11">ft ft</span></p></div>
<p><span class="font16" style="font-weight:bold;">10</span></p><div>
<p><span class="font59" style="font-weight:bold;">2</span></p></div><div>
<p><span class="font83" style="font-weight:bold;">8</span></p></div>
<p><span class="font45" style="font-weight:bold;">THE ERLANG DISTRIBUTION FOR MEAN = 5</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 29</span></p></div>
<p><span class="font45" style="font-weight:bold;">Erlang's cdf isn't symbolically integrable. We must find some other technique, than inverse-cdf<sub>f</sub> to redistribute our uniform R(i) into Erlang-density. The easy way is to mimic the standard process in which Erlajng distributions occur: merely sum k terms from an exponential random sequence Y(i):</span></p>
<p><span class="font45" style="font-weight:bold;">X « &gt; Y(i) s -1/ALPHA* &gt; ln(R(i))</span></p>
<p><span class="font45" style="font-weight:bold;">lat&nbsp;irl</span></p>
<p><span class="font45" style="font-weight:bold;">where R(i) is our uniform random sequence. To save unnecessary logarithm computations, we rewrite the summation as a product:</span></p>
<p><span class="font45" style="font-weight:bold;">k</span></p>
<p><span class="font45" style="font-weight:bold;">I* I</span></p>
<p><span class="font45" style="font-weight:bold;">X * -1/ALPHA«ln | | R(i)</span></p>
<p><span class="font45" style="font-weight:bold;">Is1</span></p>
<p><span class="font48">9.3.3 Gauss Distribution</span></p>
<p><span class="font48">The central-limit theorem says:</span><span class="font45" style="font-weight:bold;"> If</span><span class="font48"> a random sequence</span><span class="font45" style="font-weight:bold;"> X is the </span><span class="font48">sum of k independent random sequences Y(j)</span></p>
<p><span class="font48">k</span></p>
<p><span class="font45" style="font-weight:bold;">X X &gt; Y(j)</span></p>
<p><span class="font45" style="font-weight:bold;">then, for sufficiently large k,</span><span class="font70" style="font-style:italic;"> X</span><span class="font45" style="font-weight:bold;"> approaches the Gauss distribution. The theorem holds, provided each of the Y(j) contributes only negligibly to the final sum. If each of the Y(j) is identically distributed, the proviso is fulfilled automatically for large k. Further, the sum of any finite number of Gauss distributions is again Gauss-distributed.</span></p>
<p><span class="font45" style="font-weight:bold;">Gauss distributions are everywhere you look. The size of each of the leaves on a particular tree, the exact baggage weight of all passangers flying to Honolulu and the amount of thread used weekly at the Plaid Wonder shirt factory are all Gauss-distribu-ted. The central-limit theorem explains why: each of the sizes or weights or amounts is determined by dozens of independent factors, whose influence is additive and none of which predominates.</span></p>
<p><span class="font45" style="font-weight:bold;">Further examples: .</span></p>
<p><span class="font45" style="font-weight:bold;">* At any given time, the electricity consumption in a city is the sum of each customer's consumption. The total number of kilowatts consumed at noon every day is Gauss distributed.</span></p>
<p><span class="font45" style="font-weight:bold;"><sup>9</sup> At the State Fair's livestock pageant, the prize pig is chosen by a distinguished panel of judges. Each judge assigns each pig one to three points in twenty independent categories. The hogs' total scores will be Gauss distributed.</span></p>
<p><span class="font45" style="font-weight:bold;">The Gaussian distribution's density function is the bell curve:</span></p>
<p><span class="font45" style="font-weight:bold;">f(X) s 1 / (SIGMA^SQRTf 2*PI) )*exp(- 1 /2* ( (X-MEAN) /SIGMA )**2)</span></p>
<p><span class="font45" style="font-weight:bold;">Its cdf isn't symbolically integrable, so a special redistribution method has to be sought. A Gauss-distributed sequence X can be computed easily and quickly, following (6), using two sequences, R1 and R2, uniform on the interval (0<sub>V</sub>1):</span></p>
<p><span class="font45" style="font-weight:bold;">X « (-2»ln(R1))«»1/2*cos(2»PI»R2)</span></p>
<p><span class="font45" style="font-weight:bold;">X's mean is zero and its standard deviation, one. To arrive at a Gaussian sequence Z<sub>f</sub> with arbitrary standard deviation and mean, merely multiply X by 5IGHA and add MEAN:</span></p>
<p><span class="font45" style="font-weight:bold;">Z x X*SIGMA+MEAN</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.4 Lognormal Distribution</span></p>
<p><span class="font45" style="font-weight:bold;">The lognormal distribution is closely related to the Gauss distribution. A distribution 0 is lognormal just in case its logarithm is normal. Certain kinds of failure phenomena are lognormal. The distribution's density function is:</span></p>
<p><span class="font45" style="font-weight:bold;">f(Q) = 1/F»exp(-1/2«ln(Q-MEANX)**2/SIGMAX**2</span></p>
<p><span class="font45" style="font-weight:bold;">F s SIGMAX*SQRT(2*PI)*Q</span></p>
<p><span class="font45" style="font-weight:bold;">where MEANX and SIGMAX are the mean and standard deviation of its corresponding Gauss distribution. Its mean and variance are:</span></p>
<p><span class="font45" style="font-weight:bold;">HEANQ = exp(MEANX*1/2*SIGMAX**2)</span></p>
<p><span class="font45" style="font-weight:bold;">SIGMA0**2 = exp(2*MEAHX+SIGMAX»»2)*(exp(STGMAX**2)-1)</span></p>
<p><span class="font45" style="font-weight:bold;">Given a lognormal distribution's mean and variance, we solve for MEANX and SIGMAX to obtain:</span></p>
<p><span class="font45" style="font-weight:bold;">SIGMAX**2 r ln(SIGMAQ**2/MEAMQ»«2+1)</span></p>
<p><span class="font45" style="font-weight:bold;">MEANX = ln(MEANO)-1/2*SIGMAX**2</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.5 Approximating Empirical Distributions</span></p>
<p><span class="font45" style="font-weight:bold;">It often happens that no standard distribution curve quite matches the data gathered from a real system, or it may not be worth the trouble to try to find a matching curve.</span></p>
<p><span class="font45" style="font-weight:bold;">A crude, but simple method is to divide the data s domain into intervals short enough, that, within each of them, the data could be taken as uniformly distributed. The uniformity assumption simplifies the curve into a step function, for which it is easy to write a redistribution subroutine based on GPSS-F's uniform random number generator. The ratio of terms to be drawn from one step's interval is given by the ratio of the area of the rectangle under that step to the total area under all steps. (Similar technique is applied below and in 9*4.6.)</span></p>
<p><span class="font61" style="font-weight:bold;"><a name="bookmark380"></a>• •</span></p>
<p><span class="font12">#</span></p>
<p><span class="font20">»</span></p><div>
<p><span class="font45" style="font-weight:bold;">4 </span><span class="font60" style="font-weight:bold;">2</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">SIGMA x SIGMA x</span></p></div>
<p><span class="font45" style="font-weight:bold;">M» SIGMA x 1</span></p><div>
<p><span class="font59" style="font-weight:bold;">000</span></p></div><div>
<p><span class="font13">♦</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark381">0 ♦&nbsp;*</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark382">0+&nbsp;*</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark383">♦0&nbsp;*</a></span></p>
<p><span class="font45" style="font-weight:bold;">♦ 0«</span></p>
<p><span class="font13"><a href="#bookmark384">♦&nbsp;*</a></span></p>
<p><span class="font13"><a href="#bookmark385">♦&nbsp;*</a></span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">0 0</span></p></div>
<p><span class="font11">* ♦</span></p>
<p><span class="font45" style="font-weight:bold;">0 * ♦ 0 • ♦ 0« ♦ * 0 ♦ • Of-« t&gt; ♦</span></p><div>
<p><span class="font45" style="font-weight:bold;">0 0 0 0</span></p>
<p><span class="font45" style="font-weight:bold;">0 0 0 0</span></p>
<p><span class="font45" style="font-weight:bold;">0 0 0</span></p></div>
<p><span class="font45" style="font-weight:bold;">0&lt;</span></p>
<p><span class="font17" style="font-weight:bold;">10</span></p><div>
<p><span class="font49" style="font-weight:bold;">8</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">4</span></p></div><div>
<p><span class="font59" style="font-weight:bold;">2</span></p></div>
<p><span class="font45" style="font-weight:bold;">FIGURE 30&nbsp;THE LOGNORMAL DISTRIBUTION FOR MEAN x 5</span></p>
<p><span class="font45" style="font-weight:bold;">A more sophisticated technique approximates the data y method of least squares. Again, the data may be dlvicea J the convenient intervals, each to be handled separately- ri&quot;^«ffl is inverse-cdf method is applied on each interval, eacn oi</span></p>
<p><span class="font45" style="font-weight:bold;">weighted as for the step function.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark386"></a>Example</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark387"></a>* Empirically determined distributions are sometimes approximated roughly by a sequence that is part uniform, part exponential (see figure 31). The density function is fully specified by HIN and MAX, the bounds of the uniform interval, and RATIO, the ratio of terms to be drawn from it. Elements are drawn with a ratio (1-RATIO) from the exponential interval (see 9.4.6).</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark388"></a>The exponential curve is matched to the box by the following equation:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark389"></a>Y&nbsp;* C»exp(-ALPHA*MAX)</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark390"></a>Norming the area under the exponential curve to 1-RATIO yields:</span></p>
<p><span class="font45" style="font-weight:bold;">oo</span></p>
<p><span class="font45" style="font-weight:bold;">r</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark391"></a>1-RATIO r C» I exp(-ALPHA*X)dX MAX</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark392"></a>The box's area must be RATIO, whence its height is:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark393"></a>Y&nbsp;s RATIO/(MAX-MIN)</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark394"></a>The random sequence is computed for each interval using the in-verse-cdf:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark395"></a>X(i) = (MAX-MIN)/RATIO*R(i)+MIN for 0 &lt;= R(i) &lt; RATIO</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark396"></a>X(i) = MAX-(1-RATIO)*(MAX-MIN)/RATIO*ln(1-R(i)/(1-RATIO)) for RATIO &lt;= R(i) &lt; 1</span></p>
<p><span class="font45" style="font-weight:bold;">9.3.6 Truncated Distributions</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F provides the means to specify an interval from which a random sequence must be drawn. The feature truncates, in effect, the sequence's density function. The truncation offers two advantages :</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;Distributions in a real system seldom follow the mathematically idealized functions exactly, especially not at their extremes. By specifying upper and lower bounds, the user throws away the extreme right and left portions of the function.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;The time it takes the oscillations in a stochastic model's startup phase to die down depends on the standard deviations of its random parameters: the more broadly they are distributed about their means, the more slowly the startup oscillations die away (see 1.5.4). A density function's standard deviation can be reduced by truncating its extremes.</span></p>
<p><span class="font19" style="font-weight:bold;"><a name="bookmark397"></a>0.8</span></p>
<p><span class="font45" style="font-weight:bold;">MIH « 0.5 HAX = 1 RATIO = 0.*</span></p>
<p><span class="font45" style="font-weight:bold;">0.* ♦</span></p>
<p><span class="font60" style="font-weight:bold;">2</span></p><div>
<p><span class="font70" style="font-weight:bold;">1</span></p></div>
<p><span class="font47">MIH = 0.5</span></p>
<p><span class="font45" style="font-weight:bold;">MAX = 1 RATIO = 0.2</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark398"></a>U.O</span></p>
<p><span class="font45" style="font-weight:bold;">4- • </span><span class="font57" style="font-weight:bold;">2</span></p><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 31</span></p></div>
<p><span class="font45">THE DISTRIBUTION FOR BOXEXP</span></p>
<p><span class="font45" style="font-weight:bold;">Extremely large or small random values can bear unpleasantly heavily on a simulation's results, if their occurrence is unlikely in practice. An unrealistic value flusters a model and it may take the model a long time to calm back down to normal. By truncating the density function's extremes, a model avoids having to simulate once-in-a-blue-moon occurrences.</span></p>
<p><span class="font52" style="font-variant:small-caps;">a</span><span class="font45" style="font-weight:bold;"> truncated density function will have a new standard deviation, even if it is carefully trimmed to leave its mean unchanged. Truncated distributions therefore yield results different from those of their untruncated versions. If the results of a simulation using truncated distributions are to be compared with those from an analytic model (see 1.5•3)<sub>f</sub> the analytic model must use conditional probabilities.</span></p>
<p><span class="font45" style="font-weight:bold;">Symetrical distributions, like the Gaussian, are easily truncated without altering their means. Since the mean coincides with the axis of symetry, the curve is merely trimmed so as to leave it symetrical. If an asymetric distribution is to be truncated without changing its mean, one of the bounds is chosen and the other computed so as to leave the mean unaltered. The procedure is illustrated below.</span></p>
<p><span class="font45" style="font-weight:bold;">Given f (X), the truncated density function, we have:</span></p>
<p><span class="font45" style="font-weight:bold;">f (X) s 0&nbsp;for X &lt;= or X &gt; MAX</span></p>
<p><span class="font45" style="font-weight:bold;">MAX</span></p>
<p><span class="font45" style="font-weight:bold;">a</span><span class="font48">&nbsp;r</span></p>
<p><span class="font45" style="font-weight:bold;">f (X) r f(X)/ | f(X)dX&nbsp;for MTN &lt; X &lt;= MAX</span></p>
<p><span class="font45" style="font-weight:bold;">MIN</span></p>
<p><span class="font45">The truncated distribution's mean is: </span><span class="font45" style="font-weight:bold;">• &quot; j- *</span></p>
<p><span class="font45">MEAN r | X*f (X)dX and the original distribution's mean is:</span></p>
<p><span class="font45" style="font-weight:bold;">r</span></p>
<p><span class="font45">MEAN = | X*f(X)dX</span></p>
<p><span class="font45">The goal is to choose MIN and MAX so that: ft</span></p>
<p><span class="font45">MEAN s MEAN</span></p>
<p><span class="font48"><a name="bookmark399"></a>5.0</span></p><div>
<p><span class="font45" style="font-weight:bold;">MIN</span></p></div>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark400"></a>O.i»</span></p>
<p><span class="font48"><a name="bookmark401"></a>0.3</span></p>
<p><span class="font72" style="font-weight:bold;"><a name="bookmark402"></a>0.2</span></p>
<p><span class="font72"><a name="bookmark403"></a>0.1 ♦</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN</span></p>
<p><span class="font45" style="font-weight:bold;">15</span></p><div>
<p><span class="font16" style="font-weight:bold;">10</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">FIGURE 32</span></p></div>
<p><span class="font45" style="font-weight:bold;">THE VALUES FOR MIN IN DEPENDENCE OF MEAN</span></p>
<p><span class="font45" style="font-weight:bold;">whence</span></p>
<p><span class="font45" style="font-weight:bold;">MAX</span></p>
<p><span class="font29" style="font-weight:bold;">r</span></p>
<p><span class="font45" style="font-weight:bold;">| (X-MEAN)»f(X)dX MIN</span></p><div>
<p><span class="font45" style="font-weight:bold;">= 0</span></p></div><div>
<p><span class="font45">differential</span></p></div>
<p><span class="font45">Now when one of the bounds is specified, the tion can be used to solve for the other.</span></p>
<p><span class="font45" style="font-weight:bold;">Examples:</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;For the Erlang distribution, the equation yields:</span></p>
<p><span class="font45" style="font-weight:bold;">MIN^k^expC-ALPHA^MIN) * HAX<sup>ll#</sup>k*exp(-ALPHA<sup>ll</sup>MAX)</span></p>
<p><span class="font45" style="font-weight:bold;">The equation cannot be solved for MIN or MAX. The easiest way to find them is to set one and use an iterative procedure to compute the other.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;For the exponential distribution, figure 32 gives a rough estimate of the dependence of MIN on MEAN, given that:</span></p>
<p><span class="font45" style="font-weight:bold;">MAX s 5*KEAN</span></p>
<p><span class="font45" style="font-weight:bold;">If e.g. for a mean of 4,. MAX is set to 5 * ^ * 20, the graph yields HIM s 0.1H. The computed value would be MIN = 0.168.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;For lognormal distributions, the relation between MAX and MIN is:</span></p>
<p><span class="font45" style="font-weight:bold;">MAX s MEANQ»»2/MIN</span></p>
<p><span class="font45" style="font-weight:bold;">9.* Random Numbers in GPSS-F</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F offers the user as many independent, uniform random number generators as he specifies. In addition, it offers subroutines that redistribute a uniform sequence into specific distributions .</span></p>
<p><span class="font45" style="font-weight:bold;">9.^.1 Function RN Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">The function generates a uniform random sequence on the interval between 0 and 1 using the multiplicative congruence method.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">RN(RNUM)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">RNUM Generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">This number specifies which of the generators is to generate a new terra in its sequence.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">RN uses the system variables DFACT, DMODUL and DCONST. In addition, it uses the random number vector, DRN, which is defined as follows:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark404"></a>REAL*8 DRN</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION DRN(&quot;DRN1&quot;)</span></p>
<p><span class="font45" style="font-weight:bold;">RN computes the (i+1)th term in a sequence X from the ith term: X(i*1) * f(X(i))</span></p>
<p><span class="font45" style="font-weight:bold;">Each generator has a field in the vector<sub>9</sub> given by RNU!1<sub>9</sub> where the ith term in its sequence is held for reference during the next generation.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Generate a uniform random sequence&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DRN ( RNUM) =DftOD(DF ACT (RNUM) *DRN( RNUM )«*DCOMST( RNUM) <sub>f</sub> DMODUL)</span></p>
<p><span class="font45" style="font-weight:bold;">RN s DRN(RNUM) / (DMODUL - 1.)</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">The next term in a random sequence is generated. The function DMOD yields the remainder of a division; it is defined as follows:&nbsp;,</span></p>
<p><span class="font45" style="font-weight:bold;">DMOD(x<sub>f</sub>y) s x mod y</span></p>
<p><span class="font45" style="font-weight:bold;">DMOD and its two parameters are all of type REAL*8.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;Subroutine INIT1 sets the variables DFAC<sup>T</sup> and DMODUL, as well as the contents of the DRN vector.</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;ftost computer manufacturers supply a random number generator tailored for their machine. Their generator should be preferred to RN, which is machine-independent and takes no advantage of a specific machine's features.</span></p>
<p><span class="font45" style="font-weight:bold;">9-4.2 UNIFRM</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine redistributes a uniform sequence over any interval specified by the user.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p><div>
<p><span class="font45" style="font-weight:bold;">A B</span></p>
<p><span class="font45" style="font-weight:bold;">RNUM</span></p></div>
<p><span class="font45" style="font-weight:bold;">CALL UNIFRM (A,B,RNUM,RANDOM)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Interval's lower boundary Interval's upper boundary Generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">The generator numbered RNUM generates the next term in a</span></p>
<p><span class="font45" style="font-weight:bold;">uniform sequence between 0 and 1. This subroutine uses the term to compute the next member in a redistributed sequence* RANDOM Resulting random number</span></p>
<p><span class="font45" style="font-weight:bold;">The result of UNIFRM's computation is returned here.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">RANDOM s A ♦ (B - A) • RN(RNUM)</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">A random number on the interval (0,1) is used to pull another from the interval specified by the user.</span></p>
<p><span class="font45" style="font-weight:bold;">9.4,3 ERLANG Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Erlang-distributed random numbers are generated on the specified interval.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ERLANG (MEAN,K,MIN,MAX,RNUM,RANDOM,&amp;1006)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN Mean value</span></p>
<p><span class="font45" style="font-weight:bold;">The mean of the values to be generated is given. K&nbsp;Degree</span></p>
<p><span class="font45" style="font-weight:bold;">The degree specifies how many identical exponential distributions are added to yield the desired Erlang distribution.</span></p>
<p><span class="font45" style="font-weight:bold;">MIN&nbsp;Interval's lower boundary</span></p>
<p><span class="font45" style="font-weight:bold;">MAX&nbsp;Interval's upper boundary</span></p>
<p><span class="font45" style="font-weight:bold;">RNUM Generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">The generator numbered RNUM generates the next term in a uniform sequence between 0 and 1. This subroutine uses the term to compute the next member in a redistributed sequence. RANDOM Resulting random number</span></p>
<p><span class="font45" style="font-weight:bold;">The result of ERLANG's computation is returned here. &amp;1006 Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">If K is less than 1, the simulation should be terminated .</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Error control&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(K-I.GE.O) GOTO 50 RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If the degree is less than 1<sub>t</sub> the error exit is taken.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Generate an Erlang-diatributed random number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">50 ALPHA &gt; FLOAT(K) / MEAN 100 В « 1.0</span></p>
<p><span class="font45" style="font-weight:bold;">DO 150 I s 1 , К 150 R x R • RN(RNUM)</span></p>
<p><span class="font45" style="font-weight:bold;">IF(R.EQ.O) GOTO 100 <sup>v</sup> RANDOM ж -1.0 / ALPHA • ALOG(R)</span></p>
<p><span class="font45" style="font-weight:bold;">The random number generated by RN is redistributed according to the method described in 9.3*2.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Interval check&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(RANDOM.LT.MIN.OR.RANDOM.GT.MAX) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">If the number generated isn't on the interval (MIN<sub>9</sub>MAX)<sub>9</sub> it is rejected and the subroutine tries again.</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;">* When K * 1, the generated sequence is exponential.</span></p>
<p><span class="font45" style="font-weight:bold;">9*M.i| GAUSS Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">Gauss-distributed random numbers are generated on a specified interval.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL GAUSS (MEAN,SIGMA,MIN<sub>f</sub>MAX,RNUM,RANDOM)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Mean value</span></p>
<p><span class="font45" style="font-weight:bold;">The bell curve's mean value is Standard deviation The curve's standard deviation Interval's lower boundary Interval's upper boundary Generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">The generator numbered RNUM generates the next term uniform sequence between 0 and 1. This subroutine</span></p><div>
<p><span class="font45" style="font-weight:bold;">MEAN</span></p>
<p><span class="font45" style="font-weight:bold;">SIGMA</span></p>
<p><span class="font45" style="font-weight:bold;">MIN MAX RNUM</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">specified. is given.</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">in a uses</span></p></div>
<p><span class="font45" style="font-weight:bold;">the term to compute the next member in a . redistributed sequence.</span></p>
<p><span class="font45" style="font-weight:bold;">Resulting random number</span></p>
<p><span class="font45" style="font-weight:bold;">The result of GAUSS' computation is returned here.</span></p><div>
<p><span class="font45" style="font-weight:bold;">RANDOM</span></p></div>
<p><span class="font52" style="font-weight:bold;"><a name="bookmark405"></a>Algorithm description:</span></p>
<p><span class="font47"><a name="bookmark406"></a>&quot;Generate a Gauss-distributed random number&quot;</span></p>
<p><span class="font47"><a name="bookmark407"></a>100 R a RN(RNUM)</span></p>
<p><span class="font47"><a name="bookmark408"></a>IF(R.EQ.O) GOTO 100</span></p>
<p><span class="font47"><a name="bookmark409"></a>V s (-2.0 • ALOG(R)) •• 0.5 • COS(6.2832 • RN(RNUM)) RANDOM = V * SIGMA ♦ MEAN</span></p>
<p><span class="font47"><a name="bookmark410"></a>The next term in a Gaussian sequence is computed according to the method given in 9-3*3.</span></p>
<p><span class="font47"><a name="bookmark411"></a>&quot;Interval check&quot;</span></p>
<p><span class="font47"><a name="bookmark412"></a>IF(RANDOM.LT.MIN.OR.RANDOM.GT.MAX) GOTO 100</span></p>
<p><span class="font47"><a name="bookmark413"></a>RETURN •</span></p>
<p><span class="font47"><a name="bookmark414"></a>END</span></p>
<p><span class="font47"><a name="bookmark415"></a>If the number generated doesn't fall in the specified interval, It is rejected and the program tries again.</span></p>
<p><span class="font47"><a name="bookmark416"></a>9.4.5 LOGNOR Purpose:</span></p>
<p><span class="font47"><a name="bookmark417"></a>Lognormally distributed random numbers are generated on a specified interval.</span></p>
<p><span class="font47"><a name="bookmark418"></a>Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL LOGNOR (MEAN<sub>9</sub>SIGMA,MIN<sub>9</sub>MAX<sub>t</sub> RNUM,RANDOM)</span></p>
<p><span class="font47"><a name="bookmark419"></a>Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN Mean value</span></p>
<p><span class="font45" style="font-weight:bold;">The lognormal distribution's mean value is specified. SIGMA Standard deviation</span></p>
<p><span class="font45" style="font-weight:bold;">The curve's standard deviation is given. WIN&nbsp;Interval's lower boundary</span></p>
<p><span class="font45" style="font-weight:bold;">**AX&nbsp;Interval's upper boundary</span></p>
<p><span class="font45" style="font-weight:bold;">RNUM Generator's identifier</span></p>
<p><span class="font45" style="font-weight:bold;">The generator numbered RNUM generates the next term</span><span class="font47"> In a </span><span class="font45" style="font-weight:bold;">uniform sequence between 0 and 1. This subroutine use3 the term to compute the next member in a redistributed sequence. RANDOM Resulting random number</span></p>
<p><span class="font45" style="font-weight:bold;">The result of LOGNOR's computation is returned here.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description: Generate a lognormally-distributed random number&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">SIGMX2 = ALOG(SIGMA ** 2 / MEAN ** 2 ♦ 1 . ) MEANX = AL0G(MEAN) - 0.5 * SIGMX2 SIGMX s SQRT(SIGMX2)</span></p>
<p><span class="font48"><a href="#bookmark420">1 2 3 4 </span><span class="font50" style="font-weight:bold;">..A.......A..........A.......A..</span></a></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark421">11&nbsp;I&nbsp;II</a></span></p>
<p><span class="font45" style="font-weight:bold;">i*«»«-------—♦---------</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark422">12&nbsp;3&nbsp;4</a></span></p>
<p><span class="font48">FIGURE 33&nbsp;SETTING A RANDOM SEQUENCE'S BOUNDS</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font50" style="font-weight:bold;">• A</span><span class="font48"> random sequence uniformly distributed on the Interval from 1 to 4 is to be generated by the following statements:</span></p>
<p><span class="font48">CALL UNIFRM (1•,4.,RNUM,RANDOM) IRAND s IFIX(RANDOM ♦ 0.5)</span></p>
<p><span class="font48">The program would convert reals on the interval between 1.0 and 1.5 to 1| or between 3*5 and 4*0 to 4. The integers 2 and 3 would be converted, on the other hand, from intervals twice as large (see figure 33). The problem can be corrected by extending the interval over which subroutine UNIFRM generates its sequence, so that each integer is converted from an interval of length 1:</span></p>
<p><span class="font48">CALL UNIFRM (0.5<sub>f</sub>4.9,RNUM,RANDOM) IRAND a IFIX(RAND0M ♦ 0.5)</span></p>
<p><span class="font48">** Random number generators that use the multiplicative congruence method guarantee the independence of only two or three sequential terms. The possible interdependence of remote terms recommends the use of separate generators for each random parameter; otherwise, a model's stochastic parameters may not be independent .</span></p>
<p><span class="font48">** If a parameter list is supposed to specify the statement number of the calling program, and if a random number must be generated Just before the call, then the statement number should be transfered to the random number generation.</span></p>
<p><span class="font48">Example:</span></p>
<p><span class="font48">* Transactions are to be generated at random. The time between generations is to be exponentially distributed, with a mean time of 100. Instead of specifying its own statement number, GENERA'a ID parameter points to the call to ERLANG.</span></p>
<p><span class="font45" style="font-weight:bold;">1 CALL ERLANG (100</span><span class="font48">1</span><span class="font45" style="font-weight:bold;">,MTN,MAX,</span><span class="font48">RNUM<sub>t</sub>RANDOM,41006) </span><span class="font45" style="font-weight:bold;">IRAND »</span><span class="font48"> IFIX(RANDOM</span><span class="font45" style="font-weight:bold;"> ♦ 0.5) CALL'GENERA (IRAND,2TX,</span><span class="font48">PR,1,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">PS* і» • </span><span class="font45" style="font-weight:bold;font-style:italic;">m</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">m</span><span class="font10"> *</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">W</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;"><a name="bookmark423"></a>w m </span><span class="font45" style="font-weight:bold;"># і</span></p>
<p><span class="font45" style="font-weight:bold;">(У 4</span></p>
<p><span class="font76" style="font-weight:bold;">I<sup>і</sup>!</span></p>
<p><span class="font45" style="font-weight:bold;">і f ft S і 71 » І -I</span></p>
<p><span class="font11">#</span></p>
<p><span class="font45" style="font-weight:bold;">в §</span></p>
<p><span class="font45" style="font-weight:bold;">• ІІ и О а</span></p>
<p><span class="font45" style="font-weight:bold;">m в Г</span></p>
<p><span class="font45" style="font-weight:bold;">* І # і •</span></p>
<p><span class="font45" style="font-weight:bold;">а *** 9</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;">m</span><span class="font45" style="font-weight:bold;"> е ft *</span></p>
<p><span class="font60" style="font-weight:bold;"><a name="bookmark424"></a>•&nbsp;</span><span class="font45" style="font-weight:bold;font-style:italic;">е%</span></p>
<p><span class="font45" style="font-weight:bold;">ô » H ІГ Ü</span></p>
<p><span class="font45" style="font-weight:bold;">О «■*</span></p>
<p><span class="font45" style="font-weight:bold;font-style:italic;"><a name="bookmark425"></a>mm m m</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;« • * |в#</span></p>
<p><span class="font45" style="font-weight:bold;">С</span><span class="font45" style="font-weight:bold;font-style:italic;"> er </span><span class="font45" style="font-weight:bold;">■ м Л</span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark426">t*&nbsp;І</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark427">9&nbsp;CT</a></span></p>
<p><span class="font45"><a href="#bookmark428"><a name="bookmark429"></a>і&nbsp;і</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark430"><a name="bookmark431"></a>0&nbsp;І </span><span class="font45"># і</span></a></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark432">1&nbsp;</span><span class="font45" style="font-weight:bold;font-style:italic;">ж</span></a></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark433"></a>■ зі * і</span></p>
<p><span class="font43" style="font-style:italic;">Щ&amp;Ґ ФЩ,</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark434"></a>о Ü</span></p>
<p><span class="font45" style="font-weight:bold;">(М</span></p>
<p><span class="font45" style="font-weight:bold;">яг НІ</span></p>
<p><span class="font84" style="font-weight:bold;">I u GATHERING 5 T A T A ö i 1 U A L DATA</span></p>
<p><span class="font45" style="font-weight:bold;">To study a model means to gather data on its performance. GPSS-F provides subroutines that help collect and display the data in convenient forms.</span></p>
<p><span class="font45" style="font-weight:bold;">10.1 Bins</span></p>
<p><span class="font45" style="font-weight:bold;">Bins collect data on the movement of transactions. Their greatest use is to study queues, which they vaguely resemble: transactions enter the bins and leave them by calling ARRIVE and DEPART. Strictly speaking, transactions don't enter the bins at all; instead they put tokens in the bins and then go on about their business. A transaction can put tokens in more than one bin (up to five at a time), and it can put any number of them in each bin. A bin keeps track of the number of tokens it now holds, the maximum number it has held, the total time they have spent there, and so forth.</span></p>
<p><span class="font45" style="font-weight:bold;">Example:</span></p>
<p><span class="font45" style="font-weight:bold;">* To study the behaviour of a queue,' simply have each transaction throw a token in a bin just as it enters the queue and fish a token back out when it leaves. A token in the bin stands for a transaction in the queue. The following sequence realizes this use of a bin to study a facility's queue:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ARRIVE CALL SEIZE CALL DEPART CALL WORK CALL CLEAR</span></p>
<p><span class="font45" style="font-weight:bold;">10.1.1 Statistics Gathered by Bins</span></p>
<p><span class="font45" style="font-weight:bold;">A bin's data are accumulated in the BIN matrix, which is: INTEGER BIN</span></p>
<p><span class="font45" style="font-weight:bold;">DIMENSION BIN(<sup>W</sup>BIN1<sup>,,</sup>,8)</span></p>
<p><span class="font45" style="font-weight:bold;">and whose fields mean:</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,1) Current volume</span></p>
<p><span class="font45" style="font-weight:bold;">This field gives the number of tokens now in the bin.</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,2) Maximum volume</span></p>
<p><span class="font45" style="font-weight:bold;">The largest number of tokens that have been in the bin at any one time is given here.</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN<sub>9</sub>3) Total arrivals</span></p>
<p><span class="font45" style="font-weight:bold;">The total number of tokens yet put In the bin (ARRIVE) is kept here.</span></p>
<p><span class="font14" style="font-weight:bold;font-variant:small-caps;">bin</span><span class="font45" style="font-weight:bold;">(NBN,4) Total departures</span></p>
<p><span class="font45" style="font-weight:bold;">And the total tokens yet removed (DEPART) Is kept here.</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN<sub>9</sub>5) Total fleeting visits</span></p>
<p><span class="font45" style="font-weight:bold;">A token that departs again at the time of its arrival counts among the bin's fleeting visitors.</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,6) Total bin time of departed tokens (procedure A)</span></p>
<p><span class="font45" style="font-weight:bold;">The total time spent in the bin by already departed tokens accumulates in this counter. Time spent by tokens still in the bin doesn't count.</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN<sub>9</sub>7) Total bin time (procedure B)</span></p>
<p><span class="font45" style="font-weight:bold;">This counter accumulates the total time spent by all tokens in the bin<sub>9</sub> including those still here.</span></p>
<p><span class="font45" style="font-weight:bold;">BIM(MBN<sub>9</sub>8) Time of the last change</span></p>
<p><span class="font45" style="font-weight:bold;">Each time a token arrives or departs, the clock's value is noted here.</span></p>
<p><span class="font45" style="font-weight:bold;">A</span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font45" style="font-weight:bold;">| TRANSACTION j NUMBER</span></p>
<p><span class="font63" style="font-weight:bold;"><a href="#bookmark435"><a name="bookmark436"></a>| *-------------------*</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark437">6 *&nbsp;f&nbsp;I</a></span></p>
<p><span class="font11"><a href="#bookmark438">ft___»_________ft_________«</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark439">5 ♦&nbsp;II</a></span></p>
<p><span class="font62" style="font-weight:bold;"><a href="#bookmark440">| •-------------«-----•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark441">4 ♦ I I | »_________»_______________»___•</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark442">3 «• I I •_____•_____________«___________*</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark443">2 ♦&nbsp;I&nbsp;I</a></span></p>
<p><span class="font62" style="font-weight:bold;"><a href="#bookmark444">| *___«___________________«_________»</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark445">1 ♦ I&nbsp;I</a></span></p>
<p><span class="font45" style="font-weight:bold;"><a href="#bookmark446">I *.................................•</a></span></p>
<p><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font11">----------------------------------------------------&gt;</span></p><div>
<p><span class="font48">FIGURE</span></p></div>
<p><span class="font45" style="font-weight:bold;">SIMULATION TIME T</span></p>
<p><span class="font48">TOTAL BIN TIME BY PROCEDURE A</span></p>
<p><span class="font45" style="font-weight:bold;">Procedure A computes each departing token's bin &quot;time and accumulates a running total in BIN(NBN,6). The departing token's bin time is the current time, minus its arrival time, which ARRIVE will have stored in the TX matrix. In figure 34, each bar represents a token's bin time. According to procedure A, the total is Just the sum of the individual token's bin times.</span></p>
<p><span class="font45" style="font-weight:bold;">Procedure B computes the total bin time per token since the last arrival or departure. It accumulates a total in BIN(NBN,7)« To do that, it multiplies the number of tokens in the bin by the elapsed time since the last computation, adding the result to the total. The bars in figure 35 represent the total bin time between changes; the grand total is the sum of their areas.</span></p>
<p><span class="font45" style="font-weight:bold;">NUMBER OF TOKENS IN THE BIN</span></p><img src="Untitled.FR10_files/Untitled.FR10-10.jpg" style="width:187pt;height:114pt;"/>
<p><span class="font45" style="font-weight:bold;">T3</span></p><div>
<p><span class="font45" style="font-weight:bold;">T4</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">T5</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">T1</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">T2</span></p></div>
<p><span class="font45" style="font-weight:bold;">TOTAL BIN TIME BY PROCEDURE B</span></p>
<p><span class="font45" style="font-weight:bold;">There are also two ways to compute the mean bin time. Procedure A considers only tokens that have already departed; it yields a reliable mean when the great majority of tokens have already left the bin. Its value is given by:</span></p>
<p><span class="font45" style="font-weight:bold;">W21 = BIN(NBN,6) / BIN(NBN,4)</span></p>
<p><span class="font45" style="font-weight:bold;">If there are many tokens still in the bin, use procedure B. It assumes that the tokens still there would have spent roughly twice as much time in the bin as they already have. It figures that the mean bin time is:</span></p><div>
<p><span class="font48">FIGURE 35</span></p></div>
<p><span class="font45" style="font-weight:bold;">W22 = 3IN(NBN,7) / ((BIN(NBN,3)+ BIN(NBN,4))/2.)</span></p>
<p><span class="font45" style="font-weight:bold;text-decoration:line-through;">y f* -</span><span class="font45" style="font-weight:bold;"> g</span><span class="font45" style="font-weight:bold;font-style:italic;"> m</span><span class="font45" style="font-weight:bold;"> </span><span class="font45" style="font-weight:bold;text-decoration:line-through;">rf</span><span class="font45" style="font-weight:bold;">»*</span><span class="font45" style="font-weight:bold;text-decoration:line-through;">» n</span><span class="font45" style="font-weight:bold;">i I</span><span class="font45" style="font-weight:bold;text-decoration:line-through;">.</span><span class="font45" style="font-weight:bold;"> fp</span><span class="font45" style="font-weight:bold;text-decoration:line-through;">n ||M</span><span class="font45" style="font-weight:bold;">I</span></p>
<p><span class="font48">by the simulation time:</span></p>
<p><span class="font47">WSL * BIN(NBN<sub>f</sub>7) / (BIN(NBN,8)-1.)</span></p>
<p><span class="font47">The bin's statistics matrix, BINSTA, keeps two mean values: mean bin time (procedure B) and mean bin volume. It is defined:</span></p>
<p><span class="font47">REAL BINSTA</span></p>
<p><span class="font47">DIMENSION BINSTA(&quot;BIN t * <sub>f</sub> 2 )</span></p>
<p><span class="font47">Its field contain:</span></p>
<p><span class="font47">BINSTA(NBN,1) Mean bin time, WZ2</span></p>
<p><span class="font47">BINSTA(NBN,2) Mean bin volume, WSL</span></p>
<p><span class="font47">Notes:</span></p>
<p><span class="font47">*&nbsp;A bin can keep account of any set of durations, whether waiting time in a queue, service time at a facility or shelf time at a storage. A transaction's representative tokens remain in the bin from the moment it deposits them till whatever time it removes them, from its CALL ARRIVE to its CALL DEPART.</span></p>
<p><span class="font47">*&nbsp;Each transaction should remove exactly as many tokens from the bin as it deposits, otherwise, the algorithms used to gather statistics will give false results.</span></p>
<p><span class="font47">*&nbsp;Subroutine REPORT (see 10.3.1) prints the contents of the BIN and BINSTA matrices.</span></p>
<p><span class="font47">10.1.2 ARRIVE Purpose:</span></p>
<p><span class="font47">This subroutine modifies the BIN matrix to reflect the arrival of tokens in a bin.</span></p>
<p><span class="font47">Calling sequence:</span></p>
<p><span class="font47">CALL ARRIVE (NBN,NE,41006 <sub>f</sub>IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters :</span></p>
<p><span class="font45" style="font-weight:bold;">NBN&nbsp;Bin number</span></p>
<p><span class="font45" style="font-weight:bold;">Sequential numbers identify the bins.</span></p>
<p><span class="font45" style="font-weight:bold;">NE&nbsp;Number of arriving tokens</span></p>
<p><span class="font45" style="font-weight:bold;">This number of tokens arrives at the bin.</span></p>
<p><span class="font45" style="font-weight:bold;">&amp; 1006 Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">A transaction may put tokens in up to five bins at a time. If it tries to put tokens in a sixth, the subroutine takes this exit.</span></p>
<p><span class="font45" style="font-weight:bold;">I PR I NT Trace control&nbsp;-</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IRPTNT=0.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark447"></a>Data area:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark448"></a>ARRIVE uses the BIN matrix and the TX matrix.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark449"></a>Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark450"></a>&quot;Error control&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I s 9 , 13 IF(TX(LTX,I).EQ.O) GOTO 200 100 CONTINUE RETURN 1</span></p>
<p><span class="font47">If the fields TX(LTX<sub>f</sub>9) to TX(LTX,13) are already filled, the calling transaction has already put tokens in five bins. The programm returns via its error exit.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the TX matrix&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">200 TX(LTX,I) = NBN TX(LTX,1+5) = T</span></p>
<p><span class="font45" style="font-weight:bold;">The tokens' arrival time and bin number are set in the .transaction matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Set the BIN matrix&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,7) = BIN(NBN,7) ♦ BIN(NBN,1) • (T - BIN(NBN,8)) BIN(NBN,8) = T</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,1) = BIN(NBN,1 ) ♦ NE</span></p>
<p><span class="font45" style="font-weight:bold;">IF(BIN(NBN,2).LT.BIN(NBN,1) ) BIN(NBN,2) r BIN(NBN, 1)</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,3) = BIN(NBN,3) + NE</span></p>
<p><span class="font45" style="font-weight:bold;">RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">We first compute the total bin time of all tokens since the last change (procedure B) accumulating the result in RIN(NBN,7). Then we reset the time of the last change (BIN(NBN,8)). Finally, we update the current volume, total arrivals and, if need be, the maximum volume.</span></p>
<p><span class="font45" style="font-weight:bold;">10.1.3 DEPART</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:&nbsp;&quot;vy*</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine modifies the BIN and BINSTA matrices to reflect the departure of tokens from a bin.</span></p>
<p><span class="font48">Calling sequence:</span></p>
<p><span class="font48">CALL DEPART (NBH,NE,41006,IPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Bin number</span></p>
<p><span class="font45" style="font-weight:bold;">Sequential numbers identify the bins. Number of departing tokens This number of tokens departs from the bin. Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">If a transaction tries to withdraw tokens somewhere where it didn't deposit any, the subroutine takes this exit. It takes it too, if the transaction tries to withdraw more tokens than there are in the bin. Trace control-</span></p>
<p><span class="font45" style="font-weight:bold;">Trace printouts are suppressed when IPRINTsO.</span></p><div>
<p><span class="font45" style="font-weight:bold;">NBN</span></p>
<p><span class="font45" style="font-weight:bold;">NE</span></p>
<p><span class="font16" style="font-weight:bold;">61006</span></p>
<p><span class="font45" style="font-weight:bold;">IPRINT</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p></div>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">DEPART uses the TX matrix, the clock and the area COMMON/BIN/. Algorithm description: ••Error control&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 1=9,13 IF(TX(LTX<sub>f</sub>I).EQ.NBN) GOTO 200 100 CONTINUE RETURN 1</span></p>
<p><span class="font45" style="font-weight:bold;">If the bin's number isn't in the calling transaction's data area, DEPART returns via its error exit.</span></p>
<p><span class="font45" style="font-weight:bold;">••Clear the bin from the caller's entry<sup>11</sup></span></p>
<p><span class="font45" style="font-weight:bold;">200 IF(BIN(NBN,1).LT.NE) GOTO 500 INBIN s TX(LTX,1+5) TX(LTX,I) s 0 TX(LTX,I+5) = 0</span></p>
<p><span class="font45" style="font-weight:bold;">DEPART also takes the error exit if there aren't enough tokens in the bin to cover the withdrawal. If the calling transaction clears these hurdles, the bin's number and entry time are removed from its data area.</span></p>
<p><span class="font45" style="font-weight:bold;">••Set the BIN matrix&quot;</span></p>
<p><span class="font3">#</span></p>
<p><span class="font48">| BIN (NBfJ, 7) = BIM(NBN,7) ♦ BIfJ(NBN, 1) ■ (T - BIN</span><span class="font45" style="font-weight:bold;">(MBM,8)) </span><span class="font48">Biff(NBN,8) = T BIM(NBN,1) | BIN(NBN,1) | MR BIN (NBN, jj|ff = BIN(NBN.U) jg NE IF(INBIN.EQ.T) GOTO 300</span></p>
<p><span class="font48">BIN</span><span class="font45" style="font-weight:bold;">(NBN,</span><span class="font48">6</span><span class="font45" style="font-weight:bold;">) I</span><span class="font48"> BIN(NBN,6) | (T - INBIN) | NE GOTO iiOO</span></p>
<p><span class="font48">300 BIN(NBN15 ) = BIN(NBN,5) | NE</span></p>
<p><span class="font45" style="font-weight:bold;">We first compute the total bin time of all tokens</span><span class="font48"> 3ince the </span><span class="font45" style="font-weight:bold;">last change (procedure</span><span class="font48"> B)</span><span class="font45" style="font-weight:bold;"> accumulating the result in</span><span class="font48"> BIN(NBN,7&gt;. </span><span class="font45" style="font-weight:bold;">Then we reset the.time of the last change (</span><span class="font48">BIM(N8N,8)). Finally,</span></p>
<p><span class="font47">we</span><span class="font45" style="font-weight:bold;"> update the current volume<sub>9</sub> total departures<sub>9</sub> total bin time (procedure A) <sub>9</sub> and, if need be<sub>9</sub> the total of fleeting visits.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute the mean values&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">400 IF(T.E0.1) GOTO 150</span></p>
<p><span class="font45" style="font-weight:bold;">BINSTA(NBN<sub>9</sub>1) s BIN(NBN<sub>f</sub>7) / ((BIN(NBN<sub>9</sub>3)+BIH(NBN<sub>9</sub>4))/2.) BINSTA(NBN<sub>9</sub>2) S BIN(NBN<sub>9</sub>7) / (BIN(NBN<sub>f</sub>8) - 1.) 450 RETURN 500 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">We set the new mean values in the BINSTA matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">10.1.4 ENDBIN Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">At the end of simulation, ENDBIN completes fields in the BIN and BINSTA matrices. A call to ENDBIN is built into the chassis.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:&nbsp;.</span></p>
<p><span class="font45" style="font-weight:bold;">CALL ENDBIN</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">ENDBIN uses the clock and COMMON/BIN/.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Complete the bin's data&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 NBN * 1 <sub>9</sub> &quot;BIN1&quot; rF(BIN(NBN<sub>f</sub>3)-EQ.0) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">BIN(NBN,7) = BIN(NBN,7) ♦ BIN(NBN<sub>t</sub>1) « (T - BIN(NBN,8)) BIN(NBN<sub>9</sub>8) r T</span></p>
<p><span class="font45" style="font-weight:bold;">The routine computes the bin time (procedure B) since the last change and adds it to the total in BIN(NBN,7) • Then it sets the current time as the time of the last change.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute the mean values&quot; IF(T.EQ.1) GOTO 100</span></p>
<p><span class="font45" style="font-weight:bold;">BINSTA (NBN <sub>f</sub> 1 ) = BIN(NBN<sub>9</sub>7) / ( (BIN(NBN, 3) ♦ BIN(NBN<sub>9</sub>4)) / BINSTA(NBN,2) * BIN(NBN<sub>f</sub> 7) / (BIN(NBN,8) - 1.) 100 CONTINUE RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">Finally it sets the new mean values In the BINSTA matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">many siuaenis scorea uevweeu yu anu ivw, vwwvcu uv auu <sub>9</sub> ana 30 forth. The table could be In absolute numbers of students, or in percentages of the total class* GPSS-F provides orograms to collect a frequency table of simulation data (TABULA), to evaluate and print the table (EVALUE) and to print a bar chart of the table (GRAPH).</span></p>
<p><span class="font45" style="font-weight:bold;">In addition to collecting data in a frequency table, TABULA can accumulate correlated sums. The sums are then used to compute mean values by category, e.g, mean income by educational level or mean down time by age of component*</span></p>
<p><span class="font45" style="font-weight:bold;">10.2.1 TABULA Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">A call to TABULA tabulates one datum in a frequency table. Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL TABULA (X,Y,0G1,GBR,NG,TAB) Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">X&nbsp;Principal datum</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine keeps a frequency table for this variable Y&nbsp;Correlated datum</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine accumulates the sum of this variable separately for each interval in the frequency table. 0G1 Upper boundary of the first interval</span></p>
<p><span class="font45" style="font-weight:bold;">The table's domain is divided into equal intervals. The upper boundary of the first interval is given here. GBR Interval length</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter tells how long each interval is. NG&nbsp;Number of intervals</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter gives the number of intervals in the table. It may not be larger than the table's first dimension .</span></p>
<p><span class="font45" style="font-weight:bold;">TAB Frequency table</span></p>
<p><span class="font45" style="font-weight:bold;">The table to be used is passed to TABULA by coding its Fortran name.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font48">TABULA</span><span class="font45" style="font-weight:bold;"> uses a matrix defined by the user in wich it accumulates a frequency table. We refer to the table by the dummy name of</span><span class="font48"> TAB:</span></p>
<p><span class="font48">REAL TAB</span></p>
<p><span class="font48">DIMENSION TAB(&quot;TAB1<sup>M</sup>,4)</span></p>
<p><span class="font45" style="font-weight:bold;">TABlJfU Upper boundary of the Jth interval</span></p>
<p><span class="font45" style="font-weight:bold;">TABULA seta up the table by filling in the upper boundary of each interval. The intervals are open on the left and closed on the right.</span></p>
<p><span class="font45" style="font-weight:bold;">TAB(J,2) Absolute frequency&nbsp;*</span></p>
<p><span class="font45" style="font-weight:bold;">The count of X falling in the Jth interval is kept here.</span></p>
<p><span class="font45" style="font-weight:bold;">TAB(J,3) Relative frequency</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine EVALUE enters the percentage of X falling in the Jth interval in this field.</span></p>
<p><span class="font45" style="font-weight:bold;">TAB(J<sub>f</sub>4) Values of the correlated variables</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine TABULA keeps sums of the Ys for each interval of the Xs: if X falls In the Jth interval, it adds Y to the sum already in TAB(J<sub>t</sub>4).</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description: ••Set up the frequency table*</span></p>
<p><span class="font79">•</span></p>
<p><span class="font45" style="font-weight:bold;">IF(NG.GT.&quot;TAB1&quot;) NG = &quot;TAB1&quot; IF(TAB(1,1).NE.O.OR.TAB(2,1).NE.O) GOTO 50 G s 0G1</span></p>
<p><span class="font45" style="font-weight:bold;">DO 10 J : 1 , NG ?AB(.J,1) = G 10 G = G ♦ GBR</span></p>
<p><span class="font45" style="font-weight:bold;">If the number of intervals, TIG, outruns the size of the frequency table, TABULA tries to avert disaster by resetting NG. Then if it hasn't already initialized the table,,it runs through the array, setting the upper boundary for each interval.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Tabulate the data&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">50 DO 100 J s 1 , NG</span></p>
<p><span class="font45" style="font-weight:bold;">IF(X.LE.TAB(J,1)) GOTO 150 100 CONTINUE J — NG</span></p>
<p><span class="font45" style="font-weight:bold;">150 TAB(J,2) = TABU,2) ♦ 1 TABU,4) = TAB(J,4) ♦ Y RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine finds the interval where X falls, raising the count for that interval and accumulating the sum of the Ys. Any data too large or too small for the table get lumped into the rightmost or leftmost intervals.</span></p>
<p><span class="font48">Notes:</span></p>
<p><span class="font48">• The data gathered</span><span class="font45" style="font-weight:bold;"> in a frequency table (X and Y) must be of </span><span class="font48">type REAL; the</span><span class="font45" style="font-weight:bold;"> user must convert any INTEGER data he wants to </span><span class="font48">tabulate.</span></p>
<p><span class="font37" style="font-weight:bold;">jODS</span><span class="font45" style="font-weight:bold;"> enverrxng</span><span class="font37" style="font-weight:bold;"> a</span><span class="font45" style="font-weight:bold;"> uumpubcr</span><span class="font37" style="font-weight:bold;"> o/avcnii rwr any&nbsp;Hcrxuu</span><span class="font45" style="font-weight:bold;"> ,</span><span class="font37" style="font-weight:bold;"> vn«r mean</span></p>
<p><span class="font45" style="font-weight:bold;">is the total turnaround time devided by the number of jobs. We can get a better picture of the mean turnaround if we break the day into one-hour intervals and compute the mean separately for each of them. For each job<sub>9</sub> we let X be the time it entered the computer and Y be its turnaround time. These data we tabulate in a frequency table with</span><span class="font39" style="font-style:italic;"> 2k</span><span class="font45" style="font-weight:bold;"> intervals, each an hour long. At the end of the day we divide TAB(Jby TAB(J,2) to find the mean turnaround for jobs entered during the Jth hour. This is done automatically by EVALUE when it prints out the table.</span></p>
<p><span class="font45" style="font-weight:bold;">10.2.2 EVALUE Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine evaluates and prints a frequency table whose data TABULA has gathered.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling Sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL EVALUE (NG,TAB,NTAB,JPRINT)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NG&nbsp;Number of intervals</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter should specify the same number of intervals as it did for TABULA. TAB Frequency table</span></p>
<p><span class="font45" style="font-weight:bold;">Pass the table to EVALUE by coding its Fortran name here. NTAB Table identifier</span></p>
<p><span class="font45" style="font-weight:bold;">To identify the table, EVALUE prints this integer in a heading. JPRINT Print control</span></p>
<p><span class="font45" style="font-weight:bold;">If J is 1, EVALUE prints both the table and its computed distributions; if J is 0, it prints only the distributions.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">EVALUE uses a frequency table.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Initialize the variables&quot;</span></p>
<p><span class="font4">XQU = 0.</span></p>
<p><span class="font4">VAR si 0.</span></p>
<p><span class="font4">SDV 25 o.</span></p>
<p><span class="font45" style="font-weight:bold;">SUMF = 0.</span></p>
<p><span class="font4">SUMX 25 0.</span></p>
<p><span class="font4">SUMXQ 25 0.</span></p>
<p><span class="font4">GBR = TAB(2,1) - TAB(1,1)</span></p>
<p><span class="font4">GM = TAB(1,1) - GBR / 2.</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine Initializes the variables it uses to hold in« termediate values. It will use SUMP to sum the entire population of data<sub>9</sub> SUMX to sum the product of the midpoint (GM) of each in* terval with the number of data that fell on the interval, and SUMXQ to sum the square of each midpoint with the interval's population of data.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;First pass through the table&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 500 1st, NG F s TAB(I,2) SUMF = SUMF ♦ F SUMX s SUMX ♦ F • CM SUMXQ s SUMXQ ♦ F • GM • GM 500 GM s GM + GBR</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine accumulates SUMF, SUMX and SUMXQ, recomputing the midpoint (GM) as it goes.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Second pass through the table&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SUMF.EQ.O) GOTO 700 DO 600 I s 1 , NG TAB(I,3) * TAB(I,2) / SUMF</span></p>
<p><span class="font45" style="font-weight:bold;">IF(TAB(I,2).NE.O) TABX(I) = TAB(I,4) / TAB(I,2) 600 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">Then it computes the relative frequency for each interval and the means of the correlated data (Y).</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute mean value, variance and standard deviation&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">XQU r SUMX / SUMF IF(SUMF.EQ.1•) VAR * 0.</span></p>
<p><span class="font45" style="font-weight:bold;">IF(SUMF.NE.1.) VAR = (SUMXQ-SUMX»SUMX/SUMF)/(SUMF-1) SDV s SQRT(VAR)</span></p>
<p><span class="font45" style="font-weight:bold;">Finally, it computes the mean of the data (XQU), their variance (VAR) and their standard deviation (SDV). The variance is given by:</span></p>
<p><span class="font1">%</span></p>
<p><span class="font45" style="font-weight:bold;">N .&nbsp;N</span></p>
<p><span class="font45" style="font-weight:bold;">SIGMA**2=1/(N-1)*( &gt; X(i)««2-1/M*( &gt; X(i))**2)</span></p>
<p><span class="font33">••</span><span class="font0" style="font-style:italic;">&nbsp;m* mm</span></p>
<p><span class="font45" style="font-weight:bold;">1=1 i=1</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Print the results&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">700 IF(JPR INT.GT.0) WRITE (&quot;0UTD&quot;,3000)</span></p>
<p><span class="font45" style="font-weight:bold;">3000&nbsp;FORMAT(1H1)</span></p>
<p><span class="font45" style="font-weight:bold;">WRITE(&quot;0UTD&quot;,3001) NTAB</span></p>
<p><span class="font45" style="font-weight:bold;">3001&nbsp;FORMAT(1H0,15X , 5HTABLE,13/)&nbsp;i IF(JPRINT.E0.0) GOTO 900 WRITE(&quot;OUTD&quot;,3002)</span></p>
<p><span class="font57" style="font-weight:bold;">3002&nbsp;FORMAT( 3X<sub>1</sub>1 HI <sub>1</sub>12X, 1</span><span class="font48" style="font-variant:small-caps;">hx &gt;</span><span class="font57" style="font-weight:bold;"> 13X, *»HP&lt;</span><span class="font48" style="font-variant:small-caps;">x</span><span class="font57" style="font-weight:bold;"> ) , 10X <sub>1</sub>3HF/H <sub>f </sub>♦11X<sub>9</sub>4HCUMY<sub>9</sub>11X<sub>f</sub>4HE(Y)/)</span></p>
<p><span class="font57" style="font-weight:bold;">DO 800 I « 1 » NG IF(TAB(I,2).EQ.O) COTO 800</span></p>
<p><span class="font57" style="font-weight:bold;">WRITE(&quot;OUTD&quot; ,3003) I<sub>f</sub> (TAB(I <sub>f</sub> J) <sub>9</sub> Js1<sub>9</sub>1|) <sub>9</sub>TABX(I)</span></p>
<p><span class="font57" style="font-weight:bold;">3003&nbsp;F0RMATOX<sub>9</sub>I3,3(5X<sub>9</sub>F10.3)<sub>f</sub>5X<sub>9</sub>E10.3,5X<sub>f</sub>F10.3)</span></p>
<p><span class="font57" style="font-weight:bold;">800 CONTINUE&nbsp;«</span></p>
<p><span class="font57" style="font-weight:bold;">900 WRITE ( &quot;OUTD&quot;<sub>9</sub> 3004 ) SUMF <sub>f</sub> XQU <sub>9</sub> VAR <sub>9</sub> SDV</span></p>
<p><span class="font57" style="font-weight:bold;">3004&nbsp;P0RMAT(/2X<sub>9</sub>6H SUMF</span><span class="font48" style="font-variant:small-caps;">s</span><span class="font57" style="font-weight:bold;"><sub>9</sub>F10.1<sub>t</sub>2X<sub>f</sub>5H XQU</span><span class="font48" style="font-variant:small-caps;">s</span><span class="font57" style="font-weight:bold;"><sub>f</sub>F10.2<sub>9</sub>2X<sub>9</sub>5H</span><span class="font45" style="font-weight:bold;"> VARr<sub>t </span><span class="font57" style="font-weight:bold;"></sub>♦F10.2<sub>9</sub>2X<sub>9</sub>5H SDVs<sub>f</sub>F10.2//)</span></p>
<p><span class="font57" style="font-weight:bold;">RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">EVALUE prints the table, if called for<sub>t</sub> plus the means of the </span><span class="font57" style="font-weight:bold;">Y</span><span class="font48" style="font-variant:small-caps;">s</span><span class="font45" style="font-weight:bold;"><sub>9</sub> followed by the statistical data.</span></p>
<p><span class="font45" style="font-weight:bold;">10.2.3 GRAPH Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine prints a histogram of either the absolute or relative frequencies from a table.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL GRAPH (TAB<sub>9</sub>NTAB<sub>9</sub>IU<sub>9</sub>I0<sub>9</sub>Y,&amp;1006)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Frequency table</span></p>
<p><span class="font45" style="font-weight:bold;">Pass the table to GRAPH by coding its Fortran name here. Table identifier</span></p>
<p><span class="font45" style="font-weight:bold;">To identify the histogram, GRAPH prints this integer in a heading.</span></p>
<p><span class="font45" style="font-weight:bold;">Number of the leftmost interval GRAPH can print any portion of starts with this interval on the Number of the rightmost interval</span></p>
<p><span class="font45" style="font-weight:bold;">This will be the rightmost interval in the histogram. Mode</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter chooses between a histogram in absolute or in relative frequencies.</span></p>
<p><span class="font45" style="font-weight:bold;">Y&nbsp;s 0 relative frequency</span></p>
<p><span class="font45" style="font-weight:bold;">Y&nbsp;s 1 absolute frequency Error exit</span></p>
<p><span class="font45" style="font-weight:bold;">If GRAPH is asked to print fewer than 5 intervals or more than 100. it takes this exit.</span></p><div>
<p><span class="font57" style="font-weight:bold;">TAB NTAB</span></p>
<p><span class="font45" style="font-weight:bold;">1U</span></p>
<p><span class="font45" style="font-weight:bold;">10 Y</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">a frequency table; left.</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">it</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">41006</span></p></div>
<p><span class="font45" style="font-weight:bold;">a area:</span></p><div>
<p><span class="font45" style="font-weight:bold;">Dat</span></p></div>
<p><span class="font45" style="font-weight:bold;">GRAPH uses a frequency table.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark451"></a>Algorithm descriptions</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark452"></a>&quot;Error check&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark453"></a>IF(I0-IU.GT.99.0R.IO-IU.LT.*) GOTO 900</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark454"></a>If the Intervals were badly chosen, GRAPH returns via its error exit.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark455"></a>&quot;Initialize the variables&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">DO 1 I s 1 , 100 M(I) s 0.</span></p>
<p><span class="font45" style="font-weight:bold;">1&nbsp;LINE(I) r KBLANC</span></p>
<p><span class="font45" style="font-weight:bold;">INT * 100 / (10 - IU ♦ 1) INT1 s 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(INT.EQ.1) GOTO 2 INT1 s INT / 2 INT2 s INT1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(INTUINT2.LT.INT) INT1 = INT1 ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">2&nbsp;MAX = 0.&nbsp;.</span></p>
<p><span class="font45" style="font-weight:bold;">H will show the top of each histogram column, one value for each interval on the X axis; LINE will be used to build each line of print; INT shows the width of each interval; MAX will show the height of the tallest column.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Find the tops of the columns&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">11 s 0</span></p>
<p><span class="font45" style="font-weight:bold;">IP(Y.GT.O) GOTO 5 SUM = 0.</span></p>
<p><span class="font45" style="font-weight:bold;">DO 3 I = 1 <sub>9</sub>&quot;TAB1&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">3&nbsp;SUM s SUfl ♦ TAB(I,2) 5 DO 50 I = IU , 10</span></p>
<p><span class="font45" style="font-weight:bold;">II s IU 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(Y.GT.O)</span><span class="font31"> rt</span><span class="font45" style="font-weight:bold;">(I1) s TAB( 1,2) IF(Y.EQ.O) M(ID = TAB( 1,2) / SUM • 100. IF(M(I1).GT.MAX) MAX r M(I1) IF(INT.EQ.1) GOTO 50 IF(INT1.EQ.1) GOTO 20 DO 10 12 = 2 INT1 It s It 10 M(I1) s ?!(11-1 ) 20 11 s 11 ♦ INT2 50 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine sets M for each interval and determines how wide the columns are to be and how much space to put between then.</span></p>
<p><span class="font48">&quot;Scale</span><span class="font45" style="font-weight:bold;"> the frequency axis<sup>99</sup></span></p>
<p><span class="font45" style="font-weight:bold;">IND * 0</span></p>
<p><span class="font48">If!</span><span class="font45" style="font-weight:bold;"> AX = MAX</span></p>
<p><span class="font45" style="font-weight:bold;">DO 60 1*1, 20</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark456"></a>IF(IMAX.LT. 10.0R. IMAX. BQ. 10. AND. MAX. EQ. 10**(IND4-1 )) &quot; +G0T0 70</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark457"></a>IND « IND ♦ 1 IMAX » IMAX / 10 60 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark458"></a>70 IF(MAX.GT.IMAX*10**IND) IMAX s IMAX ♦ 1 YMAX</span><span class="font43"> S</span><span class="font45" style="font-weight:bold;"> IMAX • 10. •• IND</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark459"></a>IF(IMAX.LE.5.AND.YMAX.GT.10) IMAX s IMAX • 2</span></p>
<p><span class="font23">/</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark460"></a>MAX determines the scaling used on the frequency axis: the highest value on that axis is saved in YMAX.</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark461"></a>&quot;Print a title for the Graph&quot;</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark462"></a>100 WRITE(&quot;OUTD&quot;,3000) NTAB</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark463"></a>3000&nbsp;FORMAT( ÎH1 , 15X ,6HTABLE, 13//) IF(y.EQ.O) WRITE(&quot;OUTD&quot;,3001)</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark464"></a>3001&nbsp;FORMAT(4X,7HPERCENT)</span></p>
<p><span class="font45" style="font-weight:bold;"><a name="bookmark465"></a>&quot;Print the histogram columns&quot;</span></p>
<table border="1">
<tr><td>
<p><span class="font45" style="font-weight:bold;">I NT Y =</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">50</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">MODULI</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">= MOD(50,IMAX)</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">INTY =</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">INTY - MODULI</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">YVALL :</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">: YMAX / INTY</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">YCORR =</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">: YVALL / 1000.</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">INTB =</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">INTY / IMAX</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">J = 0</span></p></td><td>
<p></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">DO 150</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">1=1, INTY</span></p></td></tr>
<tr><td>
<p><span class="font45" style="font-weight:bold;">DO 120</span></p></td><td>
<p><span class="font45" style="font-weight:bold;">11 = 1 , 100</span></p></td></tr>
</table>
<p><span class="font48">IF(LINE(I1).NE.KBLANC) GOTO 120 IF(M(11 )+YC0RR.GE.YMAX) LINE(I1) = KSTERN 120 CONTINUE J = J ♦ 1</span></p>
<p><span class="font48">IF(J.GT.1) GOTO 130 IMAX = IFIX(YMAX ♦ 0.5)</span></p>
<p><span class="font48">WRITE(&quot;OUTD&quot;,3002) IMAX,(LINECl 1) , IЫ,100)</span></p>
<p><span class="font48">3002&nbsp;FORMAT(1X,110,2H I,100A1) GOTO 140</span></p>
<p><span class="font48"><a name="bookmark466"></a>130</span><span class="font45" style="font-weight:bold;"> WRITE(&quot;OUTD&quot;,</span><span class="font48">3003)</span><span class="font45" style="font-weight:bold;"> (LINE(II),</span><span class="font48">11 = 1,100)</span></p>
<p><span class="font48">3003&nbsp;FORMAT(12X,1HI,100A 1) 140 YMAX = YMAX - YVALL</span></p>
<p><span class="font48">IF(J.EQ.INTB) J = 0 150 CONTINUE</span></p>
<p><span class="font48">The subroutine builds</span><span class="font45" style="font-weight:bold;"> each line and prints It, marking the </span><span class="font48">frequency axis every ten</span><span class="font45" style="font-weight:bold;"> lines.</span></p>
<p><span class="font48">&quot;Print the X axis&quot;</span></p>
<p><span class="font48">IPL = INT 1 MULT = 1</span></p>
<p><span class="font48">IF(INT.GT.1.AND.INT.LT.11) MULT = 4 </span><span class="font45" style="font-weight:bold;">IF(INT.EQ.I)</span><span class="font48"> MULT = 9 DO</span><span class="font45"> 170</span><span class="font48"> 1=1, 100 IF(I.EQ.IPL) GOTO 160</span></p>
<p><span class="font45" style="font-weight:bold;">LINE(I) « KSTR СОТО 170 160 LINE(I) « KPL</span></p>
<p><span class="font45" style="font-weight:bold;">IPL x IPL ♦ MULT • INT</span></p>
<p><span class="font45" style="font-weight:bold;">IP(MULT.EQ.4.OR.MULT.EQ.9) MULT s MULT «■ 1 170 CONTINUE</span></p>
<p><span class="font45" style="font-weight:bold;">lfRITE(&quot;OUTD&quot;,3004) (LINE(I1),I1s1,100) 3004 FORMAT(1OX,3H0 I.100A1) IS = 16 - INT IF(INT.EQ.14) IS = 3 IF(INT.EQ.16) IS s 2 IF(INT.EQ.20) IS s 1 DO 180 I s 1 , 7 180 IFORM(I) s IF0RM1(I,IS) IB : It) 4 1 IS = 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(INT.GT.10) GOTO 190 IF(INT.GT.1) IS s 5 IF(INT.EQ.I) IS s 10 IB s 10 + IS - 1 190 WRITE(&quot;0UTD&quot;,IF0RM) TAB( IU, 1) , (TAB( 1,1) , I = IB, 10, IS) RETURN</span></p>
<p><span class="font5">•</span></p>
<p><span class="font45" style="font-weight:bold;">First we figure out where to mark the X axis with a&nbsp;Then</span></p>
<p><span class="font45" style="font-weight:bold;">we use the values from TAB(I<sub>9</sub>1) to print the values of the marks.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Error exit&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">900 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">Subroutine GRAPH returns via this exit when error detected erroneous parameters.</span></p>
<p><span class="font45" style="font-weight:bold;">10.3- Report of the System's State</span></p>
<p><span class="font45" style="font-weight:bold;">GPSS-F provides three subroutines to print out data areas: REPORT for the main ones<sub>9</sub> SMLIST for the storage's areas, and SELIST for the multifacllities'</span></p>
<p><span class="font45" style="font-weight:bold;">10.3.1 REPORT Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">REPORT prints the contents of the BIN matrix, the BINSTA matrix, the FAC matrix, the MFAC matrix, the STO matrix, the event list, the activation list, the TX matrix and the FAM matrix.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL REPORT (IBIN,IFAC,IMFAC,ISTO,IEL,IAL,ITf, IFAM)</span></p><div>
<p><span class="font45" style="font-weight:bold;">control has</span></p></div><div>
<p><span class="font45" style="font-weight:bold;">the system's addressible areas.</span></p></div>
<p><span class="font45" style="font-weight:bold;">ZU!&gt;</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">The parameters specify how many lines from each area are to be printed. Free lines are neither printed, nor do they count toward the total.</span></p>
<p><span class="font45" style="font-weight:bold;">TBIN&nbsp;bins</span></p>
<p><span class="font45" style="font-weight:bold;">IFAC&nbsp;facilities</span></p>
<p><span class="font45" style="font-weight:bold;">IMFAC&nbsp;multlfacilities</span></p>
<p><span class="font45" style="font-weight:bold;">ISTO&nbsp;storages</span></p>
<p><span class="font45" style="font-weight:bold;">ICL&nbsp;event list</span></p>
<p><span class="font45" style="font-weight:bold;">IAL&nbsp;activation list</span></p>
<p><span class="font45" style="font-weight:bold;">ITX&nbsp;transactions</span></p>
<p><span class="font45" style="font-weight:bold;">IFAM&nbsp;families</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm description:</span></p>
<p><span class="font45" style="font-weight:bold;">(See listing in Appendix A5)</span></p>
<p><span class="font45" style="font-weight:bold;">10.3.2 SMLIST Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">SMLIST prints a storage's section of the segment matrix, skipping blank lines.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SMLIST (NST)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">NST Storage number</span></p>
<p><span class="font45" style="font-weight:bold;">SMLIST prints the section of the segment matrix belonging to the addressible storage whose type number is NST.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SMLIST uses the SBV vector, the STO matrix and the SM matrix. Algorithm description: &quot;Print the SM matrix&quot;</span></p>
<p><span class="font48">WRITE(&quot;OUTD&quot;,3000) NST</span></p>
<p><span class="font48">3000&nbsp;FORMAT(1H0 <sub>t</sub>27HS M</span><span class="font45" style="font-weight:bold;"> MATRIX:</span><span class="font48"> STORAGE,13</span><span class="font45" style="font-weight:bold;">,/^X,29HLINE </span><span class="font48">♦ ADDRESS SEGLEN CODE)</span></p>
<p><span class="font48">I r SBV(NST) </span><span class="font45" style="font-weight:bold;">IB</span><span class="font48"> s I 4 ST0(NST,2) - 1 10 IADDR = I - SBV(NST) ♦ 1</span></p>
<p><span class="font48">WRITE(&quot;OUTD&quot;,3001)1,IADDR,SM(1,1),SM(1,2)</span></p>
<p><span class="font48">3001&nbsp;FORMAT(5X,14,4X,14,5X,IM,&amp;X,1*0 I s I ♦ SM(I,1)</span></p>
<p><span class="font48">IF(I.LE.IE) GOTO 10 WRITE(&quot;0UTD&quot;,3002)</span></p>
<p><span class="font45" style="font-weight:bold;">3</span><span class="font39" style="font-style:italic;">002</span><span class="font45" style="font-weight:bold;"> FORMAT(IHO) RETURN END</span></p>
<p><span class="font45" style="font-weight:bold;">After it has found the first and last lines of the section, SMLIST prints each segment's address, length and code.</span></p>
<p><span class="font45" style="font-weight:bold;">10.3.3 SELIST Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">SELIST prints a multifacility's section of the SE matrix, skipping blank lines.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SELIST (MFA)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">MFA Multifacility number</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine prints the section of the matrix belonging to the multifacility whose type number is MFA.</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SELIST uses the flBV vector, the MFAC matrix and the SE matrix. Algorithm description: •Print the SE matrix*</span></p>
<p><span class="font45" style="font-weight:bold;">WRITE(&quot;OUTD&quot;,3000) MFA</span></p>
<p><span class="font45" style="font-weight:bold;">3000&nbsp;FORMAT(1H0,24HS E MATRIX: MFAC,13,//MX, ♦30HLINE ELEM C0NT PRC PHASE)</span></p>
<p><span class="font45" style="font-weight:bold;">11&nbsp;= MBV(MFA)</span></p>
<p><span class="font45" style="font-weight:bold;">12&nbsp;= 11 ♦ MFAC(MFA,2) - 1</span></p>
<p><span class="font45" style="font-weight:bold;">13&nbsp;= 1</span></p>
<p><span class="font45" style="font-weight:bold;">DO 100 I = II , 12</span></p>
<p><span class="font45" style="font-weight:bold;">WRITE(&quot;OUTD&quot;,3001) 1,13,(SE(I,J),Js1,3)</span></p>
<p><span class="font45" style="font-weight:bold;">3001&nbsp;F0RMAT(6X,I3,3X,3(I3,2X),17) 100 13 « 13 ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">WRITE(&quot;OUTD&quot;,3002)</span></p>
<p><span class="font45" style="font-weight:bold;">3002&nbsp;F0RMATOH0) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">END</span></p>
<p><span class="font45" style="font-weight:bold;">After it has found the first and last lines of the multifacil-ity's section, SELIST prints each service element's number, occupation code, preemption code and service phase.</span></p>
<p><span class="font45" style="font-weight:bold;">.10.4 Saving the System 'a State</span></p>
<p><span class="font45" style="font-weight:bold;">Longer simulations can be Interrupted and started up again wherever they left off. This feature lets a user check intermediate results at any stage of simulation or break a very long simulation into manageable chunks. Subroutines SAVE and C0NT implement the feature by saving and restoring (on command) GPSS-F's data areas. The user must&quot;write his own subroutines to save and restore his own variables and data areas.</span></p>
<p><span class="font45" style="font-weight:bold;">10.1.1&nbsp;SAVE Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine writes all of GPSS-F's data areas on a file whose logical device number is &quot;SAVO&quot;. •</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SAVE</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">SAVE uses every area known to GPSS-F.</span></p>
<p><span class="font45" style="font-weight:bold;">Algorithm desctiption:</span></p>
<p><span class="font45" style="font-weight:bold;">(See listing in Appendix A5).</span></p>
<p><span class="font45" style="font-weight:bold;">Note:</span></p>
<p><span class="font45" style="font-weight:bold;">* The user must write a subroutine to save his own data areas <sub>9 </sub>e.g. frequency tables.</span></p>
<p><span class="font45" style="font-weight:bold;">10.4.2&nbsp;CONT Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">This subroutine restores all of GPSS-F's data areas from a</span></p>
<p><span class="font45" style="font-weight:bold;">file whose logical&nbsp;device number is &quot;SAVI*.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL CONT</span></p>
<p><span class="font45" style="font-weight:bold;">Data area:</span></p>
<p><span class="font45" style="font-weight:bold;">CONT uses every data area known to GPSS-F. Algorithm description: (See listing in Appendix A5).</span></p>
<p><span class="font45" style="font-weight:bold;">10*5 Ending Stochastic Simulations</span></p>
<p><span class="font45" style="font-weight:bold;">Suppose we're using a model to find the mean waiting time in a stationary system (see 1.5.We start the model and watch the queue fill up, recording waiting times as the model runs on. If at regular intervals we compute the mean waiting time, we find it fluctuates at first and then settles down. The longer the model runs, the less our computed mean changes. The value approached by the computed mean we shall call the true mean; it differs from the computed mean, which is:</span></p>
<p><span class="font45" style="font-weight:bold;">n</span></p>
<p><span class="font45" style="font-weight:bold;">computed mean waiting time s (&gt; ith task's waiting time)/n</span></p>
<p><span class="font45" style="font-weight:bold;">is1</span></p>
<p><span class="font45" style="font-weight:bold;">where n is the number of tasks that have been through the queue. The difference between the true and the computed means grows smaller with increasing simulation time and with increasing n.</span></p>
<p><span class="font45" style="font-weight:bold;">We can break off the simulation once the fluctuations have settled down, for we can assume that they do so in proportion as the computed value approaches the true mean. GPSS-F provides a subroutine that uses this criterion to halt simulations. The subroutine is SIMEND and the mean it use^ is the mean bin time (procedure A) for some given bin.</span></p>
<p><span class="font45" style="font-weight:bold;">SIMEND</span></p>
<p><span class="font45" style="font-weight:bold;">Purpose:</span></p>
<p><span class="font45" style="font-weight:bold;">When an unbroken string of 20 mean bin times differ no more than a given percentage from the most recent one, SIMEND halts simulation.</span></p>
<p><span class="font45" style="font-weight:bold;">Calling sequence:</span></p>
<p><span class="font45" style="font-weight:bold;">CALL SIMEND (NBN,NE,P,41006)</span></p>
<p><span class="font45" style="font-weight:bold;">Parameters:</span></p>
<p><span class="font45" style="font-weight:bold;">Bin number</span></p>
<p><span class="font45" style="font-weight:bold;">The subroutine watches the mean bin time of tokens in this bin.</span></p>
<p><span class="font45" style="font-weight:bold;">Number of withdrawn tokens between checks This number of tokens must be withdrawn before SIMEND recomputes the mean bin time and tests again whether it should call a halt. Percentage deviation</span></p>
<p><span class="font45" style="font-weight:bold;">This parameter specifies an interval around the last computed mean. The interval is the given percentage above and below the mean's value; its width is 2*P<sup>#</sup>MEAN/100. If all of the last twenty means fall within the interval, SIMEND takes its addressed exit. Termination exit</span></p>
<p><span class="font45" style="font-weight:bold;">SIMEND takes this exit to break off simulation.</span></p><div>
<p><span class="font45" style="font-weight:bold;">NBN</span></p>
<p><span class="font45" style="font-weight:bold;">NE</span></p>
<p><span class="font45" style="font-weight:bold;">P</span></p></div>
<p><span class="font47">SIHEND uses the area COMMON/BIN/ and the veetor MEAN to</span><span class="font50" style="font-weight:bold;"> save </span><span class="font47">past computations of the aean bin time;</span></p>
<p><span class="font47">REAL MEAN DIMENSION MEAN(20)</span></p>
<p><span class="font47">Algorithm description:</span></p>
<p><span class="font47">&quot;Cheek for a new test&quot;</span></p>
<p><span class="font47">NT s NA + NE</span></p>
<p><span class="font47">IF(BIN(NBN,4).LT.NT) RETURN</span></p>
<p><span class="font45" style="font-weight:bold;">If fewer than NE tokens have left the bin since the mean bin time was last computed<sub>9</sub> SIMEND returns without adieu.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute and enter the new mean&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">NA s NT</span></p>
<p><span class="font45" style="font-weight:bold;">PM s M0D(PM,20) ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">MEAN(PM) s FL0AT(BIN(NBN,6)) / FLOAT(BIN(NBN,4))</span></p>
<p><span class="font45" style="font-weight:bold;">This section enters the new mean bin time in the vector.</span><span class="font47"> It </span><span class="font45" style="font-weight:bold;">progresses cyclically through the vector, starting over at the beginning when it reaches the end and overwriting old values.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Compute the admissible interval&quot;</span></p>
<p><span class="font47">PR</span><span class="font45" style="font-weight:bold;"> s (MEAN(PM) • P) / 100. MU r MEAN(PM) - PR MO s MEAN(PM) ♦ PR</span></p>
<p><span class="font45" style="font-weight:bold;">The interval in which the mean values must fall is laid about the newly computed mean.</span></p>
<p><span class="font45" style="font-weight:bold;">&quot;Test the mean values&quot;</span></p>
<p><span class="font45" style="font-weight:bold;">III = PM 10 IM = M0D(IM<sub>f</sub>20) ♦ 1</span></p>
<p><span class="font45" style="font-weight:bold;">IF(MEAN(IM).EO.O.OR.MEAN(IM).LT.MU.OR.MEAN(IM).CT.M0) ♦RETURN IF(IM.NE.PM) GOTO 10 RETURN 1 END</span></p>
<p><span class="font45" style="font-weight:bold;">If any of the values in MEAN falls outside the interval or if any of them is zero, the subroutine returns to the caller. The check for zero insures that at least twenty mean values have been gathered.</span></p>
<p><span class="font45" style="font-weight:bold;">Notes:</span></p>
<p><span class="font45" style="font-weight:bold;">« A call to SIMEND can be placed anywhere in a model, but we recommend letting it test for termination Just after all condit-loned activations have been taken care of. The following sequence accomplishes just that;</span></p>
<p><span class="font45" style="font-weight:bold;">1001 CALL SIMEND (NBN,NE<sub>f</sub>P<sub>f</sub>41006) CALL ACTIV1 (41006)</span></p>
<p><span class="font45" style="font-weight:bold;">1003 target selector</span></p>
<p><span class="font45" style="font-weight:bold;">model</span></p>
<p><span class="font45" style="font-weight:bold;">1005&nbsp;CALL ACTIV2 (41001,41003)</span></p>
<p><span class="font45" style="font-weight:bold;">1006&nbsp;termination</span></p>
<p><span class="font45" style="font-weight:bold;">*&nbsp;GPSS-F will halt simulation automatically when:</span></p>
<p><span class="font45" style="font-weight:bold;">1)&nbsp;the model reaches its time limit, N,</span></p>
<p><span class="font45" style="font-weight:bold;">2)&nbsp;flow management runs out of transactions to process,</span></p>
<p><span class="font45" style="font-weight:bold;">3)&nbsp;SIMEND finds that the bin it is watching has stabilized, or</span></p>
<p><span class="font45" style="font-weight:bold;">4)&nbsp;a subroutine detects an error, e.g. a list overrun.</span></p>
<p><span class="font45" style="font-weight:bold;">Flow management runs out of things to do, of course, when all of the sources have shut down and all of the transactions have run out the other end of the model.</span></p>
<p><span class="font45" style="font-weight:bold;">•&nbsp;A good choice for the value of NE considers the results of an earlier simulation. The number of tokens it took to reach a stable mean is given by BIN(NBN,4). The first half of them should be written off to the startup phase and the last half divided into twenty test intervals for SIMEND, whence</span></p>
<p><span class="font45" style="font-weight:bold;">NE s BIN(NBN,4) / (2»20)</span></p>
<p><a name="bookmark152"><sup><a href="#footnote1">1</a>&nbsp;</sup></a><span class="font48">&nbsp;Static and dynamic systems:</span></p>
<p><span class="font48">Static systems are not subject to change. A beam ballance in mechanical equilibrium is a static system, provided it is not</span></p>
<p><a name="bookmark156"><sup><a href="#footnote2">2</a>&nbsp;</sup></a><span class="font48"> The aerodynamics of an airplane is studied on a scaled model in a wind tunnel.</span></p>
<p><a name="bookmark166"><sup><a href="#footnote3">3</a>&nbsp;</sup></a><span class="font48">&nbsp;Technology</span></p>
<p><span class="font48">Product design and development Control-systems design Communications</span></p>
<p><a name="bookmark170"><sup><a href="#footnote4">4</a>&nbsp;</sup></a><span class="font48"> WORK</span></p>
<p><span class="font48">When an active transaction acquires the facility, WORK simulates its time spent there by placing it in the scheduled state. This means that the transaction<sup>#</sup>s progress through the model is intèrrupted for a specified time. During this time, it remains in the scheduled state, occupying the facility. In terms of the bank-window system, the customer spends his 6 minutes at the window. When the time has ellapsed, the transaction can proceed on</span></p>
<p><a name="bookmark198"><sup><a href="#footnote5">5</a>&nbsp;</sup></a><span class="font45" style="font-weight:bold;">&nbsp;The transaction, whose parameters are in line LT.X</span><span class="font39" style="font-style:italic;"> s 1</span><span class="font45" style="font-weight:bold;"> of the transaction matrix and the activation list, and whose Identifying number is NTX = 2, occupies the facility. It has been there</span><span class="font43" style="font-style:italic;"> ever </span><span class="font45" style="font-weight:bold;">since time T § 7•</span></p>
<p><a name="bookmark268"><sup><a href="#footnote6">6</a>&nbsp;</sup></a><span class="font45" style="font-weight:bold;"> PREEftP does nothing more than to set a preemption in motion. I It cuts off a transaction's remaining service, but the transac- I tion leaves the facility under its own steam. How that</span><span class="font43" style="font-style:italic;"> happens </span><span class="font45" style="font-weight:bold;">depends on the service phase in which the preemption occurs:&nbsp;fl</span></p>
<p><span class="font45" style="font-weight:bold;">Setup: PREE?4P sets the preemption code. As soon as the setup I is over, the transaction calls WORK, which notices that a preemp- I tion is under way and returns without scheduling the transaction's work phase. The next statement will be either a call to KN0CKD, which simulates the facility's knockdown phase, or a call I to CLEAR, which frees the facility and throws the</span><span class="font43" style="font-style:italic;"> preempted ff </span><span class="font45" style="font-weight:bold;">transaction back in the queue.&nbsp;ft</span></p>
<p><span class="font45" style="font-weight:bold;">Work: PREEMP schedules the preempted transaction to call W0PK I again immediately. Then the transaction runs on as it would</span><span class="font43" style="font-style:italic;"> have, m </span><span class="font45" style="font-weight:bold;">had it been preempted in its setup phase.&nbsp;m</span></p>
<p><span class="font45" style="font-weight:bold;">Knockdown: Nothing at all happens, since the facility's occu- I</span></p>
<p><a name="bookmark314"><sup><a href="#footnote7">7</a>&nbsp;</sup></a><span class="font45" style="font-weight:bold;"> 11</span></p>
</body>
</html>