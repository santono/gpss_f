<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><meta name="generator" content="ABBYY FineReader 10"/><link rel="stylesheet" href="Untitled.FR10_files/Untitled.FR10.css" type="text/css"/>
</head>
<body>
<p>PREFACE</p>
<p>By contrast with other modelling methods, simulation is said to give expensive results. For the time being, this reservation is justified, but improved hardware and software are reducing many costs. Ve thus assume that the advantages of simulation will stand out more and more and its range of application broaden.</p>
<p>The costs of simulation fall into three categories:</p>
<p>*&nbsp;long run times,</p>
<p>*&nbsp;high memory demand, and</p>
<p>*&nbsp;large development costs.</p>
<p>It is already certain that emerging technology will drastically trim the costs of computing power and memory capacity. Long run times and high memory demand will no longer bar simulation. Development costs will, on the contrary, probably rise.</p>
<p>One way to cut development costs is to develop a simulator composed of immediately usable, tested modules. Then, to build a model, the user need only set the finished modules together. Experience shows that such a simulator reduces costs significantly, provided: 1) the number of modules is not too large and 2) they are designed to correspond to all possibly occurring elements and functions of the system being modelled. GPSS-F was designed to satisfy both criteria.</p>
<p>The GPSS-F simulator is a Fortran program-package. It consists of a chassis, the main program, into which calls to the modules, GPSS-F's subroutines, are inserted. Its construction makes it superior in several respects to its grandparent, GPSS (1):</p>
<p>*&nbsp;GPSS-F can be run on any computer with a Fortran compiler. All simulation models are virtually machine-independent.The package is already in use on a wide variety of machines, including IBM 360's and 370's, Cyber-series machines and PDP machines.</p>
<p>*&nbsp;Any Fortran programmer can change, extend or improve the simulator easily himself. He can tailor GPSS-F to suit his fancy, or even add new language-features required by his problem.</p>
<p>A beginner can learn the use of GPSS-F by either of two methods. The steam-roller method would be to read chapters 1 and 2, section ^.1 and chapters 7 and 9, ignoring under way any mention of preemption, multifacilities, storages and families.</p>
<p>The butterfly method browses through chapter 1 reading 1.6 carefully, then jumps to chapter 11, where it finds example models, each supplied with reading suggestions. Then it flits from examples to readings, progressing through the seven models from the 3imple to the ever more complex. The frequent cross-references in the text are navigation-aids for the butterfliers.</p>
<p>Despite the differences, GPSS and GPSS-F are close relatives.</p>
<p>They resemble one another especially In their names: GPSS-F'a and GPSS's stations are named alike and GPSS-F's subroutines are often named after GPSS's blocks. But the younger program has fea-tures beyond older one's. The following points summarize its nov~ titles:</p>
<p>•&nbsp;Events</p>
<p>Events are now as easy&quot;to handle as transactions, where GPSS res* trieted itself to transactions.</p>
<p>•&nbsp;Transaction-locking</p>
<p>In both simulators, transactions can wait at any point they choose, until the system's state satisfies certain conditions. In GPSS-F the user can test the system's state whenever he wants, to see whether a waiting transaction can now proceed. In GPSS, on the other hand«, only the simulator's flow management can test the wait conditions; they are outside the user's reach.</p>
<p>•&nbsp;Queue-processing</p>
<p>Each queue can be administered by its own policy. Furthermore, the transactions' priorities can be be assigned dynamically, as well as statically.</p>
<p>•&nbsp;Setup time at preemption</p>
<p>It is now possible to take into acoount the setup time lost in any preemption. A model that ignores that time yields false results, if the setup is not short by comparison with the service.</p>
<p>•&nbsp;Multifacilities</p>
<p>A multifacility is a new type of station. It consists of several ordinary facilities operating in parallel that take transactions from a common queue.</p>
<p>•&nbsp;Addressible storages</p>
<p>A transaction can acquire and free specific locations; the simulator keeps track of each location's contents.</p>
<p>•&nbsp;Coordinating transactions</p>
<p>A model can coordinate its transactions' movements more easily. In particular, user chains are more broadly applicable.</p>
<p>I should like to thank Prof. F. Hofmann for his generous support. I also thank Prof. G. Hiemeyer for allowing FGPSS (2) to be used as a basis for GPSS-F.</p>
<p>I received important help and support from B. Gernoth. She suggested especially valuable improvements. I thank T. Stroup for stimulating discussions that led to improvements in the system and for translating the text into English.</p>
<p>The program package GPSS-F is maintained by Dr. Staedtler Unternehmensberatung, Rother-Strasse 1, D 85 Nuernberg, Germany, from whom copies of the source deck may be ordered.</p>
<p>TJB LE OF CONTEHTS</p>
<p><a href="#bookmark0">1. Modelling a System. ....................1</a></p>
<p>1 <sub>#</sub> 1 Systems..............•#••••.•.•1</p>
<p>K*.1 Examples..................... 1</p>
<p><a href="#bookmark1">1.1.2&nbsp;Types of Systems..........................1</a></p>
<p>1.1.3&nbsp;Transaction-oriented and</p>
<p>Event-oriented Systems. .... ..... . ... 2</p>
<p><a href="#bookmark2">1.2&nbsp;Models. ........................3</a></p>
<p><a href="#bookmark3">1.2.1&nbsp;Similar Structures. ...............3</a></p>
<p><a href="#bookmark4">1.2.2&nbsp;Types of Models .................5</a></p>
<p>1.3&nbsp;Simulation Languages. . ........ ........ 7</p>
<p><a href="#bookmark5">1.3.1&nbsp;Types of Languages................7</a></p>
<p>1.3.2&nbsp;Model Formulation and Range</p>
<p><a href="#bookmark6">of Application..................7</a></p>
<p><a href="#bookmark7">1.4&nbsp;The Program Package GPSS-F....................8</a></p>
<p>1.4.1&nbsp;Model Construction and Range</p>
<p><a href="#bookmark8">of Application for GPSS-F . . . .........8</a></p>
<p><a href="#bookmark9">1.4.2&nbsp;A System's Elements and ^unctions....... . 9</a></p>
<p><a href="#bookmark10">1.4.3&nbsp;Application Examples. . .............10</a></p>
<p>1.5&nbsp;Developing a Model. .............. ....11</p>
<p><a href="#bookmark11">1.5.1&nbsp;Analyzing a System................11</a></p>
<p><a href="#bookmark12">1.5.2&nbsp;Building a Model.................12</a></p>
<p><a href="#bookmark13">1.5.3&nbsp;Testing a Model .................14</a></p>
<p>1.5.4&nbsp;Using a Model . .................</p>
<p>1.5.5&nbsp;Analyzing Results ............. . . .15</p>
<p>1.6&nbsp;Simulating Discrete Systems ....... ...... .15</p>
<p><a href="#bookmark14">1.6.1&nbsp;Bank-Window Model ............... .16</a></p>
<p><a href="#bookmark15">1.6.2&nbsp;Simulation Flow.................20</a></p>
<p><a href="#bookmark16">1.6.3&nbsp;Waiting Transactions. ..............23</a></p>
<p><a href="#bookmark17">1.6.4&nbsp;Conditioned Activation..............26</a></p>
<p><a href="#bookmark18">Structure of GPSS-F....................29</a></p>
<p><a href="#bookmark19">2.1&nbsp;Event Management. ...................29</a></p>
<p><a href="#bookmark20">2.1.1&nbsp;The Event List. .................29</a></p>
<p>2.1.2&nbsp;EVFNT .......... ........... .30</p>
<p>2.2&nbsp;Transactions........ ... . . . . . . . . . . .32</p>
<p>2.2.1&nbsp;Transactions' Data Area ............. 13</p>
<p>2.2.2&nbsp;Transactions ' States...............</p>
<p><a href="#bookmark21">2.3&nbsp;Transaction Management....... . . ........37</a></p>
<p><a href="#bookmark22">2.3.1&nbsp;Activation List..........................38</a></p>
<p>2.3.2&nbsp;ACTIV1. ......... ........... 39</p>
<p><a href="#bookmark23">2.3.3&nbsp;ACTIV2......■ * ' |&nbsp;.42</a></p>
<p>2.4 Transaction Generation and</p>
<p><a href="#bookmark24">Annihilation......................45</a></p>
<p><a href="#bookmark25">2.4.1&nbsp;GENERA......................45</a></p>
<p>2.4.2&nbsp;TERMIN........................</p>
<p><a href="#bookmark26">2 5 Transaction-State Management. . ............49</a></p>
<p><a href="#bookmark27">* 2.5.1 ADVANV......................49</a></p>
<p>2.5.2&nbsp;BUFFER........................</p>
<p><a href="#bookmark28">2.5.3&nbsp;UNLOCK......................51</a></p>
<p><a href="#bookmark29">2.6 The Chassis.......................51</a></p>
<p><a href="#bookmark30">2.6.1&nbsp;Chassis Sections.................52</a></p>
<p><a href="#bookmark31">2.6.2&nbsp;INIT1......................55</a></p>
<p><a href="#bookmark32">2.6.3&nbsp;INIT2......................56</a></p>
<p><a href="#bookmark33">2.6.4&nbsp;INIT3......................57</a></p>
<p><a href="#bookmark34">2.6.5&nbsp;RESET......................58</a></p>
<p><a href="#bookmark35">3.&nbsp;Stations and Policies...................60</a></p>
<p><a href="#bookmark36">3.1&nbsp;Policies...............................60</a></p>
<p>3.1.1&nbsp;Priority and Preemption ..........•.. .60</p>
<p><a href="#bookmark37">3.1.2&nbsp;FITO (First In, First Out)............6.1</a></p>
<p><a href="#bookmark38">3.1.3&nbsp;LIFO (Last In, First Out)............61</a></p>
<p><a href="#bookmark39">3.1.4&nbsp;SJF (Shortest Job First).............62</a></p>
<p><a href="#bookmark40">3.1.5&nbsp;Round-Robin (Cyclic Policy) ...........62</a></p>
<p><a href="#bookmark41">3.1.5 LFB (Limited Feedback). . . . ..........64</a></p>
<p><a href="#bookmark42">3.2&nbsp;Dynamic Priority Assignment..............64</a></p>
<p>3.2.1&nbsp;Types of Dynamic Priority</p>
<p><a href="#bookmark43">Assignment. ....... ...... . .....64</a></p>
<p><a href="#bookmark44">3.2.2&nbsp;UTL (Upper Time Limit)..............64</a></p>
<p>3.2.3&nbsp;UTLP (Upper Time Limit with</p>
<p><a href="#bookmark45">Priorities) ...................65</a></p>
<p>3.2.4&nbsp;WTLP (Waiting Time Limit with</p>
<p><a href="#bookmark46">Priorities) ...................66</a></p>
<p><a href="#bookmark47">3.3&nbsp;Policies in GPSS-F...................66</a></p>
<p><a href="#bookmark48">3.3.1&nbsp;POLICY......................67</a></p>
<p><a href="#bookmark49">3.3.2&nbsp;PFIPO ......................69</a></p>
<p><a href="#bookmark50">3.3.3&nbsp;FIFO.......................70</a></p>
<p>3-3.4 Dynamic Priority Assignment</p>
<p><a href="#bookmark51">with Subroutine DYNVAL..............71</a></p>
<p><a href="#bookmark52">3.4&nbsp;The State Vector. ...................72</a></p>
<p><a href="#bookmark53">3.5&nbsp;The Watchdog......................73</a></p>
<p><a href="#bookmark54">4.&nbsp;Facilities.............<sub>.</sub>...........74</a></p>
<p><a href="#bookmark55">4.1 Acquiring and Freeing a Facility............<sup>75</sup></a></p>
<p>4.1.1&nbsp;SFIZF ...&nbsp;..... -75</p>
<p><a href="#bookmark56">4.1.2&nbsp;WORK. . . [ ............... .. .77</a></p>
<p><a href="#bookmark57">1 .3 CL^AR . . . ' .................80</a></p><div>
<p>9</p></div>
<p><a href="#bookmark58">»2 Preemption........................................81</a></p>
<p><a href="#bookmark59">4.2,1 PREEMP......................81</a></p>
<p>11.2.2 Setup and Knockdown in Case of</p>
<p>preemption. .••••• ........ •«•••85</p>
<p><a href="#bookmark60">4.2.3&nbsp;SETUP • .................... .86</a></p>
<p><a href="#bookmark61">4.2.4&nbsp;KNOCKD.......<sub>.</sub>..............87</a></p>
<p><a href="#bookmark62">4.3 Multiple Entries to a Facility..................90</a></p>
<p><a href="#bookmark63">5.&nbsp;Multifacilitiea . . • . ..................91</a></p>
<p>5.1&nbsp;The Structure of Maltifacilities. ••........ .91</p>
<p>5.2&nbsp;Acquiring and Freeing a</p>
<p><a href="#bookmark64">Hultifacility.....................95</a></p>
<p><a href="#bookmark65">5.2.1&nbsp;MSEIZE......................95</a></p>
<p><a href="#bookmark66">5.2.2&nbsp;«WORK.............. ....... .98</a></p>
<p><a href="#bookmark67">5.2.3&nbsp;MCLEAR.....................100</a></p>
<p><a href="#bookmark68">5.3&nbsp;Preemption at Multifacilities............102</a></p>
<p><a href="#bookmark69">5.3.1 MPREEM.....................102</a></p>
<p>5*3*2 Setup and Knockdown in Case of</p>
<p>Preemption................... 106</p>
<p><a href="#bookmark70"><a name="bookmark70"></a>5.3.3 MSETUP.....................106</a></p>
<p><a href="#bookmark71">5.4&nbsp;The Plan: Service-Element Management.........107</a></p>
<p><a href="#bookmark72">5.4.1&nbsp;PLANI and PLANO................107</a></p>
<p>5.4.2&nbsp;LFIRST.................. • . • 109</p>
<p><a href="#bookmark73">5.4.3&nbsp;PRIOR.....................109</a></p>
<p><a href="#bookmark74">6.&nbsp;Storages ....... ........... ...... 111</a></p>
<p><a href="#bookmark75">6.1&nbsp;The Structure of Storages......................Ill</a></p>
<p><a href="#bookmark76">6.2&nbsp;Non-Addressible Storages........................113</a></p>
<p><a href="#bookmark77">6.2.1&nbsp;ENTER.....................113</a></p>
<p><a href="#bookmark78">6.2.2&nbsp;LEAVE........................116</a></p>
<p><a href="#bookmark79">6.3&nbsp;Strategies...................... 117</a></p>
<p><a href="#bookmark80">6.3*1 Storage Acquisition .............. 117</a></p>
<p><a href="#bookmark81">6.3-2 First-fit ........ ........... 117</a></p>
<p><a href="#bookmark82">6.3.3&nbsp;Best-fit. ...................118</a></p>
<p><a href="#bookmark83">6.3.4&nbsp;Conditioned Storage Assignment.........119</a></p>
<p>6.3.5&nbsp;Segmenting................. . . 119</p>
<p><a href="#bookmark84">6.3.6&nbsp;Collecting Free Space ............. 119</a></p>
<p><a href="#bookmark85">6.3.7&nbsp;Freeing Space.................121</a></p>
<p><a href="#bookmark86">6.4&nbsp;Addressible Storages.................121</a></p>
<p>6.4.1&nbsp;The Structure of Addressible</p>
<p><a href="#bookmark87">Storages..............».....121</a></p>
<p><a href="#bookmark88">6.4.2&nbsp;ALLOC.........................«123</a></p>
<p>6.4.3&nbsp;FREE................... * • .^127</p>
<p>6 5 GPSS-F strategies • • •...............</p>
<p><a href="#bookmark89">6:5.1 STRATA and STRATF.........•.....J30</a></p>
<p>6.5-2 FFIT. . • ............* I I ! <sup>#</sup> * 1 \\</p>
<p>6.5.3 BFXT.....•...................</p>
<p><a href="#bookmark90">7. Coordinating Transactions................135</a></p>
<p><a href="#bookmark91">7.1&nbsp;Branching on Condition. . ..............]35</a></p>
<p><a href="#bookmark92">7.1.1&nbsp;Deterministic Bran?hing ....... ..... 135</a></p>
<p>7.1.2&nbsp;Stochastic Branching:</p>
<p><a href="#bookmark93"><a name="bookmark93"></a>TRANSF. ....................W</a></p>
<p><a href="#bookmark94">7.2&nbsp;Waiting on Condition.................J36</a></p>
<p><a href="#bookmark95">7.2.1&nbsp;Trying the Gate................«37</a></p>
<p><a href="#bookmark96">7.2.2&nbsp;Local and Global Parameters .......... 13©</a></p>
<p><a href="#bookmark97">7.3&nbsp;Gates........................-</a></p>
<p><a href="#bookmark98">7.3-1 ..........................J 39</a></p>
<p><a href="#bookmark99">7.3.2&nbsp;GATE2.....................JJ3</a></p>
<p><a href="#bookmark100">7.3.3&nbsp;The IT Mechanism................145</a></p>
<p>7.4&nbsp;Gather Stations................- • • <sup>1J|6</sup></p>
<p>7.4.1&nbsp;Coordinating Transactions in one</p>
<p><a href="#bookmark101">Processing Path&nbsp;............. 1^6</a></p>
<p><a href="#bookmark102">7.4.2&nbsp;GATHR2. ....................1<sup>1</sup>*<sup>6</sup></a></p>
<p><a href="#bookmark103">7.5&nbsp;User Chains and Trigger Stations...........148</a></p>
<p>7.5.1&nbsp;Coordinating Transaction in</p>
<p><a href="#bookmark104">Parallel Paths.................148</a></p>
<p><a href="#bookmark105"><a name="bookmark105"></a>7.5.2&nbsp;LINK2.....................150</a></p>
<p><a href="#bookmark106">7.5.3&nbsp;UNLTM2.....................152</a></p>
<p><a href="#bookmark107">8.&nbsp;Families.......<sub>%</sub>..................155</a></p>
<p><a href="#bookmark108">8.1&nbsp;Kindred Tasks ....................155</a></p>
<p><a href="#bookmark109">8.2&nbsp;Data Areas for Families...............155</a></p>
<p><a href="#bookmark110">8.3&nbsp;The Birth and Death of Kinsmen............156</a></p>
<p><a href="#bookmark111">8.3.1&nbsp;SPLIT.....................156</a></p>
<p><a href="#bookmark112">8.3.2&nbsp;ASSEMB.....................158</a></p>
<p><a href="#bookmark113">8.H Coordinating Family Members ..........................160</a></p>
<p><a href="#bookmark114">8.4.1 Gather Stations for Families. .........160</a></p>
<p><a href="#bookmark115">8.11.2 GATHR1.....;.....................160</a></p>
<p>8.4.3&nbsp;User Chains and Trigger Stations</p>
<p>for Families........................... 162</p>
<p><a href="#bookmark116">8.4.4&nbsp;LIMK1............• • •&nbsp;<sub>#</sub> 163</a></p>
<p>8.4.5&nbsp;UNLIN1. . . . ..... <sub>#</sub> \ \ \ I I I ] [ I [I <sub>#</sub> 165</p>
<p>9.&nbsp;Random Sequences............'&nbsp;..... 168</p>
<p>9.1 Random Number Generators. .............. 168</p>
<p>9.2&nbsp;Uniformly Distributed Random</p>
<p>Sequences......................169</p>
<p>9.3&nbsp;Arbitrarily Distributed Random</p>
<p>Sequences . ............... ••«••170</p>
<p>9.3.1&nbsp;Using the Inverse Cumulative-»</p>
<p>Distribution Function ...... ....... 170</p>
<p>9.3.2&nbsp;Exponential and Erlang</p>
<p><a href="#bookmark117">Distribution. ............°.....171</a></p>
<p><a href="#bookmark118">9.3*3 Gauss Distribution.....• ••••««...&nbsp;174</a></p>
<p><a href="#bookmark119">9.3.4&nbsp;Lognormal Distribution. ......... . . .&nbsp;175</a></p>
<p>9.3.5&nbsp;Approximating Empirical</p>
<p><a href="#bookmark120">Distributions.................175</a></p>
<p><a href="#bookmark121">9.3.6&nbsp;Truncated Distributions ............ 177</a></p>
<p><a href="#bookmark122">9.4 Random Numbers in GPSS-F...............181</a></p>
<p><a href="#bookmark123">9.4.1&nbsp;Function RN..................І81</a></p>
<p><a href="#bookmark124">9.4.2&nbsp;UNIFRM......................182</a></p>
<p><a href="#bookmark125">9.4.3&nbsp;ERLANG........... ...........183</a></p>
<p><a href="#bookmark126">9.4.4&nbsp;GAUSS.....................184</a></p>
<p><a href="#bookmark127">9-4.5 LOGNOR.....................185</a></p>
<p><a href="#bookmark128">9.4.6&nbsp;BOXEXP.....................186</a></p>
<p>9.4.7&nbsp;Using the Random Number</p>
<p>Generators...................187</p>
<p><a href="#bookmark129">10. Gathering Statistical Data . . . . . .......... 190</a></p>
<p><a href="#bookmark130">10.1&nbsp;Bins. .......................190</a></p>
<p><a href="#bookmark131">10.1.1&nbsp;Statistics Gathered by Bins.........190</a></p>
<p><a href="#bookmark132">10.1.2&nbsp;ARRIVE...................193</a></p>
<p><a href="#bookmark133">10.1.3&nbsp;DEPART . ..................194</a></p>
<p><a href="#bookmark134">10.1.4&nbsp;ENDBIM...................196</a></p>
<p><a href="#bookmark135">10.2&nbsp;Frequency Table ..................197</a></p>
<p><a href="#bookmark136">10.2.1&nbsp;TABULA...................197</a></p>
<p><a href="#bookmark137">10.2.2&nbsp;RVALUE ................... 199</a></p>
<p><a href="#bookmark138">10.2.3&nbsp;GRAPH....................201</a></p>
<p><a href="#bookmark139">10.3&nbsp;Report of the System's State............204</a></p>
<p><a href="#bookmark140">10.3.1&nbsp;REPORT...................204</a></p>
<p><a href="#bookmark141">10.3.2&nbsp;SMLIST ................... 205</a></p>
<p>10.3.3&nbsp;SELIST . • . .............. • • 206</p>
<p><a href="#bookmark142">10.4&nbsp;Saving the System's State ............ . 207</a></p>
<p><a href="#bookmark143">10.4.1&nbsp;SAVE.............J ..........207</a></p>
<p><a href="#bookmark144">10.4.2&nbsp;C0NT . .................207</a></p>
<p><a href="#bookmark145">10.5&nbsp;Ending Stochastic Simulation. . .......... 208</a></p>
<p><a href="#bookmark146">11. Models ............................211</a></p>
<p>11.1 Flow Management ...........•..••••211</p>
<p><a href="#bookmark147">11.1.1 Bank Window......... ........<sup>231</sup></a></p>
<p>со</p>
<p>et</p>
<p>до ft M* ф 09 О С С</p>
<p>и» Н* ♦</p>
<p>Я 3 ui м •</p><div>
<p>1 U</p></div><div>
<p>н» ff</p>
<p>№ q</p>
<p>ä' ф ч</p>
<p>о эг tu</p>
<p>H* З (A</p></div><div>
<p>SS » «</p>
<p>I I</p></div><div>
<p>0<sup>і </sup>с</p>
<p>84!</p>
<p>trt*</p>
<p>ф ^ •</p>
<p>&lt;&lt; -л</p>
<p>•а</p>
<p>ф о</p>
<p>I 0) с*</p>
<p>ф 0)</p></div><div>
<p>*</p>
<p>H' И</p>
<p>3<sup>e</sup></p></div><div>
<p>I X</p></div><div>
<p>I</p>
<p>rv&gt;</p>
<p>о</p>
<p>Ш et</p>
<p>о 00</p></div><div>
<p>H &lt;&lt;</p>
<p>TD Ф I</p>
<p>ru</p></div><div>
<p>w Ф</p>
<p>о аг 0) и* 3 со</p></div><div>
<p>оч</p>
<p>U)</p>
<p>о</p></div>
<p><a name="bookmark148"></a>I to</p>
<p>•о</p>
<p>M</p>
<p>ш ч и* 9</p><div>
<p>ON</p>
<p>тЛ т* ш* Ці шЛ тЛ -А -»</p>
<p>•&nbsp;I • t ^</p>
<p>0&gt; 0N ON ON ДО</p>
<p>•&nbsp;• • • ft £ru&gt; î\&gt; —* Ф</p>
<p>oq</p>
<p>О С/) H О И' О с* 3<sup>е</sup> О ф</p>
<p>м а&gt; Ф а мп чз s с</p>
<p>О с+ a ф Ф п и 11</p>
<p>to</p>
<p>ff! а</p></div><div>
<p>ЧЛ</p>
<p>Xr</p>
<p>(А</p><img src="Untitled.FR10_files/Untitled.FR10-1.jpg" style="width:118pt;height:235pt;"/></div><div>
<p>тЛ -Л О</p>
<p>шф ^ û»</p>
<p>•&nbsp;• I ft -si -s) ф</p>
<p>•&nbsp;• • 0) U)</p></div><div>
<p>• і</p>
<p>а&gt; on • ' §</p>
<p>о н* а з ф</p></div><div>
<p>• • • ЫЫ u&gt;</p>
<p>^c H H</p>
<table border="1">
<tr><td>
<p>о</p></td><td>
<p>d* с</p></td><td>
<p></p></td></tr>
<tr><td colspan="2">
<p>а ф з</p></td><td>
<p>ш</p></td></tr>
<tr><td>
<p>ф</p></td><td>
<p>ф</p></td><td>
<p>3</p></td></tr>
<tr><td>
<p>m</p></td><td>
<p>1</p>
<p>о с</p></td><td>
<p>а</p></td></tr>
<tr><td>
<p>г&quot;</p></td><td>
<p>а*о</p></td><td>
<p>4j</p></td></tr>
<tr><td>
<p>и*</p></td><td>
<p>ф w</p></td><td>
<p>•1</p></td></tr>
<tr><td>
<p>W</p></td><td>
<p>и</p></td><td>
<p></p></td></tr>
<tr><td>
<p>t*</p></td><td>
<p>11</p></td><td>
<p>га</p></td></tr>
<tr><td>
<p>и* g</p></td><td>
<p>о</p></td><td>
<p>&quot;в</p></td></tr>
<tr><td>
<p>w</p></td><td>
<p>о'</p></td><td>
<p>&amp;</p></td></tr>
<tr><td>
<p>»</p></td><td>
<p>о \</p></td><td>
<p>и</p></td></tr>
</table></div><div>
<p>00 -J 0&gt; Kjy 4=r</p></div><div>
<p>u&gt; f\j —» и-</p></div><div>
<p>ЧЛ |гы м</p></div><div>
<p>2 О a (V</p></div><div>
<p>О I H п Ш О 7 ÛJ С* CX Ф ÇT M &lt;t&gt;</p></div><div>
<p>4J 3 h* О з a P Ф</p></div><div>
<p>О H* 5Г ЯГ</p>
<p>£ а d (I Ф а»</p>
<p>M м (Л о к у гяил</p>
<p>И f* И</p>
<p>м м d 3 и- із a и ИИ «u M і</p></div><div>
<p>ф</p></div><div>
<p>о</p>
<p>n a о и* ф 0&gt;</p>
<p>и мт</p>
<p>&lt;4 И* 3 W</p></div><div>
<p>г a</p>
<p>H* ft W h' f*</p>
<p>M* ï 3 H*</p>
<p>Wf* &amp;</p>
<p>К ' Ф</p></div><div>
<p>г- »</p>
<p>и» ф {/I (А К Є</p>
<p>M» M</p>
<p>Я ft</p>
<p>Л W і і</p></div><div>
<p>20 Г* Ф и* (/) W С t+</p>
<p>M H» c+ 3 W 9)</p></div>
<p>«Î-.</p>
<p>о</p>
<table border="1">
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p>«wt «é</p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p>•</p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p>ts&gt;</p></td></tr>
<tr><td>
<p></p></td><td>
<p></p></td><td>
<p>^ 1 SD</p></td></tr>
<tr><td>
<p>«А тЛ</p></td><td>
<p></p></td><td>
<p>ш</p></td></tr>
<tr><td>
<p>• •</p></td><td>
<p></p></td><td>
<p>• • а</p></td></tr>
<tr><td>
<p>fS) M</p></td><td>
<p></p></td><td>
<p>in) i\&gt; а</p></td></tr>
<tr><td>
<p>• ♦</p></td><td>
<p></p></td><td>
<p>• • о</p></td></tr>
<tr><td>
<p>4ru&gt;</p></td><td>
<p></p></td><td>
<p>i\&gt; — а</p></td></tr>
<tr><td colspan="3">
<p>X •-) О О С/1 С/)</p></td></tr>
<tr><td colspan="2">
<p>о э<sup>г</sup> ф</p></td><td>
<p>С «О ф</p></td></tr>
<tr><td>
<p>а ф</p></td><td>
<p>3</p></td><td>
<p>Ч С JÛ</p></td></tr>
<tr><td>
<p>ф</p></td><td>
<p>ф</p></td><td>
<p>и» С</p></td></tr>
<tr><td>
<p>M 2</p></td><td>
<p></p></td><td>
<p>g 1 ф</p></td></tr>
<tr><td>
<p>о</p></td><td>
<p>ш</p></td><td>
<p>08 П 3</p></td></tr>
<tr><td colspan="3">
<p>ra(t(p ф о</p></td></tr>
</table><img src="Untitled.FR10_files/Untitled.FR10-2.jpg" style="width:72pt;height:147pt;"/>
<p>V^UJLOU) U)U) rv&gt; r&gt;0 го го ro r\&gt; r\&gt; r\&gt; r\&gt; |\&gt;</p>
<p>, » <sup>4-4</sup> 9 OO vOvOvO 00 CO 00 00 00 00 00 чО 14) NO vO SO 0%ЧЛЧЛ LO UJ (\) (\)</p><div>
<p>f\)(V)fV) fV)</p>
<p>^ «I «4</p>
<p>ONVn xr</p></div><div>
<p>l\&gt; f\) r\&gt; f\&gt;</p>
<p>чЛ VJ1</p></div><div>
<p>гч&gt; го гч&gt; го</p>
<p>O^ONON го vo k0\0</p></div><div>
<p>ГО Г0 l\&gt; f\&gt; ЧЯ ЧЯ VJ1 Ol l\)000</p></div><div>
<p>f\&gt; !\&gt; ÏNJ</p>
<p>f\) f\) r\)</p>
<p>vo on чл</p></div><div>
<p>rv&gt; rv) f\) fU ДГ &lt;jü u&gt; u&gt; О CO 09 a&gt;</p></div>
<p>xlii</p>
<p>Appendix......................# ♦ • <sub>#</sub> 317</p>
<p><a href="#bookmark149">Al The System '3 Variables.....fff</a></p>
<p><a href="#bookmark150">K2 Description of the Data Area. ................- 523</a></p>
<p>A3 Parameter Adaption.........</p>
<p>320</p>
<p><a href="#bookmark151">A4 The Chassis . . . <sub># # .</sub>..............^ <sub>h</sub></a></p>
<p>A5 The Subroutines . . . <sub># #</sub>......</p>
<p>Bibliography . . . . <sub># # # #</sub> , ; <sub>#</sub></p>
<p>MODELLING à SYSTEM</p>
<p>Models simulate systems. More precisely<sub>f</sub> a simulation studies a system's behaviour over some period by constructing a second system,&quot; with the same structure as the original, but easier to work with. The second system is called a model.</p>
<p>1.1 Systems</p>
<p>A system is a set of elements in some way related to one another. At any instant<sub>9</sub> it is in some particular state determined by the elements' states and relationships. The system's state changes when an element's state or its relation to other elements changes.</p>
<p>1.1.1&nbsp;Examples</p>
<p>*&nbsp;The planetary system:</p>
<p>Each planet has some set of private parameters<sub>9</sub> which describe its state. These could include its diameter, geological structure, surface temperature, mass and period of rotation.</p>
<p>But the system's momentary state depends not only on the planets' own states, it depends on planetary relationships as well. Those relational parameters would include the bodies' relative positions and velocities. If we assume that the planets' own states don't change during our observation, the system's state can change only in its relational parameters.</p>
<p>*&nbsp;A computer installation:</p>
<p>Complex systems usually have elements of various types. If a computer installation is regarded as a system, its elements can be classified as processors, memories, peripherals and jobs.</p>
<p>As before, the system's parameters are both private and relational: private parameters characterize its elements; relational parameters, the relations and dependencies between them. The relational parameters specify, among other things, which job runs on which processor or which peripherals a job is using. A state change occurs when a parameter's value changes. A relational parameter could change in that the resources allocated to a job change; a private parameter could change in that a job's residual running time or priority changes.</p>
<p>1.1.2&nbsp;Types of Systems</p>
<p>Systems theory classifies systems with a terminology that imposes rough order on the clutter of possibilities.</p>
<p>disturbed. Systems whose state can change are dynamic.</p>
<p>• Deterministic and Stochastic Systems:</p>
<p>Dynamic systems are divided into two further classes. A system is deterministic, when for each system state, the subsequent system state is uniquely determined. If various states can follow, the system is stochastic. In plain English, chance is a part of the system. A radioactive nucleus is a stochastic system, since it emits nucleoids at random. 'At random' means that no given state leads, without fail, to radioactive decay.</p>
<p>• Continuous and discrete systems:</p>
<p>If state changes are continuous functions of time, as they are, say, in the planetary system, the system is continuous. A lake with streams feeding and draining it is also a continuous system. So is a spring-driven pendulum. If states change abrubtly and at intervals, the system is discrete. Two examples of discrete state changes are: a computer job frees one system resource and acquires another; the ballance in an -account is increased by the amount of a deposit.</p>
<p>1.1.3 Transaction-oriented and Event-oriented Systems</p>
<p>Among the discrete systems, we distinguish the transaction-oriented from the event-oriented. Many systems can be thought of as built from mobile and stationary system elements. The mobile elements wander between the stationary ones, altering them and being altered. The mobile elements are called transactions; the stationary elements, stations. Systems so constituted are transaction-oriented .</p>
<p>Examples:</p>
<p>*&nbsp;Computer installation</p>
<p>The stations are the system's resources, such as processors, working storage and peripheral devices. The transactions are jobs or tasks brought into the system; they travel from station to station and they acquire, free and queue up in front of stations.</p>
<p>*&nbsp;Warehouse</p>
<p>A warehouse consists of a great many racks in which wares are kept. The racks count as stations and the wares as transactions. Wares arrive at the warehouse, are filed according to muster and remain stored a <a name="footnote1"></a><sup><a href="#bookmark152">1</a></sup> while. Finally, upon receipt of an order, they are removed from the racks and forwarded.</p>
<p>*&nbsp;Street intersection</p>
<p>The cars are transactions whose essential characteristic is direction-of-travel. A traffic light coordinates their movement: travel is barred where the light is red. The cars form queues at the light until it changes; then they travel on.</p>
<p>When a model mimics one of those systems, it is irrelevant whether its transactions represent jobs in a computer, packages in a warehouse or cars at a traffic light. The essential similarity is, they are all mobile system components« A model's stations are just as flexible. They are equally adept at representing any« thing stationary<sub>9</sub> whether computer processor, warehouse rack, or traffic light.</p>
<p>In transaction-oriented systems, all state changes originate in the transaction's movements. An event-orientation doesn't divide the world so sharply into things that move and things that stay put. Instead, it sees systems as composed of elements that may or may not be stationary, but whose interplay entitles them in any case to full-fledged systemhood. The elements undergo state changes, called events, whose origin need not have anything to do with others of the system's elements. Obviously, a complex system may be thought of as part transaction-oriented, part event-oriented.</p>
<p>Examples:</p>
<p><sup>9</sup> An exchange of letters</p>
<p>Your grandmother remembered *to send you a birthday card. Since grandmothers remember such things quite on their own, they are genuine event-makers; their memories are not jogged by the movement of anything else on earth. If you wrote a pleasant reply, your activity is t ransaction—oriented| since it was occasioned by the birthday card's arrival.</p>
<p>• Traffic light</p>
<p>If we view the traffic light as a subsystem within the larger system sketched above, we could see it as event-oriented. Irrespective of traffic movements, it changes from red to green and back again.</p>
<p>1.2 Models</p>
<p>Even under the best of circumstances, it may be impossible to study a system directly. In systems planning, for example, the system doesn't yet exist. Or a system may be inaccessible, or its investigation dangerous or costly. Often, the system can't be studied because it changes too quickly or too slowly. So the study is carried out on a second system, built for the occasion. Of two systems structured alike, with respect to the values to be studied, the one used to investigate the other is called a model.</p>
<p>1.2.1 Similar Structures</p>
<p>An example should make clear what it means to say that two systems have a common structure:</p>
<p><sup>11</sup> A mechanical system</p>
<p>A mass M is suspended from a rigid wall by a spring with elastic constant K and shock absorber with damping factor D. (Fig. 1) If a time-dependent force F(t) acts on the mass, the equation of motion of its center of gravity is:</p>
<p>*</p>
<p><a name="bookmark153"></a>H* ♦ D* ♦ K* * K F(t)</p><div>
<p>I</p>
<p>I I j</p>
<p>I II</p>
<p>•---«I</p>
<p>I I</p>
<p>I</p>
<p>___I___(</p></div><div>
<p>I /</p>
<p>/</p>
<p>mi* /</p>
<p>/</p>
<p>inn / I</p>
<p>•___I___</p></div>
<p>-I — I</p>
<p>V</p>
<p>F(T)</p>
<p>FIGURE 1&nbsp;THE MECHANICAL SYSTEM</p>
<p>* An electrodynamic system</p>
<p>A resistance R, a condensor with capacitance C and a coil of inductance L are wi red in series. (Fig. 2) When a time—dependent voltage U(t) is applied to the circuit, the charge q in the circuit is governed by the equation:</p>
<p>Lq ♦ Rq ♦ q/c = q/c U(t)</p>
<p><a name="bookmark154"></a>c</p>
<p>I I I I I I</p><div>
<p>I 0</p>
<p>I</p>
<p>0 I</p></div><div>
<p>U(T)</p></div>
<p>I I I I</p>
<p>t I /1 /1 /1</p>
<p>•&nbsp;/ I / I / I / • 1/ 1/ 1/ 1/</p>
<p><a name="bookmark155"></a>•&nbsp;I I I</p>
<p>L</p>
<p>THE ELECTRODYNAMIC SYSTEM</p><div>
<p>figure 2</p></div>
<p>• A mathematical system</p>
<p>A differential equation of the form:</p>
<p>Ax ♦ Bx ♦ Cx <a name="footnote2"></a><sup><a href="#bookmark156">2</a></sup> C D(t)</p>
<p>can also be treated as a system. The variables stand for abstract system elements with certain properties, e.g. for real numbers. The relation between the abstract elements is reflected in the equation.</p>
<p><a name="bookmark157"></a>mathematical&nbsp;mechanical&nbsp;electrodynamic</p>
<p><a name="bookmark158"></a>system&nbsp;•&nbsp;system&nbsp;system</p><div>
<p>%</p></div>
<table border="1">
<tr><td>
<p>a</p></td><td>
<p>m</p></td><td>
<p>mass</p></td><td>
<p>l ;</p></td><td>
<p>inductance</p></td></tr>
<tr><td>
<p>b</p></td><td>
<p>d</p></td><td>
<p>damping factor</p></td><td>
<p>r</p></td><td>
<p>resistance</p></td></tr>
<tr><td>
<p>c</p></td><td>
<p>k</p></td><td>
<p>elastic constant</p></td><td>
<p>1/c</p></td><td>
<p>reciprocal capacitance</p></td></tr>
<tr><td>
<p>d(t)</p></td><td>
<p>f(t)</p></td><td>
<p>force</p></td><td>
<p>u(t)</p></td><td>
<p>voltage</p></td></tr>
</table>
<p>table 1&nbsp;correspondence table for the systems</p>
<p>Table 1 compares the three systems. If we regard parallel elements as counterparts<sub>f</sub> the three systems behave quantitatively a-like, or<sub>f</sub> in English, they mirror one another. How one system's quantities correspond to those in another, is given by a rule or function.</p>
<p>Since each system apes the remaining two, any one of them could be used to model the others. As a rule, the mathematical system would be used to study the two physical systems. It is nonetheless conceivable to solve the differential equation by studying one of the physical systems.</p>
<p>1.2.2 Types of Models Physical models:</p>
<p>The system's elements are all physical entities and the relationships between them are governed by physical laws. For example: <a name="bookmark159"></a><sup>9</sup> The structure of a molecule is visualized using a model with vari-colored balls for the atoms and wires for the molecular bonds.</p>
<p><a name="bookmark160"></a>• A three-dimensional surface represented by a mathematical e-quation is modelled by a sculptured block of wood.</p>
<p><a name="bookmark161"></a>Mathematical or analytic models:&nbsp;*</p>
<p>A system's behaviour is represented by a set of equations<sub>f </sub>usually differential, to which simultaneous solutions yield the sought results. Mathematical models are quite exact. They are especially well-suited for modelling static systems, such as the stress in a bridge. Their major drawback is that there may be no known solution to complex systems of equations. Stochastic systems can be studied mathematically only in simple cases based on standard distributions.</p>
<p>Computer-simulation models:</p>
<p>Simulation falls roughly in the middle between highly concrete models and highly abstract models, ^or discrete systems, it is close to physical models: the system's events are* &quot;played through' by the computer. For continuous systems, it adapts itself to mathematical models: the machine can solve obstinate systems of differential equations by brute force. Simulation's main advantages are that its models are easy to alter and that it can model very complex systems. Its disadvantages are the costs of programming and computer time.</p><div>
<p>ADVANTAGE</p></div>
<p>DISADVANTAGE</p><div>
<p>EASILY UNDERSTOOD</p></div><div>
<p>LIMITED APPLICATION</p></div><div>
<p>PHYSICAL MODEL</p></div>
<p>OFTEN NO KNOWN SOLUTION</p><div>
<p>EXACT RESULTS</p></div><div>
<p>ANALYTIC MODEL</p></div>
<p>HANDLES COMPLEX SYSTEMS</p><div>
<p>SIMULATION MODEL</p></div>
<p>LARGE IMPLEMENTATION EFFORT</p>
<p>MODELS EASILY ALTERED</p><div>
<p>TABLE 2</p></div>
<p>COMPARISON OF MODEL TYPES</p>
<p><a name="bookmark162"></a>1*3 Simulation Languages</p>
<p><a name="bookmark163"></a>In computer simulation, a model is described&nbsp;In the chosen</p>
<p><a name="bookmark164"></a>simulation language. The language features are&nbsp;like an erector</p>
<p><a name="bookmark165"></a>set or kit from which the pieces are attached to&nbsp;a chassis to form a model.</p>
<p><a name="bookmark5"></a>1.3-1 Types of Languages</p>
<p>If it is to simulate systems adeptly, our erector set's parts should go together quickly and without bother. That means that each type of model demands its own, easily adapted simulation language. A classification of simulation languages will correspond therefore to our classification of systems in 1.1.2.</p>
<p>Since it models a system's changes, simulation is useless for investigating static systems; its languages are fit to describe only dynamic systems. Dynamic systems usually have at least some random parameters, so most languages come equipped to build both stochastic and deterministic models.</p>
<p>Continuous and discrete systems are modelled using disparate methods. Continuous systems are usually described by systems of differential equations. A language equipped to simulate them must come armed with some means of describing continuous state transitions and tools for solving differential equations. DYNAMO (Pugh, 1963) and CSMP (IBM, 1967) are probably the best known languages of that type.</p>
<p>In discrete systems, the state changes occur in single, discontinuous steps. Languages designed to simulate them must offer features that change the model's state at the appropriate moments. Some examples are GPSS, GPSS-F, GASP, SIMSCRIPT and SIMULA. Among them, there are those (like GPSS) that model transaction-oriented systems and those (like GASP) that model event-oriented systems.</p>
<p>1.3.2 Model Formulation and Range of Application</p>
<p>The two criteria that judge a simulation language are:</p>
<p>a)&nbsp;How easily are its models built?</p>
<p>b)&nbsp;How broadly can it be applied?</p>
<p>Our erector-set image shows that the criteria often clash. If the erector set's parts are mostly prefabricated, criterion a) is satisfied and the model goes together without any trouble. But prefabricated parts adapt themselves mainly to prefabricated ideas. Details may be difficult to represent accurately and special desires cannot be satisfied. In short, the erector set is inflexible.</p>
<p>If the erector set's parts are small enough to show every manner of detail, model building is tedious and expensive. Moreover, modelling blunders are more likely. In that case, criterion b) is satisfied, but not a).</p>
<p>Graphing ease-of-use roughly against generality-of-applleation</p>
<p>for several common languages, we get (according to (3)) the arrangement shown in figure 3.</p>
<p>It 1s of course possible to model with the usual high-level programming languages, such as FORTRAN, ALGOL, or PL/I. A programmer can embellish his models with almost any refinement; the only bounds are set by his muse and his language. But modelling in those languages is herculean work. They are a last resort when there is no adequate ready-made language.</p>
<p>A</p>
<p>E|&nbsp;• CPSS-FORTRAN</p>
<p>A|</p>
<p>S|&nbsp;• DYNAMO</p>
<p>II</p>
<p>I .&nbsp;• CSMP</p>
<p>I</p>
<p>• GPSS</p>
<p>I I I I</p>
<p>|&nbsp;• SIMSCRIPT</p>
<p>|&nbsp;• SIMULA</p>
<p>• GASP</p>
<p>I</p>
<p>S|&nbsp;• HIGH-LEVEL PROGRAMMING</p>
<p>E|&nbsp;LANGUAGES</p>
<p>RANGE OF APPLICATION&nbsp;GENERAL</p>
<p>figure 3&nbsp;overview of common simulation languages</p>
<p>1.1 The Program Package GPSS-F</p>
<p>GPSS-F is a Fortran package that simulates discrete systems, whether stochastic or deterministic, whether transaction-oriented or event-oriented. This book emphasizes the stochastic and transaction-oriented and assumes that the reader can think his own way through the other, related cases.</p>
<p>1.1.1 Model Construction and Range of Application for GPSS-F</p>
<p>The simulator was developed expressly to meet the clashing criteria of 1.3.2. First, model construction was to be especially easy. GPSS-F consists of a pre-vritten main program, the chassis, and pre-written subroutines, the model-building modules. A model is built by attaching subroutine calls to the chassis. The pre-</p>
<p>written modules embody all important and often-used system elements. So CPSS-F satisfies the first criterion<a name="footnote3"></a><sup><a href="#bookmark166">3</a></sup></p>
<p>It satisfies the second by being easy to modify. Any Fortran programmer can learn how the simulator works; its structures a simple and clear. Whenever GPSS-F lacks a needed feature» it can be added without trouble» usually by writing a short subroutine to add to the stock of modules. As a result» GPSS-F takes a special place among simulation languages (see figure 3 again)«</p>
<p>1*4.2 A System's Elements and Functions</p>
<p>All elements and functions that occur in discrete systems can be classified into four categories. They are described briefly here and explained in detail in the chapters referred to in the headings:</p>
<p>•&nbsp;Queue processing (Chapter 3)</p>
<p>If a station cannot, for the moment, process newly arriving tasks, they queue up to wait on it.. (Tasks are to systems what transactions are to models.) When the station is ready again, one of the waiting tasks must be chosen from the queue to be pro-cessed. A procedure for selecting the next waiting task is cabled a policy.</p>
<p>Systems-analytic research has shown that any complex policy can be constructed from two elementary mechanisms: preemption and priority management. GPSS-F provides for both. Furthermore, each queue may be assigned its own specific policy, two of which are available as pre-written subroutines: 'Selection According to Priority' and 'First In, First Out'.</p>
<p>•&nbsp;Acquiring and freeing storage space (Chapter 6)</p>
<p>A storage is a station that accomodates tasks according to its capacity and their demands for space. Each arriving task requests a certain amount of space in the storage. A warehouse or a parking lot is a storage, since each incoming ware or car takes up some of the storage's available space. The loading up of storage is called its allocation; its unloading is called freeing.</p>
<p>Procedures called strategies are used to decide which of a storage's locations to load or unload. When an arriving task requests space in a storage, an allocation strategy assigns the space according to a specific rule. When a storage is unloaded, a freeing strategy must decide which spaces are to be freed, if the unloading request doesn't specify uniquely which items are to be removed.</p>
<p>Any technique for managing storage can be set up, if account is kept of the occupied locations and if strategies are available to allocate and free the storage's space. Again, GPSS-F provides for both. First, it keeps track automatically of the positions and contents of filled storage spaces. Second, it permits each storage to be assigned its own strategies. In addition, it provides two pre-written loading strategies: first-fit and best-fit.</p>
<p>•&nbsp;Coordinating tasks (Chapter ?)</p>
<p>The two mechanisms *Branch on Condition* and 'Wait on Condition* suffice to coordinate the movement of tasks through a dis-fO</p>
<p>Crete ays tea. One speaks of 'branching on condition'» in case a task can be sent to one of various stations, depending on the system's state. 'Waiting on condition' Beans that tasks can be held at some point<sub>f</sub> until the system's state changes to meet specific conditions.</p>
<p>In GPSS-F, tasks can branch or wait at any point in the model. The user specifies the condition under which branching or waiting occurs by means of a logical expression. Hence any coordination procedure can be specified without trouble»</p>
<p>* Denoting families of tasks (Chapter 8)</p>
<p>Tasks may belong to a family; they preserve their identity although they carry markers that show their family membership. Families are especially useful, when tasks running through a processing path must be handled differently from one another<sub>9</sub> depending on their properties.</p>
<p>1.4.3 Application Examples</p>
<p>GPSS-F can be put to a variety of uses. As a spur to imagination, some typical ones are listed below:</p>
<p>•</p>
<p>*&nbsp;Transportation planning</p>
<p>Planning of railroad stations, port facilities<sub>9</sub> airports, parking lots</p>
<p>Design of urban transportation systems Timetable production Traffic-light control</p>
<p>*&nbsp;Operations research Company modelling</p>
<p>Production planning, investment planning Scheduling and cost planning for projects Profitability studies Production control Stock control</p>
<p>Optimal workshop layout for a given job profile</p>
<p>*&nbsp;Administration Macroeconomic planning</p>
<p>Planning of schools, hospitals and universities Capacity studies</p>
<p>*&nbsp;Data processing</p>
<p>Planning computing installations</p>
<p>Planning operating procedures in a computer center Operating-systems design Computer-installation configuration -</p>
<p>The sequence of steps taken to build a model depends on the problem being investigated« Nonetheless, a few broad points are fairly problem-independent; they belong to the development of nearly every model. Figure 4 shows them as a standard flow chart for modelling.</p>
<p>First, the system is analyzed and its model designed and built. Then the model is tested to see how accurately it replicates the system. Finally, when it is a good likeness, the replica is used to study the original. For use in planning, say, one of the model's features would be altered to see how the system would react, if it were altered in the same way.</p>
<p>1.5*1 Analyzing a System</p>
<p>The first step is to analyze the system carefully. After it has been classified roughly, the system's components are identified, along with their private parameters. Finally, the relational parameters are identified.</p>
<p>Once the system's parameters have been found, they must be assigned actual values. This is relatively easy when their values are simple constants, but parameters are often random variables of unknown behaviour. If so, their customs and habits must be studied where they run wild: in the system itself. If the system is hostile to study, we satisfy ourselves with reasonable assumptions concerning its random variables. *</p>
<p>It is advisable to analyse the system as much as possible without considering model construction. The analysis must be objective and neutral and it should not be restricted prematurely by model-building considerations.</p>
<p>A system is modelled to solve a specific problem or to answer a clear question, whose nature guides most aspects of the system's analysis. The question to be answered determines, for example, which of the model's parameters will be varied and which will be studied. Then we study the model, setting the former to see what effect they have on the latter.</p>
<p>Finally, we measure the model's performance for different parameter settings. Our measure or evaluation is a function of the parameters we choose to study and it specifies, perhaps with numerical precision, how pleased we would be to have the real system behave likewise. If several goals are to be pursued, not all with the same intensity, we choose an evaluating function that weights each goal according to its importance.</p>
<p>Example:</p>
<p>* We want to Investigate how to serve the cars faster at a highway gas station. The improvements * costs are not to exceed some fixed limit. This system is clearly discrete, stochastic and transaction-oriented. Its components are the cars, the gas pumps, the station attendants and the cash register. Their private parameters are:</p>
<p>Mean arrival rate</p>
<p>Gasoline required</p>
<p>Flow rate in gallons per minute</p>
<p>Mean service time per car</p>
<p>Mean service time per car</p><div>
<p>Cars</p>
<p>Pumps</p>
<p>Attendants Cash register</p></div>
<p>Not counting the pump rate<sub>9</sub> which is constant, the parameters are all random variables whose behaviour has to be found by studying the gas station. The relational parameters specify spatial and temporal relations between the system's components.</p>
<p>The problem to be solved determines which values we shall want to study. Since the goal is to serve cars faster, a good choice would be to study the mean queue length at the pump. Or we could study the cars' mean waiting times, instead. The model is then used to find alterations to the system that minimize those parameters under various assumptions.</p>
<p>The parameters that can be altered are the number and layout of the pumps as well as their flow rate, the number of attendants, and the number of cash registers. We could study the effect,^ say, of substituting faster pumps merely by increasing the pumps' flow-rate parameter. The performance measure reflects the relative importance of reduced waiting times versus the cost of achieving it. The model might show that the faster pumps, do the job, but an additional slow pump has the same effect at half the cost.</p>
<p>A system's analysis is complete when the following have been determined:</p>
<p>*&nbsp;System's type</p>
<p><sup>11</sup> System's components with private and relational parameters</p>
<p>*&nbsp;Problem formulation that specifies which parameters are to be altered and which to be studied</p>
<p>*&nbsp;Performance measure</p>
<p>1.5.2 Building a Model</p>
<p>The choice of simulation language determines a model's construction. It helps immensely to find a language adapted to the system and general enough to represent all wanted detail. Time spent selecting the right language is rarely lost. It is won back when the model is easier to build than it would have been using the wrong language.</p>
<p>How faithfully should a model reflect the modelled system? Replicating the system exactly is neither possible nor necessary. Precisely those system components have to be found that are relevant to the study. We can ignore all details whose inclusion would alter the results inessentially.</p>
<p>Improving a model's faithfulness inflates the effort to build it. The added effort includes computer time, memory requirements, programming time and testing time. Some effort is, of course, always required if the model is to reflect important aspects of the</p>
<p>But every far-reaching improvement demands that added ef-</p>
<p>fM**b* justified.</p><div>
<p>&lt;---</p></div>
<p>ANALYZE</p>
<p>THE SYSTEM</p><div>
<p>—&gt;</p></div>
<p>DESIGN AND</p>
<p>DEVELOP ITS MODEL</p><div><img src="Untitled.FR10_files/Untitled.FR10-3.jpg" style="width:187pt;height:246pt;"/></div><div>
<p>—&gt;</p></div>
<p><a name="bookmark167"></a>analyze</p>
<p><a name="bookmark168"></a>the results</p><div>
<p>figure i</p></div>
<p><a name="bookmark169"></a>flow diagram for building models</p>
<p>A simulation model should be built along the same principles as any large or complex program system. Constructing the model from modules, keeping them understandable and building in test aids are excellent principles to follow.</p>
<p>1.5.3 Testing a Model</p>
<p>After a model is built, someone must test how well it reflects the modelled system. Of course, programming bugs falsify the replica. More important mistakes are a falsely analyzed system or a botched model. Other worries surround the parameters. Maybe we overlooked an essential one or assigned it the wrong value or mistook its relationship to the other essential parameter we forgot to include.</p>
<p>a simulation model is often tested by comparing the results of a simulation with measurements taken from the system itself. This procedure presumes, of course, that the system already exists and that measurements are practical. If the model reflects the system accurately for the cases compared, we boldly assume the model's correctness in all remaining cases.</p>
<p>a simulation model can sometimes be tested by comparing it with a mathematical model. From concurring results, ~we ponclude, as before, that the model also functions correctly in cases too complex to handle mathematically. This procedure's disadvantage is that it doesn't uncover any systems-analysis blunders, furthermore, if the analytic model uses approximation techniques, it isn't clear whether differing results convict the model or the approximation methods of error.</p>
<p>1.5.4 Using a Model</p>
<p>How a computer simulation is used to study a system should be clear from the gas-station example. Here we mention two problems specific to the use of certain stochastic models. The problems are discussed more thoroughly in (8).</p>
<p>Computer simulations of stochastic systems yield reliable results only after they have run for a certain time; analytic models yield exact results immediately, even for values dependent on random variables such as mean queue-length or mean serving time. To find mean values using a simulation model, the model is examined from time to time and the observations collected and analyzed .</p>
<p>For stationary sytems (systems in which the mean values are time-independent, i.e. constant), that is done by running the simulation and collecting the values of its random parameters, say queue length, at regular intervals. The law of large numbers insures that, despite statistical variation, the model's mean values will eventually approach the system's. If we observe the model and. plot the mean values of its random variables against time, we can see how they fluctuate and how the fluctuations die down, approaching the sought value.</p>
<p>A system is called non-stationary, if the mean values of its parameters, e.g. mean queue-length, are non-constant functions of</p>
<p>time. Suppose we seek the mean value of such a parameter. We cannot exclude statistical ^Variation from the results by running the model just once| but long enough that the law of large numbers assures that the observed mean approaches the actual mean. Since the mean is a function of time<sub>9</sub> there is no single, constant value for the observed mean to approach« The mean values of non-sta-tionary systems can be found only by running the model repeatedly until the observed values from the various simulation runs begin to converge to a single function. This method is so expensive for complex systems, that it restricts modelling by simulation severely.</p>
<p>If the conditions at the start of a simulation differ from the system's normal operating conditions, the model will fluctuate in ways that don't mirror the system until it reaches its normal, full-swing phase. There are two possibilities for avoiding spurious results due to the fluctuations of a model's startup.</p>
<p>First, we could start the model up in full swing. This would require pre— filling the queues and pre-assigning transactions to stations. The procedure requires extremely good knowledge of the system. Second, we could let the raôdel run through its startup phase, then start collecting data only after the startup fluctuations have settled down.</p>
<p>It is very difficult to determine exactly when the startup phase is over, since the startup fluctuations are hard to distinguish from normal statistical variation. In such cases, all systems, including stationary ones, must be treated in the initial phase as non-stationary.</p>
<p>1.5.5 Analyzing Results</p>
<p>Probability theory and statistics provide important tools for reducing and interpreting the results of a simulation. These fields are too broad to be handled here; the interested reader should consult the bibliography for recommended texts (e.g. (8)). If simulation is used for systems optimization, operations research offers additional tools for analyzing the results and for making it easier to optimize the system. Again, the interested reader is refered to the bibliography.</p>
<p>1.6 Simulating Discrete Systems</p>
<p>Discrete systems are modelled by means of a simple procedure, described below, which we refer to as flow management. Certain details of the description pertain GPSS-F's flow management, but the techniques used to process any discrete system are roughly the same.</p>
<p>Since we restrict ourselves to discrete systems, we can assume that the system goes from one state to another at definite times. This state change or transition occurs in that the values of the system's parameters change at those times.</p>
<p>Computer simulation immitates such processes. It sets up data areas corresponding to each of the system's elements. At specific</p>
<p>moments, indicated by the simulation clock» the simulator modifies the data areas, thereby mimicking a state change«</p>
<p>Plow management's job is to Insure that state changes occur at the prescribed times and in prescribed sequence. It has a list that specifies the time when each particular state change must occur. When the simulator clock reaches a time shown in flow management's list» it jumps to the section of the simulator program that effects the required change.</p>
<p>There are thus four simulator components» which work in tandem:</p>
<p>a Data areas for the system eleanents</p>
<p>The data areas specify the state of the system.</p>
<p>*&nbsp;The simulation program</p>
<p>The simulation program consists of various program parts that effect state changes by altering the data areas; each program part can be executed independently of the others.</p>
<p>*&nbsp;Flow manageaent</p>
<p>Flow management has a list available to it that specifies which program part is to be executed and at what time.</p>
<p>*&nbsp;The simulation clock</p>
<p>The simulation clock specifies the simulation time. Flow management consults it» in order to know when it has become time to carry out a state change in its list.</p>
<p>1.6.1 Bank-Window Model</p>
<p>An extremely simple model» built using GPSS-F, will show how discrete systems are simulated. The system consists of a bank window and customers. A detailed description of the bank-window model is given in section 11.1.</p>
<p>Starting at 8:00» a customer arrives at the window every 5 minutes. If the window is free, the customer can be served immediately. Serving time is exactly 6 minutes. If a customer is already at the window, an arriving customer waits in line, i.e. he queues up. Obviously, the first customer is the only one who won't have to wait and the line will grow longer and longer as the day wears on.</p>
<p>We shall represent the window, the system's only stationary element, by a facility. A facility is a GPSS-F station that serves just one customer at a time. Our facility can be in exactly one of two states: occupied (processing a customer) or free (ready to process the next customer) . The transitions from one of those states to the other are the only state changes the facility can undergo.</p>
<p>The customers, the system's mobile elements, will be represented by transactions. When a customer steps up to the window to be served, we will say, in terms of the model, a transaction has acquired the facility; when he leaves the window, we will say the transaction has freed the facility.</p>
<p>| A TRANSACTION IS GENERATED j EVERY 5 MINUTES</p>
<p>I I</p>
<p>I</p>
<p>| THE TRANSACTION ACOUIRES THE j FACILITY. IT QUEUES UP AT j THE FACILITY IF THE FACILITY I IS OCCUPIED</p>
<p>I</p>
<p>| THE TRANSACTION SPENDS 6 j MINUTES AT THE FACILITY BEING SERVED</p>
<p>I</p>
<p>I THE TRANSACTION FREES THE</p>
<p>I FACILITY</p>
<p>I I</p>
<p>I</p>
<p>I THE TRANSACTION IS I ANNIHILATED</p>
<p>I I</p><div>
<p>TOC* ryöilHNN» H «ajr*w*-r*iiJ« 6M0/IMOT?:* CGCP</p>
<p>9HO* tftjtup SHT/Jlt&gt;i:cro Jâ/IA</p></div><div><img src="Untitled.FR10_files/Untitled.FR10-4.jpg" style="width:85pt;height:46pt;"/></div>
<p>TRANSACTION'S FLOW THROUGH THE BANK-WINDOW MODEL</p>
<p>From the system's point of view, a customer comes into existence for the first time when he enters the bank; everything he ever did up to that moment is irrelevant to the simulated system. Thus customers are created when they enter the system, or in terms of the model, transactions are generated. A transaction is generated by a station called a source. In our system, the source can be thought of as the bank's door. Once they have left the system, the customers' further activities can again be ignored, so the transactions used to represent them can be annihilated. A single transaction's progress through the system is diagrammed in figure 5.</p>
<p>For the purposes of this example, each transaction is, at any given time, in exactly one of three states: active, scheduled to be active, or waiting. A transaction can pass from one block in</p><div>
<p>FIGURE 5</p></div>
<p>figure 5 to the next only when It la active. A transaction is generated active, so that it passes over to the second block. There, it either acquires the facility and proceeds to the third block or it queues up to the facility. While a transaction is queued up at the facility, it is waiting; when it reaches the head of the queue, it becomes active in order to acquire the facility and to proceed to the next block. As soon as it acquires the facility and begins being served, it is scheduled to be acti-* vated again in six minutes. Six simulated minutes later, it frees the facility and is annihilated. In terms of state changes, the first transaction's boring biography between generation and annihilation is: active, scheduled, active; for all remaining transactions it will be the more blood-stirring: active, waiting, active, scheduled, active.</p>
<p>The state changes in a GPSS-F model are undertaken by GPSS-F subroutines. We shall understand 'state change' in a broad sense in which a number of parameters could be altered together to make one (complex) state change. The simulation program describing our model consists of sequences of subroutine calls, each of which effects a particular type of state change. The statement at the head of each sequence is given a statement number, so that flow management has the means to jump to any state change. The statement numbers serve as targets labelling the simulation program's sections.</p>
<p>Flow management's list, from which it decides which program part to execute and when, is a list of targets (i.e. statement numbers) paired with state-change times; when the simulator clock reaches a time in the list, flow management jumps to the statement sequence whose target is paired with that time. At the end of the sequence, when the simulation program has carried out all necessary state changes, it returns to flow management. When the clock reaches the next time in the list, the procedure starts over again. In this way, flow management undertakes each state change at the proper time.</p>
<p>The simulator clock shows simulated time and it is incremented in discrete time units. In the bank-window model, each time unit will correspond to one minute.</p>
<p>Note that there are three kinds of time used in talking about models: the machine time in which the gpss-f model runs, the time shown on the simulation clock and the system time it simulates. In machine time, for example, only one transaction at a time is ever active. Thus we can speak, without confusion, of the active transaction. In simulated time, several transactions may be active simultaneously. That state is simulated by leaving the simulator clock constant and activating the transactions one after the other.-</p>
<p>The GPSS-f subroutines to be used in the bank-window model correspond one-to-one to the blocks in figure 5. They have the following functions:</p>
<p>•&nbsp;GENERA</p>
<p>When GENERA is called, it generates an active transaction. A transaction is considered generated when GENERA has aoqulred a line for it in the transactions' data area, and filled in its initial parameters. It is considered active when a GPSS-F subroutine sets an internal variable (LTX) to show that it is active. A transaction is represented exclusively by its entry in the transactions' data area; the entry &quot;is&quot; the transaction.</p>
<p>Each time it generates a transaction, GENERA schedules Itself to be called again to generate the next transaction. It does that by entering a new generation time and its own statement number as target in flow management's list. The new generation time is relative to the present simulated time; it is calculated from GENERA's argument ET, as follows:</p>
<p>New&nbsp;Present&nbsp;ET, that is, ellapsed</p>
<p>generation s simulator&nbsp;+ time until next</p>
<p>time&nbsp;clock time&nbsp;transaction generation</p>
<p>Since GENERA always generates a transaction for a particular source, it modifies both the sources' and the transactions' data areas.</p>
<p>Normally, GENERA returns control to the statement following it. (That isn't true of every GPSS-F subroutine; some of them sometimes return control directly to flow management.) After return from GENERA, execution continues with the next statement in the simulation program.</p>
<p>•&nbsp;SEIZE</p>
<p>The SEIZE subroutine administers the facility. If the facility is free, SEIZE changes its state to occupied; the currently active transaction acquires the facility. If the facility is already occupied, the active transaction is placed in the wait state in the facility's wait queue. Thus SEIZE changes either the facility's state from free to occupied, or the transaction's from active to waiting, but not both.</p>
<p>The SEIZE subroutine requires the facility's data area, in order to determine whether it is occupied or free and, if need be, in order to change the facility's state. SEIZE also requires the active transaction's data area in order to show, roughly speaking, its position in the queue.</p>
<p>If the active transaction acquires the facility, it remains active and SEIZE returns control to the statement following the call. If SEIZE puts the transaction in the wait state, the transaction can proceed no further; hence SEIZE returns control to flow management. In this case execution does not continue with the next statement in the program.</p>
<p>its way by being re-activated.</p>
<p>WORK schedules the transaction's re-activation by entering an activation time and its own statement number in flow management's list. When it is re-activated, flow management will Jump back to the CALL WORK statement that scheduled the re-activation; this time WORK recognizes the returning transaction and doesn't reschedule it.</p>
<p>WORK schedules a transaction to be re-activated at a time computed as follows from its argument WT:</p>
<p>New&nbsp;Present&nbsp;WT, that is, serving</p>
<p>activation <a name="footnote4"></a><sup><a href="#bookmark170">4</a></sup> simulator&nbsp;+ (working) time for the</p>
<p>time&nbsp;clock time&nbsp;transaction</p>
<p>The statement number that WORK enters as target in the list is given by its parameter, ID. In our model, WORK schedules the transaction to be re-activated in 6 minutes (WT s 6) and specifies that WORK is to be called again at that time (ID ? WORK CALL's statement number).</p>
<p>When it schedules a transaction to be re-activated, WORK returns control to flow management. When it is called the second time, it recognizes the transaction that has just been served and returns control to the statement following the call.</p>
<p>•&nbsp;CLEAR</p>
<p>This subroutine frees a facility by clearing the &quot;occupied&quot; code from the facility's data area. After a call to CLEAR, execution resumes with the following statement.</p>
<p>•&nbsp;TERMIN</p>
<p>TERMIN obliterates a transaction from the system by clearing its data area. It returns control to flow management.</p>
<p>The simulation program built from these subroutines to simulate the bank-window system is shown in figures 6 and 7 for two clock times. The interaction of the simulator clock, flow management and the simulation program are described more closely in the next section.</p>
<p>1.6.2 Simulation Flow</p>
<p>Flow management has a subroutine that searches its list for the earliest state change to be carried out. Then it sets the simulator's clock ahead to that time by transferring the value it finds to the variable t, which is the clock. Associated with that earliest state-change time, it finds a target that shows which program part undertakes the state change now to take place. Flow management then jumps to that statement number and the designated program part undertakes the requisite state change.</p>
<p>Example:</p>
<p>• In figure 6, the simulation clock shows time T = 11. GENERA is now supposed to generate a transaction, since the first customer appeared at the bank at time T = 1 and our model assumes that</p>
<p>customers arrive every.five minutes. Thus the target&nbsp;'1* appears in the list associated with activation time t s 11. After advancing the clock to t * 11, flow management jumps to statement number 1.</p>
<p><a name="bookmark171"></a>simulator Clock t</p>
<p>I ii l&lt;</p>
<p>flow management's list</p>
<p>target state-chg stmt. time</p>
<p><a name="bookmark172"></a>ï~s t î3 t</p>
<p><a name="bookmark173"></a>«•I 1 I 11 I»»</p>
<p><a name="bookmark174"></a>î t t</p>
<p>data areas for the system elements</p>
<p>I I I I I I I I</p>
<p>source data area transaction data area</p><div>
<p>I I</p>
<p>VI &lt;</p>
<p>I I</p>
<p>K«</p></div>
<p>simulation program</p>
<p>CALL GENERA ( ET s 5 ) CALL SEIZE</p>
<p>CALL WORK ( WT = 6 , ID : 3) CALL CLEAR CALL TERMIN</p><div>
<p>statement number</p>
<p>1 2 3</p></div>
<p>the simulation model at time ts 11</p>
<p>The system's progress is reflected by undertaking state changes one after the other. For each scheduled state change, a time and target appear In flow management's li3t. Flow management assures correct state-change sequencing by searching its list and selecting state changes in chronological order.</p>
<p>Example:</p><div>
<p>FIGURE 6</p></div>
<p>• In figure 6, the simulation clock shows T = 11, at which time a transaction i3 generated. The next time at which a state change is to take place is T s 13. Hence, after the generation scheduled for T s 11 has been carried out, the simulation clock is advanced from 11 to 13. The new state is shown In figure 7.</p>
<p>Flow management's list must be primed by the user, i.e. he</p>
<p><a name="bookmark175"></a>■ust enter the tine and target for the very first 'state cha into flow management's list.&nbsp;<sup>nge</sup></p>
<p><a name="bookmark176"></a>SIMULATOR CLOCK T</p>
<p><a name="bookmark177"></a>I 13 !&lt;•••••«••</p>
<p><a name="bookmark178"></a>....... •</p>
<p><a name="bookmark179"></a>•</p>
<p><a name="bookmark180"></a>FLOW MANAGEMENT'S«</p>
<p><a name="bookmark181"></a>LIST&nbsp;•</p>
<p>•</p>
<p><a name="bookmark182"></a>TARGET STATE-CHG • STMT. TIME&nbsp;•</p>
<p><a name="bookmark183"></a>••I 3 I 13 I»»»</p>
<p><a name="bookmark184"></a>™T ï îê T</p>
<p><a name="bookmark185"></a>. j J</p>
<p>statement number</p>
<p>1 2 3</p>
<p><a name="bookmark186"></a>DATA AREAS FOR THE</p>
<p>SYSTEM ELEMENTS</p>
<p><a name="bookmark187"></a>.... ............... ..........</p>
<p><a name="bookmark188"></a>ï &quot;\ ï rTTTTTT'î</p>
<p><a href="#bookmark189">| FACILITY DATA AREA&nbsp;|&lt;&quot;</a></p>
<p>| TRANSACTION DATA AREA ~ |&lt;••</p>
<p><a name="bookmark190"></a>•</p>
<p><a href="#bookmark191">simulation&nbsp;•</a></p>
<p><a href="#bookmark192">program&nbsp;•</a></p>
<p><a name="bookmark193"></a>•</p>
<p><a href="#bookmark194">CALL GENERA ( ET = 5 )&nbsp;•</a></p>
<p><a href="#bookmark195">CALL SEIZE&nbsp;•</a></p>
<p>CALL WORK ( WT s 6&nbsp;, ID s 3 ) »</p>
<p><a name="bookmark196"></a>CALL CLEAR&nbsp;••••••</p>
<p>call termin&nbsp;•••»•»</p>
<p>THE SIMULATION MODEL AT TIME T s 13</p>
<p>Example:</p>
<p>• In our model, priming . flow management's list consists of scheduling the first transaction generation. The user primes the list at the start of simulation by entering time T s 1 and GENERA's statement number as target. Now that the first state change has been scheduled, he passes control to flow management.</p>
<p>Each time flow management uses an entry in its list to initiate a scheduled state change, it erases that entry. In our example, at the start of simulation, there is only one scheduled state change (the first transaction generation). When flow management clears that entry and jumps to GENERA, its list is empty. But before it returns control to flow management, the model schedules new state changes, so that the simulator doesn't run out of things to do.</p><div>
<p>FIGURE 7</p></div>
<p>Examples</p>
<p>•&nbsp;In figure 6, a call to GENERA causes a transaction to be gen* erated. GENERA schedules the next generation automatically by entering the new generation time and its own statement number in the list as target. Since we want to generate a new transaction every 5 minutes, we set GENERA*s parameter ET s 5. The current simulator-clock time is T s 11, so GENERA enters the new generation time T s 16 in the list. Figure 6 shows the old transaction-generation entry; figure 7<sub>f</sub> the new one.</p>
<p>•&nbsp;Serving a transaction takes exactly 6 time units. When SEIZE acquires the facility for a transaction, it returns to the next statement, which is a call to WORK. WORK is thus called at the same simulator-clock time at which the facility begins serving the transaction. Since the facility is supposed to serve the transaction for 6 minutes, WORK schedules itself to be called a-gain at time T ♦ 6 by entering that time and its own statement number in the list; then WORK returns to flow management (and not to the next statement in the model). Tn figures 6 and 7, the activation time 13 and the target 3 are shown. Then when WORK is called again, it recognizes the transaction that has just been served and returns control to the CALL CLEAR statement, which frees the facility.</p>
<p>In our bank-window example, the user sets the model in motion by priming flow management's list. All other state changes are scheduled automatically during the simulation by GPSS-F's subroutines.</p>
<p>ACTIV1 is flow management's subroutine that searches the list for the next state change. It advances the simulator's clock to the new state-change time and returns its associated target in the variable, NADDR. Then a computed GOTO jumps to the statement designated by NADDR. The simulation program looks schematically like this:</p>
<p>COMMON NADDR</p>
<p>CALL&nbsp;ACTIV1</p>
<p>GOTO&nbsp;(1,2,3), NADDR</p>
<p>1&nbsp;CALL&nbsp;GENERA</p>
<p>2&nbsp;CALL&nbsp;SEIZE</p>
<p>3&nbsp;CALL&nbsp;WORK CALL CLEAR CALL TERMIN</p>
<p>1.6.3 Waiting Transactions</p>
<p>Transactions queued up at a facility are in the wait state; they are neither active, nor scheduled to become active at any particular time* Before we show how flow management activates waiting transactions, we describe the data areas mentioned in section 1.6.2 more thoroughly. Flow management's list actually consists of two sublists:</p>
<p>• The event list</p>
<p>Only scheduled events appear in the event list. (Events are defined roughly in section 1.1.3.) The list entry in figure 7 that occasions a transaction generation is actually in the event list,</p>
<p>• The activation list</p>
<p>This sublist is exclusively for already existent transactions. There are entries in the list for all scheduled or waiting transactions. Scheduled transactions are those whose activation times are already determined. Their entries consist of an time and a target showing what further state change should occur when the transaction is again active. Figure 7 shows such a transaction; it is scheduled to free the facility at time T s 13. Its entry is actually in the activation list. The waiting transactions are waiting to acquire a presently occupied facility. Their activa-tion-llst entries consist of a block code and a target. The block code is a negative whole number -K, where K is the identifying station number of the facility where the transaction is waiting.</p>
<p>Example:</p>
<p>•&nbsp;In figure 6, a transaction occupies the facility, which it will free at time T s 13. The transaction generated at time T ? 11 tried immediately to acquire the facility (CALL SEIZE), but found it occupied and has to wait. Hence its entry in the activation list at T s 13 has a block code (see figure 8). Since the transaction is waiting on a facility whose station number K is 1, -1 appears in the second column of the activation list. As soon as the facility has been freed, the waiting transaction can be served. Since it must then acquire the facility, the target in its activation-list entry while it waits is 2, the statement number of CALL SEIZE.</p>
<p>The transactions' data areas are the transaction matrix and the activation list. Each transaction has a line in the matrix where its parameters are stored. The first parameter in the matrix (NTX) is the transaction's identifying number, the third (ET) is its generation time. If a transaction's parameters are in the nth line in the transaction matrix, its entry in the activation list is likewise the nth line in that list. A complete description of the transaction matrix is given in chapter 2.</p>
<p>Example:</p>
<p>•&nbsp;In figure 8, transaction number 3 is in line LTX * 2. To process this transaction, flow management also uses the second line in the activation list. In this case, the transaction was generated at time T s 11 and is waiting on the facility whose station number is K s 1.</p>
<p>The facilities' data areas are the facility matrix (FAC matrix) and the state vector. The FAC matrix contains information about the transaction currently occupying the facility. For instance, the first parameter (LTX) shows which transaction occupies it<sup>-</sup>. A complete description of the FAC matrix is given in</p>
<p><a name="bookmark197"></a>chapter The state vector shows aa follows whether is occupied or free:</p><div>
<p>a facility</p></div><div>
<p>STATE(K)sO STATE(K)<a name="footnote5"></a><sup><a href="#bookmark198">5</a></sup>1</p></div>
<p><a name="bookmark199"></a>The facility numbered K is occupied The facility numbered K is free.</p>
<p><a name="bookmark200"></a>simulator clock t</p>
<p>nr»</p>
<table border="1">
<tr><td>
<p>event list</p></td><td>
<p>fac matrix</p></td><td>
<p></p></td><td>
<p>state</p></td><td>
<p>vector</p></td><td>
<p></p></td></tr>
<tr><td>
<p>target state-chg stmt. time</p></td><td>
<p>ltx</p></td><td>
<p></p></td><td>
<p>state</p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>i I I</p></td><td>
<p>1 1 1</p></td><td>
<p>1 1</p></td><td>
<p>1 0</p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
<tr><td>
<p>1 1 t 16 |</p></td><td>
<p>1 1</p></td><td>
<p>1 1</p></td><td>
<p>1</p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
<tr><td>
<p>activation List</p></td><td>
<p>transaction</p></td><td>
<p>matrix</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>target tx stmt. state</p></td><td>
<p>ntx</p></td><td>
<p>et</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1 3 1 13 1</p></td><td>
<p>1 2 |</p></td><td>
<p>1 6 I</p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>12 1-11</p></td><td>
<p>I 3 1</p></td><td>
<p>1 11 1</p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>figure 8 the</p></td><td>
<p>data areas at</p></td><td>
<p>time t =</p></td><td>
<p>13</p></td><td>
<p></p></td><td>
<p></p></td></tr>
</table>
<p>Examples:</p>
<p>*&nbsp;a facility's identifying number, K, doesn't appear explicitly in its data area, since facilities cannot be generated and annihilated. Its identifying number is, instead, simply its line number in the FAC matrix*</p>
<p>*&nbsp;Facility number K * 1 has the first line in the facility matrix. At time T s 13, the facility is occupied, since the corresponding element in the state vector has the code 0. (Figure 8)</p>
<p>1.6*4 Conditioned Activation</p>
<p>Vhen the facility is freed<sub>9</sub> one of the waiting transactions should be activated so that it can acquire the facility. In our model <sub>9</sub> the transaction waiting at the head of the queue is chosen to be activated <sub>f</sub> but more complex models can have more complex choice procedures. In general<sub>9</sub> then<sub>9</sub> the time when a transaction should be re-activated is not known when it enters a queue.</p>
<p>Hence, flow management cannot handle waiting transactions as scheduled; their activation is not to occur at some pre-arranged time. Expressed generally<sub>9</sub> the activation is to occur just when the system's state fulfils precisely specified conditions. Such activations are thus called conditioned.</p>
<p>Example:</p>
<p>•&nbsp;Figure 8 shows the data areas at time T s 13. Transaction 2's scheduled activation (line number LTX = 1) hasn't yet been carried out.</p>
<p>ACTIV1 now activates transaction 2 and jumps, via the computed GOTO, to CALL WORK<sub>f</sub> which acknowledges the end of the transaction's time at the facility and returns to the subsequent statement. Subroutine CLEAR frees the facility and returns to the statement following its call; then 7ERMIN annihilates the transaction by clearing its data areas. The data areas after these manipulations are depicted in figure 9. Note that the clock still shows T s 13. Now the facility is free and a transaction is waiting to acquire it; a conditioned activation of transaction 3 (LTX s 2&gt; must follow.</p>
<p>Flow management's subroutine, ACTIV2, undertakes all conditioned activations. It searches the activation list for transactions with block codes<sub>9</sub> at the same time checking the state-vec-tor entry of the facility where the blocked transaction is waiting. If it finds a blocked transaction whose facility is free, the transaction can acquire it: a conditioned activation results.</p>
<p>Example:</p>
<p>•&nbsp;In figure 9 <sub>9</sub> flow management would find transaction 3t with block code -1<sub>9</sub> in the second line of the activation list. The absolute value of the block code is the line number of the facility where the transaction is waiting, in this case, the facility whose number is K s 1. The state vector shows the facility free.</p>
<p>Since the transaction can now be activated, ACTIV2 activates it, sets NADDR = 2 and returns to the computed GOTO, which jumps to CALL SEIZE. SEIZE acquires the facility for the active transaction, so it returns control to the next statement in the program, which is a CALL WORK. WORK schedules the transaction to be re-activated in six minutes (see figure 10), then it returns control to flow management.</p>
<p>SIMULATOR CLOCK T</p>
<p>mti</p><div>
<p>FIGURE 9</p></div><div>
<p>fac matrix</p></div><div>
<p>STATE VECTOR STATE</p>
<p>i</p></div>
<table border="1">
<tr><td>
<p>EVENT LIST TARGET STATE-CHG STMT. TIME .</p></td><td>
<p>FAC MATRIX LTX</p></td><td>
<p></p></td><td>
<p>state state</p></td><td>
<p>vector</p></td><td>
<p></p></td></tr>
<tr><td>
<p>I I 1</p></td><td>
<p>1 1</p></td><td>
<p>1 1</p></td><td>
<p>1 1</p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
<tr><td>
<p>| 1 I 16 1</p></td><td>
<p>1 1</p></td><td>
<p>1 1</p></td><td>
<p>1</p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
<tr><td>
<p>ACTIVATION LIST TARGET TX STMT. STATE</p></td><td>
<p>TRANSACTION NTX</p></td><td>
<p>MATRIX ET</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>1 1 1</p></td><td>
<p>t 1</p></td><td>
<p>1 1</p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>12 1-11</p></td><td>
<p>1 3 1</p></td><td>
<p>1 11 1</p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p>1</p></td></tr>
</table>
<p>FREEING THE FACILITY</p>
<p>SIMULATOR CLOCK T</p>
<p>mm mm mm ^m mm tm</p>
<p>I 13 I</p>
<p>event list target state-chg stmt. time .</p>
<p>ltx \ 2 ]</p>
<table border="1">
<tr><td>
<p>1 1 i 16 |</p></td><td>
<p>ii 1 1</p></td><td>
<p>i i</p></td><td>
<p></p></td></tr>
<tr><td>
<p>activation list target tx stmt. state</p></td><td>
<p>transaction matrix ntx et</p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1 1 1</p></td><td>
<p>1 i i 1</p></td><td>
<p>i</p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>1 3 1 19 i</p></td><td>
<p>13 1 | 11 |</p></td><td>
<p>i</p></td><td>
<p>1</p></td></tr>
<tr><td>
<p>figure 10</p></td><td>
<p>acouirtng the facility 0</p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
</table>
<p>When the GPSS-F subroutines SEIZE or WORK or TERHIN return control to flow management, they always return control to ACTIV2. (The mechanism by which they do that, called an addressed exit, is described below.) To effect a conditioned activation, ACTIV2 enters the target in the variable NADDR. Then it exits to the computed GOTO, which uses NADDR to jump to the indicated program part. The computed GOTO is called the target selector. If ACTIV2 can find no conditioned activations to undertake, it exits instead to ACTIV1, which then searches for the next scheduled activation.</p>
<p>Example:</p>
<p><sup>9</sup> Figure 10 shows a system state in which no transactions are waiting at a free facility; no conditioned activations are possible. ACTIV2 returns to ACTIV1, which will now initiate the scheduled transaction generation at T s 16.</p>
<p>ACTIV2 must return, as we have seen, either to the target selector or to ACTIV1. It does that by means of two addressed exits: if a^conditioned activation is possible, ACTIV2 returns by means of the second addressed exit to the target selector; otherwise ACTIV2 takes the first addressed exit, to ACTIV1.</p>
<p>An addressed exit is a feature available from many Fortran compilers whereby one or more statement numbers, prefixed by the symbol '&amp;'<sub>9</sub> are passed as parameters to a subroutine. The subroutine then has the option of returning to one of those statement numbers, instead of returning to the following statement. This is the only non-standard Fortran feature used in GPSS-F; it can be imitated, though inelegantly, in standard Fortran.</p>
<p>With provisions for conditioned activation, the simulation program looks schematically like this:</p>
<p>COMMON NADDR 1001 CALL ACTIV1 1003 GOTO (1,2,3), NADDR</p>
<p>1&nbsp;CALL GENERA</p>
<p>2&nbsp;CALL SEIZE</p>
<p>3&nbsp;CALL WORK CALL CLEAR , CALL TERMIN</p>
<p>1005 CALL ACTIV2 (41001,41003)</p>
<p>Notes:</p>
<p>* The rest of this book is a GPSS-F programming manual. It can, nevertheless, introduce the reader to GPSS-F. Beginners should follow the preface's reading suggestions*</p>
<p>Plow management Is the heart of GPSS~F, It ensures that a model's state changes occur in proper sequence. It comprises event management and transaction management.</p>
<p>The elements of GPSS-F are stations and transactions. Transactions are the mobile components; they wander between stationary components, the stations. Both take on various states, which specify, for instance, when or under what circumstances a trans* action can proceed from one station to the next.</p>
<p>A GPSS-F simulation is run by executing a Fortran main prog« ram, large portions of which are pre-wrltten (see 2.6 and appendix A4), into which the user inserts the modules from which his model is built. The pre-written portion of the main program can be thought of as a chassis upon which the model is built; the modules from which the model is constructed are mostly calls to GPSS-F subroutines.</p>
<p>2.1 Event flanagement</p>
<p>We have already defined events roughly in 1.1.3* What counts as an event will vary slightly from one simulator to the next. For GPSS-F, we can avoid a tedious normative definition by defining events descriptively: an event is any state change scheduled in the event list. In practice, events will be changes that occur (mostly to stations) without being caused by the transactions * activities. An important class of events is transaction-generation.</p>
<p>2.1.1 The Event List</p>
<p>The event list is the data area that enables flow management to process events in correct order. An event is characterized completely by its time of occurrence and the change it comprises. Hence an entry in the event list specifies both: time and target. The list is defined as follows:</p>
<p>INTEGER EL</p>
<p>DIMENSION EL(&quot;EL1&quot;.2)</p>
<p>»</p>
<p>Each non-empty line schedules an event, so we can refer to a specific one by giving its line number (LEV s n) in the list. Each line has two fields whose meanings are:</p>
<p>EL(LEV,1) Target (statement number)</p>
<p>This field contains a statement number referring to the program part that changes the system's state as the event requires. Event management Jumps to that statement when the event's time (next field) has come.</p><div>
<p>0 F</p></div><div>
<p>0 P S S - F</p></div><div>
<p>STRUCTURE</p></div>
<p>EL(LEV,2) Event time</p>
<p>The time when the event is to take place la entered here. Event management compares the entry with the simulator's clock; when the values are the same<sub>9</sub> it Jumps to the target statement (see 2.3*2)*</p>
<p>Note:</p>
<p>*&nbsp;In describing GPSS-F, the data areas* sizes are left open by specifying a dimension symbolically in quotes. Before GPSS-F is compiled, each such symbol must be replaced throughout the source program by some actual value, tailored to the user's needs (See appendix A3)«</p>
<p>Example:</p>
<p>•&nbsp;To dimension the event list<sub>9</sub> the symbol &quot;EL1&quot; in EL(<sup>ff</sup>EL1 &quot;,2) must be replaced by an actual value, which specifies the number of 1 ines in the list* That value determines how many pending (i.e. scheduled) events at a time the system can handle.</p>
<p>2.1.2 EVENT</p>
<p>Purpose:</p>
<p>Subroutine EVENT is used to schedule an event.</p>
<p>Calling sequence:</p>
<p>CALL EVENT (EVT,EVAD,NS,&amp;1006<sub>f</sub> IPRINT)</p>
<p>Parameters:</p>
<p>EVT&nbsp;Event time</p>
<p>The time when the event should occur is specified. The event will be- scheduled only if the time specified is greater than or equal to the simulator clock's time.</p>
<p>EVAD Target (statement number)</p>
<p>The event is meant to cause a state change; this parameter specifies the statement number of the program part that carries out that state change.</p>
<p>NS&nbsp;Source number</p>
<p>When a call to EVENT schedules a transaction generation, the generating source (see 2.4.1) must be identified. NS s Source number</p>
<p>Each source has an identifying number. NS r 0</p>
<p>For all other events, that is events that don't schedule transactions to be generated, NS must be \&nbsp;zero.</p>
<p>41006 Error exit for full event list</p>
<p>EVENT returns to statement 1006 when the event cannot be scheduled. That occurs when there are no more lines in the list.</p>
<p>IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT « 0*</p>
<p>Data area:</p>
<p>EVENT alters the event list. If a transaction's generation is scheduled, the source matrix is used.</p>
<p>Algorithm description:</p>
<p>EVENT works in tandem with GENERA, described in section 2.4.1. A first reading could overlook the details of their interplay without harm. In that case the only section to read is the one labelled &quot;Schedule&quot;.</p>
<p>&quot;Reset activation time&quot;</p>
<p>IF(NS.EQ.O) GOTO 50 IF(NS.LE.&quot;SRC1&quot;) GOTO 20 RETURN 1 20 IF(EVT.EQ.O) GOTO 200</p>
<p>IF(SRC(NS,1).EO.O) GOTO 50 I x SRC(NS,1) GOTO 150</p>
<p>Subroutine GENERA always generates a transaction for some particular source. Each time it is called, it automatically schedules the source to generate another transaction. If the user wishes to reschedule a source's generation, he can do so by calling EVENT with that source's identifying number. EVENT uses the source's line in the source matrix (described in 2.4.1) to find the event-list entry that must be modified.</p>
<table border="1">
<tr><td colspan="2">
<p>&quot;Schedule&quot;</p></td><td>
<p></p></td></tr>
<tr><td>
<p>50</p></td><td>
<p>DO 100 1 = 1,</p></td><td>
<p>&quot;EL1&quot;</p></td></tr>
<tr><td>
<p></p></td><td>
<p>IF(EL(I,1).EQ.0)</p></td><td>
<p>GOTO 150</p></td></tr>
<tr><td>
<p>100</p></td><td>
<p>CONTINUE</p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN 1</p></td><td>
<p></p></td></tr>
<tr><td>
<p>150</p></td><td>
<p>EL(I » 1) &quot; EVAD</p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p>EL(1,2) s EVT</p></td><td>
<p></p></td></tr>
<tr><td>
<p></p></td><td>
<p>IF(LEL.LT.I) LEL</p></td><td>
<p>s I</p></td></tr>
</table>
<p>A free line is sought ii\ the event list; wherever one Is found, the event's time and target are entered. Event management (ACTIV1) searches the list as far as the list-end pointer, LEL, and assumes remaining lines to be empty. If EVENT uses a line beyond the pointer, it must be modified.</p>
<p>••Schedule a transaction generation&quot;</p>
<p>IF(NS.GT.O) SRC(NS<sub>f</sub>1)&nbsp;r I RETURN</p>
<p>Every source has a line&nbsp;in the source matrix correspondlng to</p>
<p>its identifying number, NS.&nbsp;When EVENT schedules a source to gen-</p>
<p><a name="bookmark201"></a>•rate a transaction, it seta a pointer to the event in that source's data area (SRC(NS,D). At generating time, GENERA identifies the responsible source by Beans.of the pointer.</p>
<p><a name="bookmark202"></a>&quot;Shut down a source&quot;</p>
<p><a name="bookmark203"></a>200 I • SRC(NS,1) EL(I,1) s 0 EL(I,2) « 0</p>
<p><a name="bookmark204"></a>When a source is shut down, its line in the event list is cleared.</p>
<p>&quot;Reset the list-end pointer, LEL&quot;</p>
<p>250 IF(EL(LEL,1).NE.O.OR.LEL.EQ.1) RETURN LEL s LEL - 1 GOTO 250 END</p>
<p>If shutting down a source frees a line at the end of the event list, the list-end pointer, LEL, must be decremented. ~</p>
<p>Notes:</p>
<p>•&nbsp;The user must schedule the first transaction generation for each source by calling EVENT. If he knows at start of simulation when a source should generate its first transaction, he can schedule the event in section 6 of the chassis, &quot;Schedule the first events* (see 2.6). He must schedule at least one event there, normally a transaction's generation. We have already referred to that procedure as priming flow management's list.</p>
<p>•&nbsp;A given call to GENERA can generate a transaction for any source; the source number is not specified in GENERA's parameter list. Hence various calls to EVENT for various sources can specify the same CALL GENERA statement in the EVAD parameter. GENERA discovers for which source it is generating a transaction by finding out which source's entry in the SRC matrix points to the event that scheduled the generation.</p>
<p>•&nbsp;GPSS-F shuts a source down automatically when <sup>v</sup>the source has generated as many transactions as are specified in GENERA's ZTX (generation limit) parameter. The user can shut down a source before it has reached its generation limit by calling EVENT with EVT * 0.</p>
<p>2.2 Transactions</p>
<p>A discrete system's transactions have private parameters., which GPSS-F maintains in a data matrix, one transaction to a line. The parameters that specify whether a transaction is ac-tive<sub>f</sub> scheduled to become active or waiting to become active are kept in the activation list and in the variables LTX and LFAM;</p>
<p><a name="bookmark205"></a>2.2*1 Transactions' Data Area</p>
<p>The parameters that characterize a transaction are assembled in a line of the transaction matrix (TX matrix). Since each transaction takes up one line<sub>9</sub> the number of lines dimensioned for the matrix specifies how many transactions at a time the system can handle. Each of them has space in the matrix for a total of &quot;7X2* parameters of which GPSS-F uses the first 18 positions. The user can use the remaining ones any way he wants. The TX matrix is defined as follows:</p>
<p>INTEGER TX</p>
<p>DIMENSION TX^TX!&quot; ,<sup>f,</sup>TX2&quot;)</p>
<p>The individual elements in each line are described below. The variable LTX -specifies the line in the TX matrix. Chapters re* ferred to in the headings detail their uses.</p>
<p>Transaction number (Chapter 2)</p>
<p>GENERA assigns each transaction entering the&nbsp;system</p>
<p>a unique, consecutive, identifying number.&nbsp;If this</p>
<p>field is zero, GPSS-F assumes the line to be&nbsp;free.</p>
<p>Duplicate number (Chapter 8)</p>
<p>It is sometimes useful to designate a number of transactions as belonging together; they are said to form a family. Since all transactions in a family have the same transaction number, they are distinguished from one another by this additional identifying number.</p>
<p>Creation time (Chapter 2)</p>
<p>The clock time when the transaction was generated is entered here.</p><div>
<p>TX(LTX<sub>9</sub>1)</p>
<p>TX(LTX<sub>f</sub>2)</p></div><div>
<p>TX(LTX<sub>f</sub>3)</p></div>
<p>Priority (Chapters 2 and 3)</p>
<p>The transaction's priority is specified here, larger the number, the greater the priority.</p><div>
<p>TX (LTX,4)</p></div><div>
<p>The</p></div>
<p>Post-preemption target (Chapter 4)</p>
<p>When a transaction is preempted, this parameter tells where it needs to be targeted to reacquire the station.</p>
<p>Residual serving time (Chapter 4)</p>
<p>When a transaction is preempted from a station, its remaining serving time is entered here. That is the amount of time it needs to spend at that station to finish being served.</p>
<p>Preemption return element (Chapter 5)</p>
<p>When a transaction is preempted from a multifacili-</p>
<p>ty, it is possible to specify that the element that</p>
<p>began serving it finish serving it. Tn that case,</p>
<p>the element's Identifying number is saved in this</p>
<p>field.</p><div>
<p>TX(LTX,5)</p>
<p>tx(ltx,6)</p>
<p><sup>t</sup>x(ltx,7)</p></div>
<p>Block time (Chapters 3 and H)</p>
<p>In case a transaction must wait, this field contains the time when it began waiting. The field is sometimes used by a policy to decide in which order to re-activate transactions.</p>
<p>Bin number (Chapter 10)</p>
<p>GPSS-F provides entitles called bins for accumulating data on transactions' behaviour. If GPSS-F should keep account of which bins the transaction is in<sub>t</sub> their numbers must be entered in fields TX(LTX,9) to TX(LTX<sub>9</sub>13). Thus, a transaction can be in up to five bins at a time.</p>
<p>Bin-entry time (Chapter 10)</p>
<p>In TX(LTX, 1*1) to TX(LTX,18) are recorded the times when the transaction entered the collections whose numbers are recorded in the corresponding five bin-number fields.</p>
<p>Free parameters</p>
<p>Here the user can store further private parameters for the transaction. He has &quot;TX2&quot; minus 18 available fields.</p><div>
<p>TX(LTX,8)</p>
<p>TX(LTX,9)</p></div><div>
<p>TX(LTX,14)</p>
<p>TX(LTX,19)</p></div>
<p>2.2.2 Transactions' States</p>
<p>Transaction-oriented models lend themselves to a stock of imagery, of which this book shall make free use. Without the images, it would be deadly wearisome to describe even the simplest model's workings. The most important thing to imagine is that transactions move from station to station during the simulation. The other thing to imagine is that almost everything that happens in a model results from some transaction's activity. We shall say of every state change, except events, that a transaction undertook it or suffered it. We say, for instance, that a transaction acquires a facility, or that it is placed in some<sub>#</sub> state. Since state changes are actually undertaken by GPSS-F's subroutines, the programs called while a transaction is active could be thought of as carrying out or even as being its activities.</p>
<p>A transaction can be in one of three states: active, scheduled or waiting. When it undertakes state changes, it is active: its activities include moving about or altering some element's state, usually its own or that of the station where it happens to be.</p>
<p>A transaction is scheduled, if it is to be re-activated at some specific time: at the given moment, it becomes active and undertakes further state changes. A transaction is waiting, if it can't go any further until the model's state fulfils some specific condition: once the condition is satisfied, the transaction can proceed. Both scheduled and waiting transactions are inactive. The one becomes active again at a specified time, whatever . the system's state may be; the other becomes active again when the system's state meets certain requirements, whatever time it may be.</p>
<p>Example:</p>
<p>• A transaction arrives at a facility<sub>9</sub> hoping to be served» but finds the facility occupied at the moment. So it has to wait. As soon as the condition</p>
<p>the facility is free</p>
<p>is satisfied, the transaction can proceed to be served, assuming it is the only one waiting. The condition will be satisfied when a single parameter changes<sub>9</sub> namely the facility's occupancy. Other types of stations can set more complex conditions, depending perhaps on numerous parameters, all of which must satisfy the condition, before the transaction may proceed.</p>
<p>Transactions don't wait around just anywhere<sub>9</sub> they always wait at a station, where they could be pictured as standing in line. We call the lines wait queues, or simply queues.</p>
<p>The proper moment arrives for a waiting transaction to become active again, when the system's state changes to fulfil the requisite condition. In order to know when that has happened, the relevant parameters must be tested; as soon as they satisfy the condition, the waiting transaction can proceed. There are two ways of watching out for the right moment:</p>
<p>1)&nbsp;For transactions waiting at most types of stations, GPSS-F keeps track of the system's state and re-activates them automatically. After each change in the system's state, transaction management checks to see if some waiting transaction's condition has been fulfilled. If so, the transaction is re-activated. Waiting transactions that are administered automatically in that way are called blocked.</p>
<p>2)&nbsp;For transactions waiting at certain types of stations, it is desirable to let the user prescribe when to re-test the system's state. He is free to call for a system-state check at any point in the program. Transactions so administered are called locked. (The stations where transactions wait in the locked state are storages, described in chapter 6, and type-1 gates, described in chapter 7.)</p>
<p>Thus waiting actually comprises two distinguishable states: blocked and locked.</p>
<p>The four states: active, scheduled, blocked and locked are exhaustive and mutually exclusive; i.e. at any machine-time moment, each transaction is in exactly one of those states. Furthermore, in machine time, only one transaction at a time may be active. Since there can be only one, we may refer to the currently active transaction without fear of confusion.</p>
<p>In simulated (i.e. simulator clock) time, more than one transaction can be active. GPSS-F simulates that state of affairs, say when two transactions are scheduled to be re-activated at some time T, by leaving the simulator clock fixed at T and activating the transactions one after the other: the first transaction proceeds until it becomes inactive, then the other.</p>
<p>The following overview summarizes the four possible transaction states (see also figure 11 and table 3):</p>
<p><a name="bookmark206"></a>activate</p>
<p><a name="bookmark207"></a>deactivate</p><div>
<p>active</p></div>
<p><a name="bookmark208"></a>scheduled activation</p><div><img src="Untitled.FR10_files/Untitled.FR10-5.jpg" style="width:191pt;height:92pt;"/></div><div>
<p>SCHEDULE</p></div><div>
<p>-------------------&gt;</p></div>
<p><a name="bookmark17"></a>conditioned activation •</p><div><img src="Untitled.FR10_files/Untitled.FR10-6.jpg" style="width:191pt;height:91pt;"/></div><div>
<p>BLOCK</p></div>
<p><a name="bookmark209"></a>a</p>
<p><a name="bookmark210"></a>i start</p>
<p>I</p>
<p>LOCK</p>
<p><a name="bookmark211"></a>locked</p>
<p>FIGURE 11&nbsp;TRANSACTION STATES AND STATE TRANSITIONS</p>
<p>• Active</p>
<p>The transaction progresses from station to station, undertaking state changes. In terms of GPSS-F's variables, a transaction is active when LTX and LFAM are set to show that it is so (see 2.3.3).</p>
<p>All three remaining states are accessible to an active transaction. It goes into the scheduled state when it has carried out all of the state changes it can, for the time being, and its activities should begin again at some specific time. GPSS-F places a transaction automatically in one of the two wait states whenever it arrives at a station and cannot proceed on account of the</p>
<p>system's present state. Depending on the type of station the transaction is blocked or locked. If the former, GPSS-F tests automatically after each state change, whether the transaction may now proceed; if the latter» the user must oall for the testa himself.</p>
<p>•&nbsp;Scheduled</p>
<p>The transaction's re-activation time is already fixed. All transactions in this state have an entry in the activation list; its field AL(LTX,2) contains a positive whole number. (The activation list is defined in section 2.3.1.) At the appointed time (given in AL(LTX<sub>9</sub>2))<sub>9</sub> the the transaction becomes active. That state transition is called scheduled activation and is undertaken by subroutine ACTIV1 (see 2.3*2).</p>
<p>•&nbsp;Blocked</p>
<p>A blocked transaction can proceed no further on account of the system's state; it has arrived at a station (other than a storage or a type-1 gate) that requires it to wait. Transaction management watches out for the proper moment to re-activate it. Blocked transactions have a negative whole number, -K, called a block code, in the AL(LTX,2) field of their activation-list entry. Its absolute value identifies the station where the blocked transaction is waiting. As soon as the system's state changes in a way that fulfils the wait condition, the transaction becomes active. That state transition is called a conditioned activation and is undertaken by ACTIV2 (see 2.3*3).</p>
<p><sup>1</sup> Locked</p>
<p>A locked transaction c an proceed no further, likewise on account of the system's state. It has reached a storage or a type-1 gate that requires it to wait. Here, the user occasions the sys-tem-state checks, as explained below. Locked transactions have a lock code in AL(LTX,2) consisting of a negative whole number, whose value is -(K+<sup>H</sup>KEND<sup>H</sup>), where K identifies the station at which it waits. &quot;KEND&quot; is the number of stations definable in GPSS-F. Since the value &quot;KEND&quot; is known to GPSS-F, it can always distinguish locked transactions from merely blocked ones: block codes run from -1 to -&quot;KEND&quot;; lock codes, from -(W&quot;FCEND&quot;) to -(&quot;KEND&quot;*&quot;KEND&quot;).</p>
<p>When the user wants to have a transaction's wait condition tested, he merely places it in the blocked state. Since the blocked transaction is then under GPSS-F's supervision, flow management tests Its wait condition at the first opportunity. The transition from locked to blocked is called a start and is effected by subroutine UNLOCK (see 2.5.3)•</p>
<p>2.3 Transaction Management</p>
<p>Transaction management has the task of overseeing transactions' passage from station to station. It keeps track of the transactions' states and, If need be, undertakes state transitions. It finds the information it needs to perform those tasks In the activation list, which it processes by means of its routines ACTIV1 and ACTIV2.</p>
<p>STATE TRANSITION&nbsp;UNDERTAKEN BY (GPSS-F SUBROUTINES)</p>
<p>SCHEDULING&nbsp;WORK, SETUP, KNOCKD, ADVANC, BUFFER</p>
<p>SCHEDULED ACTIVATION&nbsp;ACTIV1</p>
<p>BLOCKING&nbsp;SEIZE, PREEHP, GATE2, AMONG OTHERS</p>
<p>CONDITIONED ACTIVATION&nbsp;ACTIV2</p>
<p>LOCKING&nbsp;ENTER, ALLOC, GATE1, AMONG OTHERS</p>
<p>STARTING&nbsp;UNLOCK</p>
<p>TABLE 3&nbsp;TRANSACTION'S STATE TRANSITIONS</p>
<p>2.3*1 Activation List</p>
<p>The activation list contains all the information needed to activate scheduled and waiting transactions. Each line in the list corresponds to the same line in the transaction (TX) matrix; if a transaction's entry is the nth line in the TX matrix (LTX s n), its entry in the activation list is also the nth line. The activation list is defined as follows:</p>
<p>INTEGER AL</p>
<p>DIMENSION AL(&quot;TX1&quot;,2)</p>
<p>The fields of each line have the following meanings:</p>
<p>AL(LTX,1) Target.(statement number)</p>
<p>This field contains the statement number of the program part where the transaction in line LTX of the TX matrix is to continue its activity, the next time it becomes active.</p>
<p>AL(LTX,2) State code</p>
<p>A scheduled transaction has here a positive whole number giving the clock time when it is to be activated .</p>
<p>A waiting transaction has a negative whole number called a wait code. A blocked transaction's code is -k and a locked transaction's code is -(««-&quot;kend&quot;), where k is the station number of the station at which it is waiting.</p>
<p>2.3.2 ACTIV1 Purpose:</p>
<p>Subroutine ACTIV1 searches out the next event or the next scheduled transaction activation.</p>
<p>Calling sequence:</p>
<p>CALL ACTIV1 (&amp;1006)</p>
<p>Parameters:</p>
<p>41006 Exit to final analysis section</p>
<p>1006 is the statement number of the final analysis section in the GPSS-F chassis. ACTIV1 takes this addressed exit when It finds nothing in the event or activation . lists to be carried out before time N, where N is a user-specified simulation-time limit. In other words, simulation stops when the simulator's clock reaches N or when ACTIV1 can find nothing left to do.</p>
<p>Data area:</p>
<p>ACTIV1 uses the event and activation lists and the data area COMMOM/FAM/.</p>
<p>Algorithm description:</p>
<p>&quot;Clear the line pointers&quot;</p>
<p>LEV * 0 L7X s 0</p>
<p>The line pointer LEV will be set to show which line in the event list contains the event to occur next. In the same way<sub>f</sub> LTX will point to that transaction's line in the activation list that is to be activated next.</p>
<p>&quot;Set the simulator clock&quot;</p>
<p>T1 s T - RT T = N ♦ 1</p>
<p>The current simulator clock -time is kept in the variable T; the variable is<sub>f</sub> so to speak, the simulator, clock. The clock determines the flow of events in GPSS-F and may under no circumstances be modified by the user. For the time being, the clock is set to a time greater than N.</p>
<p>The variable RT is the user clock; GPSS-F always advances it the same number of units as the simulator clock, but the user can reset it to zero whenever he wants.</p>
<p>&quot;Search out the next event&quot;</p>
<p>DO 100 J s 1 <sub>9</sub> LEL</p>
<p>if(el(j,2).eq.0.0r.el(j,2).ge.t) goto 100 t « el(j,2) lev s j</p>
<p>NADDR x EL(LEV<sub>9</sub>1) 100 CONTINUE</p>
<p>The event list is searched for the event with the lowest actl-vat ion time; that time is entered in T. By that means <sub>9</sub> the simulator clock is advanced. Further<sub>9</sub> the line number of that soonest event is set in LEV. ACTIV1 searches the list no further than the line pointed to by the list-end pointer, LEL; remaining lines are empty.</p>
<p>After return from ACTIV1<sub>9</sub> control flows in the GPSS-F chassis to the target selector (See 2.6). The target selector then passes control to the program part which is to execute the state change meant to occur for that event. It does that by jumping to the event's target statement nuaber<sub>9</sub> which is placed<sub>9</sub> for the target selector's use, in the variable NADDR.</p>
<p>•Search out the next transaction activation*</p>
<p>DO 200 J s 1 , LAL</p>
<p>IF(AL(J,2).LE.0.0R.AL(J<sub>f</sub>2).GE.T) GOTO 200 T • AL(J,2) LTX s J</p>
<p>NADDR s AL(LTX,1) LEV s 0 200 CONTINUE</p>
<p>ACTIV1 now searches the activation list for a transaction scheduled to be activated sooner than the event it just finished finding in the event list. If it should find one, it sets up the system variables to activate the transaction instead: LTX is set to point to the transaction's entry in the activation list, LEV is cleared and T2ADDR and the clock time T are reset. The routine searches the list as far as the list-end pointer, LAL; remaining lines are empty.</p>
<p>&quot;Check for simulation halt*</p>
<p>IF(T.GT.K) RETURN 1</p>
<p>At search start, T was set -to a time one time unit greater than the user's time limit. That procedure insures that the search finds only times less than or equal to that limit. If no such time is found, T will have kept the value N+l, in which case simulation is to be broken off. Then, ACTIV1 returns to the final analysis section. Otherwise, control returns to the statement following the call to ACTIV1. That statement will normally be the target selector.</p>
<p>&quot;Set the user clock<sup>1</sup>*</p>
<p>RT : T • T1</p>
<p>The user's clock, RT, runs as fast as the simulator's. It con<a name="bookmark212"></a>tains the time relative to the last point when the user reset it. Until the user resets his clock, it contains the sane time as the simulator clock.</p>
<p><a name="bookmark213"></a>&quot;Family membership&quot;</p>
<p><a name="bookmark214"></a>LFAM * 0</p>
<p>IF(LTX.EQ.O) GOTO 400 IF(TX(LTX,2).EQ.O) RETURN DO 300 J s 1 , &quot;FAM1&quot; IF(TX(LTX<sub>t</sub>1).EQ.FAM(J,1)) GOTO 350 300 CONTINUE</p>
<p>RETURN 350 LFAM s J RETURN</p>
<p>If the transaction is a family member, the line number of the family's entry in the family matrix is set.</p>
<p>&quot;Clear the event's entry&quot;</p>
<p>400 EL(LEV,1) s 0 EL(LEV,2) s 0</p>
<p>When an scheduled event is carried out, its entry in the event list is cleared.</p>
<p>•Reset the list-end pointer, LEL&quot;</p>
<p>450 IF(EL(LEL,1).NE.0.0R.LEL.EG.1) RETURN LEL s LEL - 1 GOTO 450 END</p>
<p>When the event cleared happens to be at the last in the list, the list-end pointer has to be reset.</p>
<p>Notes:</p>
<p>*&nbsp;The very first state change in a GPSS-F simulation must be an event, since there are not yet any transactions. In fact, the first event will usually be a transaction's generation. At the start of simulation, ACTIV1 receives control so as to find and initiate the first event. It receives control again each time ACTIV2 runs out of conditioned activations to perform; then it searches out the next event or scheduled activation. The interplay between ACTIV1 and ACTIV2 is shown in figure 12 (see 2.6).</p>
<p>*&nbsp;When it happens that both events and transact ions' activations are scheduled for the same (simulated) time, the events take precedence. If multiple events are scheduled for the same time, the event occuring first in the list takes precedence; the same goes for simultaneously scheduled activations. That sequence can be altered by rewriting ACTIV1.</p>
<p><sup>11</sup> ACTIV1 does event management's Job by keeping track of the</p>
<p><a name="bookmark215"></a>•vent list. At the same time, ACTIV1 does part of* transaction management's Job by performing all scheduled activations.</p>
<p><a name="bookmark216"></a>2.3.3 ACTIV2 Purpose:</p>
<p>ACTIV2 tests wait conditions for all blocked transactions. If the transaction that was last active has altered the system's state so as to enable a blocked transaction to proceed, it is activated. That is called a conditioned activation.</p>
<p>Calling sequence:</p>
<p>CALL ACTIV2 (41001,41003)</p>
<p>Parameters:</p>
<p>f</p>
<p>41001 Scheduled activation exit</p>
<p>If no conditioned activation can be found, transaction management continues by looking for a scheduled activation. That means that this subroutine exits to the «CALL ACTIV1 statement in the chassis, which must carry statement number 1001« 41003 Conditioned activation exit</p>
<p>If ACTIV2 finds a conditioned activation, it exits to the target selector, which must bear the statement number 1003.</p>
<p>Data area:</p>
<p>ACTIV2 uses the activation list and the data areas COMMON/FAM/ and COMMON/POL/.</p>
<p>Algorithm description:</p>
<p>Because it administers the trial of type-2 gates (described in chapter 7) and because it must prepare certain data areas for the policies (described in chapter 3), ACTIV2 is somewhat involved. A first reading could skip to the notes at the end of this section.</p>
<p>&quot;Clear the event pointer&quot;</p>
<p>LEV = 0</p>
<p>An event may have occurred just before ACTIV2 gained control. If so, LEV will still point to the event's entry in the event list; it must be cleared.</p>
<p>&quot;Let transactions try the type-2 gates&quot;</p>
<p>IF(IT.EQ.T) GOTO 200 IT i T</p>
<p>DO 100 I * &quot;BGATE2&quot; <sub>f</sub> *EGATE2&quot; 100 STATE(I) * 1</p>
<p>ACTIV2 administers trial of the type-2 gates automatically. Each time a transaction has been active» ACTIV2 must teat whether it has altered the system state so as to permit transactions waiting at such gates to proceed. (Gates are explained In detail in sections 7.2 and 7.3«) The type-2 gates' elements in the state vector are set to show them accessible» so that a blocked transaction can try the gate (i.e. test its condition).</p>
<p>&quot;Search for a blocked transaction<sup>19</sup></p>
<p>200&nbsp;00 201 JA * 1 » LAL IF(AL(JA.2).GE.O) GOTO 201 K « - AL(JA,2) IF(K.GT.&quot;KEND&quot;) GOTO 201 IF(STATE(K).NE.0) GOTO 250</p>
<p>201&nbsp;CONTINUE IT » 0 RETURN 1</p>
<p>ACTIV2 searches for a transaction blocked at an accessible station. (An accessible station is one that is ready to serve a waiting transaction.) When it finds such a transaction, it passes control to the section labelled &quot;Assemble<sup>19</sup>. ACTIV2 searches the activation list only as far as the list-end pointer LAL; subsequent lines are empty. If it cannot find a transaction waiting at an accessible station, ACTIV2 exits to ACTIV1. When that occurs, the IT mechanism must be reset (see 7.3-3)-</p>
<p>&quot;Assemble&quot;</p>
<p>250 P0LC * 1</p>
<p>POLVEC(POLC) * JA JA s JA + 1</p>
<p>IF(JA.GT.LAL) GOTO 350 DO 300 JB s JA , LAL IF(AL(JB,2).NE.-K) GOTO 300 P0LC r POLC + 1 POLVEC(POLC) s JB 300 CONTINUE</p>
<p>When It finds one blocked transaction that could be activated, ACTIV2 searches the activation list for other transactions blocked at the same station. It enters the count of such transactions in the variable POLC and their line numbers in the vector P0LVEC. It collects that information for use by the policies, which are described in chapter 3.</p>
<p>&quot;Policy selection&quot;</p>
<p>350 CALL POLICY (•&lt;)</p>
<p>The information in POLC and P0LVEC is passed to the POLICY subroutine in COMMON. The subroutine selects one of the transactions waiting at the station K to be activated. It does that by setting the variable LTX to point to the transaction to be</p>
<p><a name="bookmark217"></a>aotivated. &quot;Conclusion*</p>
<p>IF(K.LE.&quot;EGATE2&quot;) OK * 1</p>
<p>IF(K.LT.&quot;BGATE2&quot;.OR.K.CT.*ECATE2&quot;) IT * O</p>
<p>Finally, the OK a:id IT mechanisms must be reset. OK and IT are two flags used by GPSS-F for reasons explained in sections 3.5 and 7.3.3.</p>
<p>&quot;Activate the transaction&quot;</p>
<p>MADDR « AL(LTX,1) LFAM s 0</p>
<p>IF(TX(LTX<sub>9</sub>2).EQ.O) RETURN 2 DO 400 J s 1 , &quot;FAM1&quot; IF(TX(LTX<sub>f</sub>1).EQ.FAM(J,1)) GOTO 450 400 CONTINUE RETURN 2 450 LFAM s J RETURN 2 END</p>
<p>A transaction is considered active when the variables LTX and possibly LFAM are set to show that it is active. LTX contains the line number of the transaction's entry in the TX matrix. If the transaction is a family member, the line number of its family entry in the family matrix is set in LFAM.</p>
<p>Since a transaction is now active, ACTIV2 exits to the target selector. The target selector then Jumps to the statement number contained in NADDR.</p>
<p>Notes:</p>
<p><sup>1</sup> Each transaction that has been active can have changed the system's state before it became inactive again. Thus, whenever a transaction is deactivated, ACTIV2 must receive control in order to test whether any conditioned activations have become possible. Every time anything happens, ACTIV2 asks again,, 'have any wait conditions been satisfied?' Once ACTIV2 has found all of the conditioned activations it can (perhaps none), it returns to ACTIV1.</p>
<p>•&nbsp;ACTIV2 undertakes conditioned activations in the order it finds them. If, at some given time, a conditioned activation is possible at more than one station, ACTIV2 prefers the station it happens to find first. That sequence can be altered by rewriting this subroutine.</p>
<p>•&nbsp;ACTIV2 searches the activation list only for block . codes between -1 and -&quot;KEND&quot;. By that means, it restricts itself to transactions whose re-activation transaction management administers, overlooking any locked transactions.</p>
<p>A start (explained in section 2.5.3) is undertaken by replacing the lock code -(K+^KEND&quot;) with the block code -K. The next</p>
<p>time ACTIV2 is called, the started transactions are tested for possible activation along with the other blocked transactions.</p>
<p>2.4 Transaction Generation and Annihilation</p>
<p>When a transaction enters a system, it has been, from the system's naive viewpoint, created or generated; when a transaction leaves the system, it has been, so far as the system cares, annihilated. GPSS-F has special programs for generating and annihilating transactions.</p>
<p>2.4.1 GENERA&nbsp;* Purpose:</p>
<p>This subroutine creates transactions and fills in important</p>
<p>private parameters for the transaction.&nbsp;It also schedules an</p>
<p>event, the next generation by the source&nbsp;responsible for the present one.</p>
<p>Calling sequence:</p>
<p>CALL GENERA (ET,ZTX,PR<sub>t</sub>ID,41006,IPRINT)</p>
<p>Parameters:</p>
<p>Emission interval</p>
<p>This specifies how much time should ellapse before the source generates another transaction. If the simulator's clock shows time T when GENERA is called, the next generation will occur at time T ♦ ET. Generation limit</p>
<p>The user specifies for each source, how many transactions it may generate before being shut down. When the limit is reached, GENERA generates no transaction and schedules no new generation. Priority</p>
<p>A transaction's priority is specified at generating time</p>
<p>and set in TX(LTX,4) .</p>
<p>GENERA CALL's statement number</p>
<p>This statement number is entered in the event list as the event's target. Error exit</p>
<p>GENERA takes an addressed exit to statement 1006, if it cannot find the source responsible for the generation, or if the transaction cannot be generated because the TX matrix is already full. It Is recommended in both cases to stop the simulation. (A simulation ends normally by passing control to the final analysis section of the GPSS-F chassis, which bears statement number 1006.) Trace flag</p>
<p>Trace printouts are suppressed when IPRINT * 0.</p><div>
<p>ET</p>
<p>ZTX</p>
<p>PR</p>
<p>ID</p>
<p>41006</p></div><div>
<p>IPRINT</p></div>
<p><a name="bookmark218"></a>Data area:</p>
<p>GENERA uses the TX and source matrices• Each source has a line in the source matrix (SRC matrix)<sub>9</sub> which is defined as follows:</p>
<p>INTEGER SRC</p>
<p>DIMENSION SRC(&quot;SRCI&quot;<sub>9</sub>2)</p>
<p>The two fields in each line have the following meanings:</p>
<p>SRC(J,1) Event-list pointer</p>
<p>Each event calling for the generation of a transaction has an entry in the event list* This field points to the line in the list where this source's next generation is scheduled.</p>
<p>SRC(J<sub>9</sub>2) Transactions counter.</p>
<p>Each time a transaction is generated for this source, this counter is incremented by 1.</p>
<p>GENERA also uses the variable NTXC to assign each newly generated transaction a unique Identifying number. Each time JLt generates a transaction<sub>9</sub> it increments NTXC by 1.&nbsp;~</p>
<p>Algorithm description:</p>
<p>&quot;Find the source&quot;</p>
<p>DO 100 J = 1 <sub>9</sub> &quot;SRC1&quot; IF(SRC(J<sub>9</sub>1).EQ.LEV) GOTO 150 100 CONTINUE RETURN 1</p>
<p>GENERA finds the source responsible for generating this transaction by searching the SRC matrix for the entry whose first field, SRC(J,1), matches the event list's line pointer, LEV. The contents of SRC(J,1) will have been set when generation was scheduled<sub>9</sub> either by a call to EVENT, or by the last call to GENERA for the source.</p>
<p>&quot;Advance the counters&quot;</p>
<p>#</p>
<p>150 SRC(J,1) = 0</p>
<p>SRC(J,2) a SRC(J,2) ♦ 1 NTXC s NTXC ♦ 1</p>
<p>The counter NTXC and the count of the number of transactions already generated by the current source are incremented by 1.</p>
<p>&quot;Generate&quot;</p>
<p>DO 200 LTX s 1 , &quot;TX1&quot; IF(TX(LTX,1).EQ.0) GOTO 250 200 CONTINUE RETURN 1 250 TX(LTX.I) s NTXC</p>
<p>Data area:</p>
<p>GENERA uses the ?X and source matrices. Each source has a line in the source matrix (SRC matrix), which is defined as follows:</p>
<p>INTEGER SRC</p>
<p>DIMENSION SRC(&quot;SRC1&quot;,2)</p>
<p>$1</p>
<p>The two fields in each line have the following meanings:</p>
<p>SRC(«J,1) Event-list pointer</p>
<p>Each event calling for the generation of a transaction has an entry in the event list. This field points to the line in the list where this source's next generation is scheduled.</p>
<p>SRC(J<sub>f</sub>2) Transactions counter.</p>
<p>Each time a transaction is generated for this source, this counter is incremented by 1•</p>
<p>GENERA also uses the variable NTXC to assign each newly generated transaction a unique identifying number. Each time^it generates a transaction, it increments NTXC by 1.&nbsp;<sub>#</sub></p>
<p>Algorithm description:</p>
<p>&quot;Find the source&quot;</p>
<p>DO 100 J s 1 <sub>f</sub> «SRC1&quot; IF(SRC(J,1).EQ.LEV) GOTO 150 100 CONTINUE RETURN 1</p>
<p>GENERA finds the source responsible for generating this transaction by searching the SRC matrix for the entry whose first field, SRC(J,1), matches the event list's line pointer, LEV. The contents of SRC(J,1) will have been set when generation was scheduled, either by a call to EVENT, or by the last call to GENERA for the source.</p>
<p>&quot;Advance the counters&quot;</p>
<p>150 SRC(J,1) s 0</p>
<p>SRC(J,2) s SRC(J,2) ♦ 1 NTXC s NTXC ♦ 1</p>
<p>The counter NTXC and the count of the number of transactions already generated by the current source are incremented by 1.</p>
<p>&quot;Generate&quot;</p>
<p>DO 200 LTX s 1 &quot;TX1&quot; IF(TX(LTX,1).EQ.0) GOTO 250 200 CONTINUE RETURN 1 250 TX(LTX,1) s NTXC</p>
<p>TX(LTX<sub>f</sub> 3) * T TX(LTX<sub>f</sub>4) u PR</p>
<p>An empty line is sought in the TX matrix. Here, the generation time, the priority and the transaction number are entered. If no empty line can be found, the error exit is taken.</p>
<p>&quot;Reset the event list&quot;</p>
<p>IF(LTX.GT.LAL) LAL * LTX IF(SRC(J,2).GE.ZTX) RETURN SRC(J,1) * LEV EL(LEV,1) s ID EL(LEV,2) s T ♦ ET IF(LEV.GT.LEL) LEL » LEV RETURN END</p>
<p>If the source hasn't yet reached its generation limit, GENERA schedules it to generate another transaction. The list-end pointer, LEL, shows how far the event list is filled in with scheduled events. If GENERA makes an entry beyond that point (which ACTIV1 counted down, if necessary, when it erased the event from the event list), it must reset LEL.</p>
<p>Notes:</p>
<p>*&nbsp;When a transaction is generated, it is active. Its line number in the TX matrix is placed in LTX and its activity continues with the statement following the call to GENERA.</p>
<p>•&nbsp;A given call to GENERA can generate a transaction for any source; there is no one-to-one correspondence between sources and calls to GENERA. Which source is responsible for the transaction generated by a particular call is determined by the contents of the event list and the source matrix.</p>
<p><sup>9</sup> The user must schedule the first generation for each source by calling EVENT. Normally, he does that in section 6 of the chassis, &quot;Schedule the first events<sup>91</sup>. GENERA schedules subsequent generations automatically.</p>
<p>2.4.2 TERMIN Purpose:</p>
<p>TERMIN annihilates a transaction by clearing its line in the TX matrix. In case the transaction was the last surviving member of its family, its entry in the family matrix is cleared as well.</p>
<p>Calling sequence:</p>
<p>CALL TERMIN (&amp;1005,IPRINT)</p>
<p>«a</p>
<p>p«ru«tiru</p>
<p>A1005 Exit to transaction management</p>
<p>After a tranaaotlon has been annihilated, tranaaotlon Management must be called to activate the next tranaaotlon« 1005 la the number of the CALL ACTIV2 statement. I Fit INT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT «0.</p>
<p>Data area:</p>
<p>TERMIN uses the activation list and the TX matrix. If the transaction to be annihilated is a family member, the FAM and ASH matrices are used as well.</p>
<p>Algorithm description:</p>
<p><a name="bookmark219"></a>•Family&quot;</p>
<p>IF(LFAM.EO.O) 00T0 200 FAM(LFAM,2) * FAH(LFAM<sub>f</sub>2) - 1 IF(FAM(LFAH<sub>f</sub>2).GT.0) GOTO 200 DO 100 IB « I , 3 100 FAM(LFAM<sub>f</sub>IB) s 0</p>
<p>DO 110 IB • V , &quot;ASM1&quot; 110 ASM(LFAM,IB) « 0 LFAM « 0</p>
<p>For family members, the counter in FAM(LFAM<sub>f</sub>2) is decremented. If the transaction is the last surviving member of the family, the family's data areas are cleared.</p>
<p><sup>19</sup> Annihilate&quot;</p>
<p>200&nbsp;DO 201 IA «&nbsp;1 , &quot;TX2&quot;</p>
<p><a href="#bookmark220">201&nbsp;TX(LTX<sub>V</sub>IA) a&nbsp;0</a></p>
<p><a href="#bookmark221">DO 202 IA *&nbsp;1 i 2</a></p>
<p><a href="#bookmark222">202&nbsp;AL(LTX,IA) *&nbsp;0</a></p>
<p>A transaction Is annihilated by clearing its line in the TX matrix and in the activation list.</p>
<p>&quot;Reset the llst~end pointer, LAL&quot;</p>
<p>250 IF(TX(LAL,1).NE.O.OR.LAL.EQ.1 ) RETURN 1 LAL * LAL - 1 GOTO 250 END</p>
<p>When the last transaction In the activation list 1s annihilated, the list-end pointer must be decremented, perhaps by several lines. The latter is the case when there are gaps in the next-to-last positions in the list, say from previous annihilations.</p>
<p>2.5 Transaction-State Management</p>
<p>Among GPSS-F's model-building subroutines are several whose only function is to alter the transaction's state, say from active to scheduled, or from locked to blocked* Such subroutines are discussed in this section.</p>
<p>2.5.1 ADVANC Purpose;</p>
<p>A CALL ADVANC statement deactivates a transaction for a specified time by placing it in the scheduled state. The call also specifies the transaction's re-activation target.</p>
<p>Calling sequence:</p>
<p>CALL ADVANC (AT,IDN,&amp;1005<sub>f</sub>IPRINT)</p>
<p>Parameters:</p>
<p>AT&nbsp;Detention time</p>
<p>This parameter specifies how long the transaction is to be detained at its present position in the system. ADVANC can detain a transaction while it occupies a station or while it is underway between stations. If the simulator's clock shows time T when ADVANC is called, the transaction is scheduled to be re-activated at time T ♦ AT. IDN&nbsp;Target</p>
<p>After ACTIV1 re-activates the transaction, it passes control to this statement number. &amp;1005 Exit to transaction management</p>
<p>ADVANC detains a transaction, wherever it happens to be, by deactivating it and placing it in the scheduled state. Following deactivation, transaction management is called to activate a new transaction. IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>ADVANC uses the activation list.</p>
<p>Algorithm description:</p>
<p>&quot;Detain&quot;</p>
<p>AL(L7X,1) = IDN AL(LTX,2) = T ♦ AT RETURN 1 END</p>
<p>The new activation time and target statement number are entered in the activation list.</p>
<p>2.5*2 BUFFER Purpose:</p>
<p>BUFFER deactivates a transaction. The transaction is scheduled for the current time T<sub>9</sub> but first, all transactions for which a conditioned activation is possible are processed.</p>
<p>Calling sequence:</p>
<p>CALL BUFFER (IDN<sub>9</sub>&amp;1005<sub>9</sub>IPRINT)</p>
<p>Parameters:</p>
<p>IDN&nbsp;Target</p>
<p>When the transaction is re-activated<sub>9</sub> it resumes its activity at this statement number.</p>
<p>&amp;1005 Exit to transaction management</p>
<p>After the currently active transaction has been deactivated <sub>9</sub> ACTIV2 must be called so that it can search out all transactions whose conditioned activation is possible.</p>
<p>IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>BUFFER uses the activation list.</p>
<p>Algorithm description: &quot;Deactivate&quot;</p>
<p>AL(LTX<sub>f</sub>1) s IDN AL(LTX<sub>f</sub>2) s T RETURN 1 END</p>
<p>The currently active transaction is re-scheduled for the same time<sub>9</sub> In that the target statement number and the current clock time T are entered for it In the activation list. Then BUFFER returns to ACTIV2<sub>f</sub> which seeks out all possible conditioned activations before it passes control to ACTIV1 to search for scheduled activations. Thus<sub>f</sub> the desired effect is achieved.</p>
<p>Note:</p>
<p><sup>11</sup> BUFFER places a transaction in the scheduled state. Since the activation time specified is the current clock time, a call to BUFFER is equivalent to a call to ADVANC with AT = 0.</p>
<p>2.5.3 UNLOCK Purpose:</p>
<p>UNLOCK places locked transactions in the blocked state; transaction management can then administer their re-activation. That state transition is called a start. When UNLOCK is called, it starts all transactions waiting at the station specified in its parameter list.</p>
<p>Calling sequence:</p>
<p>CALL UNLOCK (K<sub>9</sub>IPRINT)</p>
<p>Parameters:</p>
<p>K&nbsp;Station number</p>
<p>The transactions waiting at the station whose number is K are placed in the blocked state. The transition is carried out only for stations where waiting transactions can be locked<sub>9</sub> i.e. storages and type-1 gates. IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>UNLOCK uses the activation list.</p>
<p>Algorithm description:</p>
<p>&quot;Start&quot;</p>
<p>Kl s - &quot;KEND&quot; - K DO 100 I s 1 <sub>f</sub> LAL IF(AL(I<sub>f</sub>2).NE.K1) GOTO 100 AL(I<sub>V</sub>2) r - K 100 CONTINUE RETURN END</p>
<p>Locked transactions have the lock code -&quot;KEHD<sup>I,</sup>-K in their ac-tivation-list entries. The code is replaced with -K. In this way, the transactions are placed under transaction management's supervision.</p>
<p>2.6 The Chassis</p>
<p>The GPSS-F chassis determines how a simulator program is constructed by specifying the position of various sections of the program. When the user writes a simulator program, he inserts the statements (mostly calls) necessary to represent his model into the proper sections of the chassis. (See appendix A4.)</p>
<p>2.6.1 Chassis Sections</p>
<p>The chassis is divided into 12 sections, each with its own function. Some of the sections are fixed and not to be altered; others are meant to be filled in by the user.</p>
<p>•1. General Fortran declarations&quot;</p>
<p>In this section, all arrays are dimensioned<sub>9</sub> variable-type conventions specified and COMMON areas declared. The user must enter any declarations needed for his own variables.</p>
<p>&quot;2. Statement functions&quot;</p>
<p>■mr</p>
<p>The user must define here any statement functions he uses.</p>
<p>&quot;3- Clear the data areas&quot;</p>
<p>Subroutine RESET clears all data areas belonging&nbsp;immediately</p>
<p>to GPSS-F. If his own data areas need clearing, the&nbsp;user must clear them himself.</p>
<p>&quot;4. Initialize constants and control variables&quot;&nbsp;•</p>
<p>The policy, strategy and plan matrices are initialized. If the user doesn't initialize these data areas, they are processed using the default values specified by GPSS-F. The capacities of the storages must be entered in the STO matrix and the multifa-cillty capacities must be set in the MFAC matrix. The use of those matrices is explained in chapters 3» 5 and 6.</p>
<p>The INITn subroutines initialize GPSS-F's control variables. INIT1 sets the starting values for the random number generators. INIT2 constructs the multifacilities' data areas and INIT3 constructs the addressible storages' data areas, each from the appropriate capacity specifications.</p>
<p>&quot;5. Read in control values, initial values and function-value tables&quot;</p>
<p>It is often useful to read in certain values, instead of specifying them in the simulation program. The function ITREAD is a-vallable for helping in this task; it reads and echo-prints integers in 110 format.</p>
<p>&quot;6. Schedule the first events&quot;</p>
<p>In order to set the simulation rolling, the user must schedule some event. Normally, the first event will be a transaction's generation, scheduled by calling EVENT and specifying a call to GENERA as target.</p>
<p>&quot;7. Flow management 1: Events and scheduled activations&quot;</p>
<p>Simulation gets under way in this section. ACTIV1 seeks out the earliest event or scheduled activation and sets it in motion* at the same time clearing its entry from the list.</p>
<p>&quot;8. Target selector<sup>11</sup></p>
<p>This section Jumps to the part of the program meant to carry out the state transition for an event or an activated transaction. The target selector consists of a computed GOTO, which Jumps to the statement number specified in the system's variable, NADDR. It must contain all statement numbers occurring as targets in the next section. The user must write the target selector.</p>
<p>Model&quot;</p>
<p>The user must write his model, which will consist mainly of calls to GPSS-F subroutines. Any statement that flow management should be able to Jump to must bear a statement number, preferably between 1 and 999, so as not to conflict vith other statement numbers in the chassis.</p>
<p>&quot;10. Flow management 2: Conditioned_activations&quot;</p>
<p>Each time an active transaction becomes inactive, ACTIV2 tests whether any new conditioned activations have become possible. If so, it activates one of the waiting transactions and returns to section 8, which Jumps to part of the model; otherwise, it returns to section 7, which searches for the next scheduled activation.</p>
<p>&quot;11. Final analysis&quot;</p>
<p>Subroutine ENDBIN is called, which computes final values for all transactions whose behaviour has been assembled in bins (see 10.1). Otherwise, the user must write this section to analyze the results of his simulation.</p>
<p>&quot;12. Print results&quot;</p>
<p>Here, the user prints out the results of his simulation. It is always a good idea to look over the final state of the model. Subroutine REPORT makes that easy by printing out the contents of all of GPSS-F's data areas.</p>
<p>Notes:</p>
<p>• The chassis' structure clarifies flow control's procedure. First, an event takes place or a scheduled transaction is activated. Then, when the event has occured or the transaction has concluded its activity, the system's new state is checked to see whether any conditioned activations have become possible. Only when there are no more conditioned activations to carry out, will the next event occur or scheduled activation be undertaken. The following sequence is thus in force:</p>
<p>Event or scheduled activation</p>
<p>All conditioned activations thus made possible Event or scheduled activation</p>
<p>ACTIV1: EVENT OR SCHEDULED ACTIVATION</p>
<p>YES</p>
<p>• UO</p><div>
<p>TARGET SELECTOR</p></div>
<p>| L s HAVE ALL POSSIBLE CONDITIONED ACTIVATIONS BEEN UNDERTAKEN?</p>
<p>I</p>
<p>V</p>
<p>MODEL</p>
<p>I</p>
<p>V</p>
<p>ACTIV2: CONDITIONED ACTIVATION</p>
<p>I</p>
<p>FIGURE 12&nbsp;FLOW MANAGEMENT'S PROCEDURE</p>
<p>Example:</p>
<p>• A transaction schedules itself to free a facility. At the appointed time, ACTIV1 activates it; when ACTIV2 receives control, the facility will be ready to . accept another transaction. If there are any transactions waiting at the facility, a conditioned activation has become possible.&nbsp;<sub>é</sub></p>
<p>2.6.2 INIT1 Purpose:&nbsp;<sup>1</sup></p>
<p>INITt initializes the requisite values for the random number generators.</p>
<p>Calling sequence:</p>
<p>CALL INIT1</p>
<p>Data area:</p>
<p>INIT1 uses the area COMMON/DRN/.</p>
<p>Algorithm description:</p>
<p>&quot;Set the multipliers&quot;</p>
<p>All of GPSS-F's random number generators are indepent from one another. Independence is insured by the fact that each generator has its own multiplier for its iterative routine. The multipliers are stored in DFACT(RNUM)• The multipliers are set .according to the requirements explained in sections 9*2 and 9.4.1. (See also appendix A5.)</p>
<p>&quot;Specify constants and modulo&quot;</p>
<p>DMODUL s 2.*•30 DO 10 I s 1 , &quot;DRH1&quot; 10 DCONST(I) s 227623267.</p>
<p>The values of the additive constants and the modulo are set.</p>
<p>&quot;Set the starting values&quot;</p>
<p>DO 20 1*1 <sub>9</sub> &quot;DRN1&quot; 20 DRN(I) s 1. RETURN END</p>
<p>Each random number generator receives its own starting value</p>
<p><a name="bookmark223"></a>2.6.3 IMIT2 Purpose:</p>
<p>Subroutine INIT2 divides up the servloe element matrix to eor-respond to the individual multifaellitles. (See 5*1)</p>
<p>Calling sequence:</p>
<p>CALL INIT2 (49999)</p>
<p>Parameters:</p>
<p>49999 List-end exit</p>
<p>If the sum of the service elements of all multifaellitles is larger than the number of available lines In the SE matrix, simulation is broken off at once.</p>
<p>Data area:</p>
<p>INIT2 uses the data'area COMMON/MFA/.</p>
<p>Algorithm description:&nbsp;•</p>
<p>&quot;Specify the multifaellitles used&quot;</p>
<p>LSE a 1</p>
<p>DO 100 I s 1 , •HFAC1&quot; IF(MFAC(I,2).EQ.0) GOTO 100</p>
<p>The user must fill in the second field of each line in the MFAC matrix, MFAC(MFA,2), with the number of the service elements for that multifacility. If the multlfacllity's entry in this field is zero, it is assumed to remain unused; INIT2 sets up no space in the SE matrix for it.</p>
<p>&quot;Set up a section of the SE matrix&quot;</p>
<p>MBV(I) s LSE LSE s LSE ♦ MFAC(I,2) IF(LSE-1.GT.&quot;SE1&quot;) GOTO 200 100 CONTINUE</p>
<p>RETURN 200 RETURN 1 END</p>
<p>Each section of the SE matrix contains the data areas for the service elements of a multifacility. Each section of the SE matrix is .specified by the number, called the basis number, of its first line. In each pass through the loop, the basis number of the next section is determined and entered in the multifacility basis vector. In case INIT2 runs over the end of the SE matrix, it aborts the simulation.</p>
<p><a name="bookmark224"></a>Votes:</p>
<p><a name="bookmark225"></a>• IMT2 may not be called before the end of section H of the chassis, since construction of the SE matrix depends on values entered in the NFAC matrix.</p>
<p>2.6.* INIT3 Purpose:</p>
<p>Subroutine INIT3 divides up the segment matrix to correspond to the capacities of the storages. (See 6.4.1.)</p>
<p>Calling sequence:</p>
<p>CALL INIT3 (49999) Parameters:</p>
<p>49999 List-end exit</p>
<p>When the sum of the capacities of the addresslble storages is larger than the number of lines allocated to the segment matrix, simulation is aborted.</p>
<p>Data area:</p>
<p>INIT3 uses areas COMMON/SBV/, COMMON/STO/ and COMMON/STR/. Algorithm description: &quot;Check for addressibiiity&quot; LSM r 1</p>
<p>DO 100 I s 1 , &quot;ST01&quot; IF(STRAMA(I,1).EQ.O) GOTO 100</p>
<p>The user specifies in the strategy matrix (STRAMA) which strategy is to be used to allocate and free storages (see 6.5). If a line of this matrix is empty, then INIT3 assumes it isn't dealing with an addresslble storage. In that case, it doesn't set up a section in the segment matrix.</p>
<p>&quot;Set up a section in the segment matrix**</p>
<p>SBV(I) r LSM SM(LSM,1) = ST0(1,2) SM(LSM,2) s - 1 LSM s LSM ♦ ST0(I,2) IF(LSM-1 . GT.&quot;SM1**) GOTO 200 100 CONTINUE</p>
<p>RETURN 200 RETURN 1 END</p>
<p>A section is set up in the segment matrix by setting its ba-</p>
<p>sls-llne number In the storage basis vector. Then the entire segment Is aarked with Its length and an Indicator showing that It Is free. The length of the section corresponds to the capacity of the storage.</p>
<p>In each pass through the loop, the basis number for the next seotlon Is computed. If the number runs over the end of the segment matrix, simulation Is aborted.</p>
<p>Note:</p>
<p>* INIT3 may not be called before the end of section 4 of the chassis, since the stragegy and STO matrices must be filled In first.</p>
<p>2.6.5 RESET Purpose:</p>
<p>Subroutine RESET clears all of GPSS-F's data areas. Calling sequence: CALL RESET Data area:</p>
<p>All of the data areas to be cleared are In COMMON.</p>
<p>Algorithm description:</p>
<p>&quot;Clear the simulation clocks&quot;</p>
<p>T s 0 RT s 0</p>
<p>At simulation start, the simulation clocks are set to zero.</p>
<p>&quot;Set the OK and IT mechanisms&quot;</p>
<p>OK s 0 IT = 0</p>
<p>These mechanisms require that the OK and IT flags be pre-set</p>
<p>to zero.&nbsp;(See 3-<sup>i</sup>* and 5.3.3.)</p>
<p>&quot;Reset the NTXC counter&quot;</p>
<p>MTXCs 0</p>
<p>The counter NTXC is zeroed.</p>
<p>&quot;Reset the list<sub>r</sub>end pointers'*</p>
<p>LEL »1 LAL = 1</p>
<p>The two list-end pointers<sub>9</sub> which show how far the event and activation lists need to be searched, are reset*</p>
<p>&quot;Clear the data areas&quot;</p>
<p>(Program listed in appendix A5.)</p>
<p>All of GPSS-F's data areas are cleared at start of simulation.</p>
<p>3 STATIONS AND POLICIES</p>
<p>If a GPSS-F station cannot process an arriving transaction immediately <sub>9</sub> the arrival is placed in the wait state. That can happen, in principle, at any GPSS-F station; the particular circumstances that determine whether an arriving transaction must wait include the station's type and current state. A transaction that must wait is placed in the wait queue (or simply queue) in front of the station. When the ; station is again ready, one of the transactions in its queue is selected and activated, so that it may begin its processing phase. The procedure by which a waiting transactions is selected is called a policy.</p>
<p>In .general, a station that is ready to process a transaction is said to be accessible; in the reverse case, inaccessible. Facilities, for example, are accessible precisely when they are not occupied by a transaction, but the accessibility of other types of stations may be a a more complex matter. The types of GPSS-F stations and the chapters where they are discussed in detail are listed below:</p>
<table border="1">
<tr><td>
<p>a</p></td><td>
<p>Facility (4)</p></td></tr>
<tr><td>
<p>•</p></td><td>
<p>Multifacility (5)</p></td></tr>
<tr><td>
<p>a</p></td><td>
<p>Storage (6)</p></td></tr>
<tr><td>
<p>•</p></td><td>
<p>Type-1 Gate (7)</p></td></tr>
<tr><td>
<p>a</p></td><td>
<p>Type-2 Gate (7)</p></td></tr>
<tr><td>
<p>a</p></td><td>
<p>Gather station (7)</p></td></tr>
<tr><td>
<p>•</p></td><td>
<p>Gather station for families (8)</p></td></tr>
<tr><td>
<p>•</p></td><td>
<p>User chain and trigger station (7)</p></td></tr>
<tr><td>
<p>•</p></td><td>
<p>User chain and trigger station for families (8) *</p></td></tr>
</table>
<p>3.1 Policies</p>
<p>From a systems-analytic viewpoint, each transaction-oriented system is composed of elementary subsystems. Each of these subsystems consists of a station and its queue (see figure 13). Of the many types of policies for selecting transactions from a queue, the following sections set out the most important.</p>
<p>3.1.1 Priority and Preemption</p>
<p>The criterion by means of which a transaction is selected from a queue is reflected in the transaction's priority. High priority</p>
<p>means greater importance and sooner selection from the queue, A priority-driven policy searches a given queue for the the trans« action with the highest priority and selects It to be activated*</p>
<p>Priority-driven policies give preference to the Important transactions<sub>9</sub> but in systems with long queues<sub>9</sub> low-priority transactions nay not be processed sufficiently<sub>f</sub> or even at all*« Other kinds of policies take pains to avoid unjustlfiedly handicapping low^priority transactions.</p>
<p>In especially pressing cases<sub>9</sub> we may even want to clear a cur* rently occupied station to permit an especially Important arrival to be processed immediately* The mechanism for doing that is called preemption* Preemptions always take up some amount of time* Thus, though a policy with preemption can always react quickly to pressing cases<sub>9</sub> this advantage is bought at the cost of setup time<sub>9</sub> which increases administrative overhead*</p>
<p>In a system with priority management and preemption» every imaginable policy can be built*</p>
<p>-----------• - I&nbsp;I</p>
<p>III I II I II I----1 STATION I</p>
<p>----------• I&nbsp;I</p>
<p>WAIT QUEUE&nbsp;----------------</p>
<p>FIGURE 13&nbsp;STATION WITH QUEUE</p>
<p>3-1.2 FIFO (First In<sub>9</sub> First Out)</p>
<p>The FIFO policy assigns priorities according to arrival time: the transaction longest in the queue gets the highest priority. FIFO's principle is &quot;first-come, first-served&quot;; it corresponds to a simple ideal of fair treatment. A preemptive FIFO policy clears a station to allow an arriving transaction to be processed, if the arriving transaction has the higher priority.</p>
<p>Example:</p>
<p>* A doctor's patients are admitted according to their order of arrival in the waiting room. When an emergency case arrives, the patient being treated at the moment must return to the waiting room. He has been preempted.</p>
<p>3.1.3 LIFO (Last In, First Out)</p>
<p>Where FIFO selected the transaction longest in the queue, LIFO selects the newest. LIFO works according to the stacking principle: incoming work goes on top of the stack and the stack is worked off top-down.</p>
<p><a name="bookmark226"></a>Example</p>
<p>• Tourists rids to the top of the Washington Monument in an elevator. The last tourist in the elevator is the first tourist out.</p>
<p>3*1SJF (Shortest Job First)</p>
<p>SJF assigns the highest priority to the transactions with the shortest processing times. Throughput can be optimized in this way, i.e. the greatest number of tasks can be processed and the largest number of customers satisfied. The moral of this policy is that it's a good idea to do the short work as fast as possible before starting in on the tough work.</p>
<p><a name="bookmark227"></a>Examples</p>
<p>• A computer's operating system gives shorter jobs higher priority. Long jobs have to settle for long waiting times since they take up large portions of the system's available resources. SJF can be equipped with preemption, just like any other policy.</p>
<p>3*1*5 Round-Robin (Cyclic Policy)</p>
<p>Round-robin gives each waiting transaction a time slice on the station. At the end of the slice, round-robin checks whether the transaction has been completely processed: if so, it can leave the station; otherwise, it's thrown back in the queue and its remaining processing time is noted. (See figure 14.) This policy assumes it's a good idea to process each transaction a little bit, then go on to the next. It is especially useful when waiting transactions can tend to other matters in between being processed by the station, say matters not involving this station.</p>
<p>Example:</p>
<p>• In a time-sharing computer system, each user gets a slice of time every so often. Each job gets processed, though the rule is: the more users, the slower everybody runs.</p>
<p>Round-robin can be implemented, of course, only when preemption is available: each task gets preempted at the end of its time slice. A task is, however, not preempted because a higher-priority task arrives; it is preempted on account of a regular report from the clock.</p>
<p>Round-robin is more flexible when the time slices are assigned on the basis of transaction priority instead of being constant. Such a policy is called RRP (Round-Robin with priorities).</p>
<p>• •</p>
<p><a href="#bookmark228">—--- * •</a></p>
<p><sup><a href="#bookmark229">11</sup> I&nbsp;I&nbsp;•&nbsp;«</a></p>
<p>TP*</p>
<p>I III! I I I----1 STATION j----• FINISHED ?</p>
<p><a href="#bookmark230">I&nbsp;I •&nbsp;•</a></p>
<p><a href="#bookmark231">WAIT QUEUE&nbsp;—---------------•&nbsp;•</a></p>
<p><a name="bookmark232"></a>• •</p>
<p>I NO</p>
<p>I</p>
<p>FIGURE 14&nbsp;ROUND-ROBIN POLICY</p>
<p>QUEUE</p>
<p><a href="#bookmark233">(ROUND-ROBIN) _________• •</a></p>
<p><a href="#bookmark234">—&gt; nun i—&nbsp;« •</a></p>
<p><a href="#bookmark235">_________• i _______________„ • •</a></p>
<p><a href="#bookmark236">Il I • «YES I----1 STATION |----• FINISHED ? •---&gt;</a></p>
<p><a href="#bookmark237"><a name="bookmark237"></a>I I •&nbsp;• _________» j ________________ • •</a></p>
<p><a href="#bookmark238">-&gt; huh i—&nbsp;• •</a></p>
<p><a href="#bookmark239">i_________• •</a></p>
<p><a href="#bookmark240">QUEUE&nbsp;| NO</a></p>
<p><a href="#bookmark241">I (FIFO)&nbsp;|</a></p>
<p>*</p>
<p>• • • •</p>
<p><a href="#bookmark242">I&nbsp;___. YES •&nbsp;«</a></p>
<p>-------------------------------• N s 0 ? •</p>
<p><a name="bookmark243"></a>• •</p>
<p><a name="bookmark244"></a>• • • /</p>
<p>| NO</p><div>
<p>FIGURE 15</p></div>
<p>LIMITED-FEEDBACK POLICY</p>
<p>3.1*6 LFB (Limited Feedback)</p>
<p>Because cyclic policies have high overhead, we may often want to limit the number of transactions taking part in round-robin. There are various ways of dividing the transactions into two groups: the one handled by round-robin, the other by some other policy.</p>
<p>A simple example of such a policy would be LFB. LFB assigns each transaction entering round-robin some number of time slices, N; each time a transaction uses one of its time slices, its number of remaining slices is decreased by 1. When a transaction runs out of round-robin slices, it is placed in another queue, from which it is selected by some other policy, say FIFO. Transactions are selected from the FIFO queue only when there are no more transactions in the round-robin queue. (See figure 15.)</p>
<p>3*2 Dynamic Priority Assignment</p>
<p>Each transaction is assigned a static priority when it is generated; it keeps that priority so long as it is in the system. Dynamic priority assignment, on the other hand, gives waiting transactions priorities that depend on specific conditions. .</p>
<p>3.2.1 Types of Dynamic Priority Assignment</p>
<p>The moment when priorities should be assigned depends on the problem to be solved. Two typical procedures are the following:</p>
<p>•&nbsp;Priorities are assigned at regular intervals.</p>
<p>*&nbsp;Priorities are assigned every time a station is freed and the</p>
<p>policy must select a new task.</p>
<p>The more often new priorities are assigned, the better they reflect the system's current condition. Since, however, each priority assignment means administrative overhead, up-to-date priorities are paid for in time and effort. When processing time is short compared with priority assignment's overhead, the overhead can't be ignored. Oyerhead time depends on the number of tasks whose priorities must be computed and on the complexity of the computation.</p>
<p>Any of a multitude of conditions can determine the priority dynamically assigned to a transaction. Nothing especially general can be said about them here, except that the priorities assigned should be the value of some function of the system's current state. The following sections describe a few typical policies for dynamic priority assignment.</p>
<p>3.2.2 UTL (Upper Time Limit)</p>
<p>This policy can only be used on queues at facilities or multi-facilities . Each transaction can be assigned an upper time limit,</p>
<p>within which tine it sust be processed. The closer the tine Unit approaches, the higher the priority goes. In that case, the transaction's priority is a simple function of the time remaining before the limit. The remaining time could include the transaction's processing time. The very simplest function for specifying the priority would be the following linear equation:</p>
<p>Priority * -Remaining time</p>
<p>All priorities thus assigned would be negative and -1 would be the highest priority.</p>
<p>3.2.3 UTLP (Upper Time Limit with Priorities)</p>
<p>A refinement and improvement of the UTL policy reassigns priorities on the basis of the transaction's initial priority. It raises a transaction's priority faster, if it had a high priority to begin with.</p>
<p><a name="bookmark245"></a>A</p>
<p>201 XXXXXX TASK WITH IP s 1&nbsp;••«*•»*»»«»*»«•»*</p>
<p><a href="#bookmark246">IP&nbsp;»X</a></p>
<p><a href="#bookmark247">|R •••«•• TASK WITH IP s 4&nbsp;•&nbsp;X</a></p>
<p><a href="#bookmark248">II&nbsp;«X</a></p>
<p>10&nbsp;«X 151R • X</p>
<p>11&nbsp;«X IT »X</p>
<p><a href="#bookmark249">|Y&nbsp;«X</a></p>
<p><a href="#bookmark250">I&nbsp;«X</a></p>
<p><a href="#bookmark251">10| • I&nbsp;X •</a></p>
<p><a href="#bookmark252">I&nbsp;X •</a></p>
<p><a href="#bookmark253">I&nbsp;X •</a></p>
<p><a href="#bookmark254">I&nbsp;X&nbsp;•</a></p>
<p><a href="#bookmark255">51&nbsp;X&nbsp;•</a></p>
<p><a href="#bookmark256">I&nbsp;X&nbsp;•</a></p>
<p><a href="#bookmark257">I&nbsp;X</a></p>
<p><a href="#bookmark258">I&nbsp;X</a></p>
<p>1| X&nbsp;TIME ---♦—♦—♦—♦—♦——♦—♦—♦—♦—♦—♦—♦—♦—&gt;—♦—♦—&gt;</p>
<p><a href="#bookmark259">1&nbsp;5&nbsp;10&nbsp;15</a></p>
<p>FIGURE 16&nbsp;PRIORITY CHANG.E IN UTLP FOR TRANSACTIONS WITH</p>
<p>DIFFERENT INITIAL PRIORITIES, IP</p>
<p>Figure 16 show3 how the priorities of two transactions could rise o.ver time in UTLP. A transaction's initial priority, IP, is</p>
<p>specified when it is created. In the figure, a transaction is created at time T * 1 with initial priority IP « 1. Its priority increases by 1 each time unit, so that by time T « 13<sub>9</sub> it has P * 13. Another transaction enters the system at time T * 8 and receives initial priority iP * 4. But the policy raises the second transaction's priority by 4 for each time unit that passes, so that by time T * 14, it has reached the upper priority limit P s 20. An essential feature of such policies is that the transaction-processing sequence within a queue can change: in UTLP, transactions can catch up from behind.</p>
<p>3*2.4 W7LP (Waiting Time Limit with Priorities)</p>
<p>If a facility is especially burdened, transactions with low, static priorities may have to wait too long to be processed. To help matters, a dynamic priority assignment could see to it that transactions that have waited long, gradually get better and better priorities. The catch is that transactions with high initial priorities have to settle for longer total processing times. Note that if all arriving transactions have the the same priority, and if all waiting transactions bubble up at the same rate, WTL reduces to FIFO.</p>
<p>Example:</p>
<p>• A facility's queue Is equipped with 20 possible priority levels. It can be shown that with dynamic priority assignment, low-priority transactions have lower total processing times and thus lower total waiting times than with static assignment. (See 11.4)</p>
<p>3*3 Policies in CPSS-F</p>
<p>Using the two mechanisms, priority-driving and preemption, any desired policy can be built. Priority-driving is possible in every queue in GPSS-F; GPSS-F supports preemption, however, only for facilities and multifacilities. The subroutines that carry out preemptions for those stations are respectively PREEMP and MPREEM. Preemption for storages could be handy for some models, but a general subroutine for such cases would be unwieldy. Thus we leave it to the user to write his own special-purpose routines to effect the particular kind of storage preemption he needs.</p>
<p>GPSS-F's priority-driving support consists of several features. First, each transaction carries a priority, freely chosen by the user at generation time, in TX(LTX,i). Further, there are procedures driven by other kinds of priorities, e.g. FI^O, for selecting transactions from a queue to be processed. Since reasonable selection criteria could well differ from queue to queue, the user can assign each station its own* specific policy, each of which can be designed to handle the special selection criteria for its station. For simple cases, such as priority selection or FIFO selection, GPSS-F supplies pre-built policies.</p>
<p>When a station becomes accessible, transaction management's task (undertaken in ACTIV2) is to find a waiting transaction and</p>
<p>activate it so that it can begin being processed. To find out precisely which transaction should be activated, ACTIV2 sets up the POLVEC vector and calls POLICY. POLICY figures out which of the policies belongs to the station in question and calls it. Pi* nally, this last subroutine picks a transaction and passes its 7X-matrix line number back to POLICY, which passes the result back to ACTIV2. Figure 17 is a bird's-eye view of the program hierarchy and the data areas passed.</p>
<p>•----------— POLVEC -------------- POLVEC --------</p>
<p><a name="bookmark260"></a>I&nbsp;I----------&gt;l&nbsp;I—-------&gt;1&nbsp;|</p>
<p>I ACTIV2 I&nbsp;I POLICY t&nbsp;| SELECTION |</p>
<p>|&nbsp;|&lt;----------1&nbsp;|&lt;----------1&nbsp;J</p>
<p>-------------- LTX ------~------ LTX ----—--------</p>
<p><a name="bookmark261"></a>FIGURE 17&nbsp;SUBROUTINE HIERARCHY OF A CALL TO POLICY</p>
<p>3.3.1 POLICY Purpose:</p>
<p>The POLICY subroutine determines which policy processes transactions waiting in the the station's queue whose station number is K; then it calls the subroutine that effects that policy.</p>
<p>Calling sequence:</p>
<p>CALL POLICY (K)</p>
<p>Parameters:</p>
<p>K&nbsp;Station number</p>
<p>The station number X specifies the station from whose queue a waiting transaction is to be selected.</p>
<p>Data area:</p>
<p>The variables used by POLICY are collected in LABELLED COMMON/POL/.</p>
<p>POLVEC (&quot;TXÎ&quot;) (Policy Vector)</p>
<p>ACTIV2 enters here the line numbers of all blocked transactions that are waiting at station K. A transaction's line number LTX entered in the POLVEC vector designates its position in the activation list and in the TX matrix.</p>
<p>POLC (Queue length)</p>
<p>ACTIV2 enters here at the station.</p><div>
<p>number of blocked transactions</p></div><div>
<p>waiting</p></div><div>
<p>the</p></div>
<p>POL (Policy Matrix)</p>
<p>In GPSS-F, each queue of transactions waiting at a station can bt processed by its own policy. The user enters data in the poll» ey Matrix that specify which policy processes each station. It la defined as follows:&nbsp;—&gt;</p>
<p>INTEGER POL</p>
<p>DIMENSION POL(&quot;P0L1&quot;,2)</p>
<p>The individual elements have the following meanings:</p>
<p>POL(I,1) Station number</p>
<p>The station's station number K to be processed by the policy is designated in P0L(I,1).</p>
<p>P0L(I,2) Policy number</p>
<p>Each policy is designated by a number. The number of the policy that is to process the queue at the station designated in P0L(I,1) is entered here.</p>
<p>Algorithm description:</p>
<p>&quot;Find the policy&quot;</p>
<p>DO 100 I s 1., &quot;P0L1&quot; IF(P0L(I,1).NE.K) GOTO 100 IADDR s P0L(I,2) - GOTO 120 100 CONTINUE IADDR = 1 120 CONTINUE</p>
<p>GOTO (1,2,3,*»,5) , IADDR</p>
<p>The policy matrix is searched to find the policy assigned to station K. If there is no entry in the policy matrix for station K, its queue is processed using the policy whose number is 1.</p>
<p>&quot;Call the policy-implementing subroutine&quot;</p>
<p>1&nbsp;CALL PFIF0 RETURN</p>
<p>2&nbsp;CALL FIFO RETURN</p>
<p>3&nbsp;CALL P0LI3 RETURN</p>
<p>1»&nbsp;CALL P0LI4</p>
<p>RETURN 5 CALL P0LI5 RETURN END</p>
<p>A computed GOTO is used to jump to the subroutine call appropriate to station K. That subroutine sets the line number of the selected transaction in the variable LTX. Since LTX is in a COMMON area, it is available to ACTIV2. Policy numbers 1 and 2 are assigned to the pre-built GPSS-F policies PFIF0 and FIFO.</p>
<p>• If the user writes his own policies, they must be assigned ni»bers and Fortran names. The user enters the station and policy numbers in the policy matrix by writing the appropriate statements into section 4 of the chassis«; The policy's name must appear in a CALL statement added at the point corresponding to its * policy number to the above section of subroutine POLICY.</p>
<p>3.3-2 PFIFO Purpose:</p>
<p>PFIFO selects the blocked transaction with the highest priority | If more than one transaction has the same priority, then further selection is on the basis of the FIFO policy.</p>
<p>Calling sequence:</p>
<p>CALL PFIFO</p>
<p>Data area:</p>
<p>PFIFO uses the area COMMON/POL/.</p>
<p>Algorithm description:</p>
<p>&quot;Initialize the search*</p>
<p>IPR x 1</p>
<p>LTX s POLVEC(I) IF(POLC.EQ.I) RETURN</p>
<p>The search begins with the first transaction in the policy vector. The variables used in the search are initialized. If only one transaction is in the queue, the search can be avoided; then the subroutine returns to the calling program, POLICY.</p>
<p>&quot;Compare&quot;</p>
<p>DO 100 1=2, POLC LTX1 : POLVEC(I)</p>
<p>IF(TX(LTX,4)-TX(LTX1,4)) 110 , 120 , 100 110 LTX = LTX1 IPR = 1</p>
<p>POLVEC(I) x LTX GOTO 100 120 IPR s IPR ♦ 1</p>
<p>POLVEC(IPR) = LTX1 A 100 CONTINUE</p>
<p>The policy vector is sorted according to priority with highest priority first. IPR is the count of transactions with the highest occuring priority.</p>
<p>•Call FIFO*</p>
<p>POLC » IPR</p>
<p>IF(IPR.LE.1) RETURN</p>
<p>CALL FIFO</p>
<p>RETURN</p>
<p>END</p>
<p>If more than one transaction has the highest occuring priority, FIFO selects the winner. Since these transactions have been sorted to the top of the vector, only they must be searched by FIFO. Hence PFIFO sets the number IPR in POLC. If, on the other hand, there is only one transaction with the highest priority, PFIFO returns to POLICY.</p>
<p>3-3-3 FIFO Purpose:</p>
<p>FIFO finds the transaction in a queue that has the earliest block time, i.e., the one that has been waiting the longest. If there is more than one such transaction, the one with the smallest transaction number is selected. If more than one transaction has the same transaction number, they must all belong to a family; then the duplicate number decides.</p>
<p>Calling sequence:</p>
<p>CALL FIFO</p>
<p>Data area:</p>
<p>FIFO uses the area COMMON/POL/.</p>
<p>Algorithm description:</p>
<p>•Initialize the search<sup>11</sup></p>
<p>LTX s P0LVECO) IF(P0LC.EQ.1) RETURN</p>
<p>The search begins with the first transaction in the policy vector. The variables required in the search are initialized. If there is only one transaction in the queue, the search can be a-voided; then the subroutine returns to the calling program.</p>
<p>&quot;Compare*</p>
<p>do 150 i s 2 , polc ltx1 s polvec(i) 100 if(tx(ltx,8)-tx(ltx1,8)) 150 , 110 , 130 110 if(tx(ltx,1)-tx(ltx1,1)) 150 , 120 , 130 120 if(tx(ltx,2)-tx(ltx1,2)) 150 , 150 , 130 130 ltx = ltx1 150 continue</p>
<p>RETURN END</p>
<p>The transactions in the policy vector are searched in order of occurrence. The variable LTX is set to point to the transaction selected.</p>
<p>3-3.4 Dynamic Priority Assignment with Subroutine DYNVAL Purpose:</p>
<p>DYNVAL is used to assign priorities dynamically. The subroutine searches out all transactions waiting at the station K and assigns them a new priority. The new priority is computed by the function DYNPR<sub>V</sub> which is written by the user.</p>
<p>Calling sequence:</p>
<p>CALL DYNVAL (K<sub>f</sub>PCOUNT,IPRINT)</p>
<p>Parameters:</p>
<p>K&nbsp;Station number</p>
<p>All transactions waiting at the station designated by this number receive a new priority. PCOUNT Count of reassigned priorities</p>
<p>The number of transactions that received new priorities is returned in this counter.</p>
<p>Data area:</p>
<p>DYNVAL uses the activation list and the transaction matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Reassign the priorities&quot;</p>
<p>PCOUNT s 0</p>
<p>DO 100 I s 1 <sub>f</sub> LAL</p>
<p>IF(AL(I<sub>f</sub>2).NE.-K. AND. AL( T <sub>f</sub> 2) . NE^K-^KEND&quot;) GOTO 100 PR s TX(I,i|) TX(I<sub>f</sub>M) s DYNPR(I ) PCOUNT s PCOUNT ♦ 1 100 CONTINUE RETURN END</p>
<p>The activation list is searched for transactions blocked or locked at the station K. The new priority is computed by the function DYNPR and set in TX(LTX<sub>f</sub>4).</p>
<p>Notes:</p>
<p>* Administrative overhead incurred by assigning priorities dynamically is usually too big to ignore. The overhead depends on the number of new priorities assigned and the complexity of the priority computation.</p>
<p>•&nbsp;The user is responsible for accounting for the overhead of dynamic priority assignment.</p>
<p>*&nbsp;DYNVAL reassigns priorities only to transactions in the queue; any transactions currently occupying the station are ignored.</p>
<p>3.* The State Vector</p>
<p>All GPSS-F stations can be accessible or inaccessible, i.e. ready to process an arriving transaction or not ready. A transaction arriving at an inaccessible station is placed in the wait state and thereby entered in the station's queue. Each station has an element in the state vector, which specifies its state:</p>
<p>STATE(K) s 0 Station number-K is inaccessible. STATE(K) s 1 Station number-K is accessible.</p>
<p>The element number, K, in the state vector is the station's Identifying number. In addition to a station number, each station has a type number, which identifies it among stations of the same type. A station's station number can be computed from its type and type number when the construction of the state vector is taken into account. (The state vector's construction is shown in appendix A2; the following examples refer to the state-vector diagram there.)</p>
<p>Example:</p>
<p>* If the maximum number of facilities set by the program definition parameter &quot;FAC1&quot; is &quot;FAC1&quot; s 20, the multifacility with the type number MFAC s 5 is the station whose station number is 25.</p>
<p>In order to be able to refer easily to state-vector elements belonging to a particular station type, the upper limit of each section of the state vector has a special designator as shown in the following list:</p>
<p>&quot;FAC1&quot; &quot;EFAC&quot; ♦ &quot;EMFAC&quot; • &quot;ESTO&quot; ♦ &quot;EGATE1&quot; &quot;EGATE2&quot; &quot;EGATH1&quot; &quot;EGA7H2&quot; &quot;EUCHN1&quot;</p><div>
<p>EFAC&quot;</p>
<p>EMFAC&quot;</p>
<p>ESTO&quot;</p>
<p>EGATE1&quot;</p>
<p>EGATE2&quot;</p>
<p>EGATH1&quot;</p>
<p>EGATH2&quot;</p>
<p>EUCHN1 &quot;</p>
<p>EUCHN2&quot;</p></div><div>
<p>MFAC1&quot; &quot;ST01&quot; GATE1&quot; &quot;GATE2&quot; &quot;GATH1&quot; &quot;GATH2&quot; &quot;UCHN1&quot; <sup>ff</sup>UCHN2<sup>ff</sup></p></div><div>
<p>&quot;FAM1&quot;</p>
<p>&quot;FAtH&quot; 2</p></div>
<p>Example:</p>
<p>The last&nbsp;multifacility has the state-vector element</p>
<p>STATE I &quot;EMFAC&quot;) .&nbsp;The first storage, i.e. the storage whose type number is NST = 1, has the state-vector element STATE(&quot;EMFAC&quot;*1)I</p>
<p>• Gather stations that are specially designed to process families have more than one element in the state vector. Each has &quot;FAM1&quot; elements since each family must have its own state-vector element.</p>
<p>3.5 The Watchdog</p>
<p>We shall require that no transaction gain access to a station without having been in that station's queue. To put it differently, a transaction must have been selected by a station's policy before the station may serve it. Were it not for the restriction, a new arrival could be processed without having to wait its turn.</p>
<p>Transactions- sometimes arrive at a station that has Just become accessible and at which other transactions are already waiting. Were it not for the watchdog, the new arrival would acquire the station without having competed for selection with the waiting transactions. The hound sees to it that each newly arriving transaction is blocked at least once.</p>
<p>Our faithful mutt is driven by the variable OK. If a transaction arrives at a station that has just been freed, it finds the variable set OK s 0 and is automatically blocked. Fido forces the arriving transaction to compete for selection with transactions that have already waited their turns. When a transaction is blocked, it has been deactivated, which means that ACTIV2 will be called next. ACTIV2 finds the station accessible with transactions waiting at it; thus a conditioned activation is called for. ACTIV2 lets the station's policy select a waiting transaction and then activates it. At the same time, it sets OK s 1, so that faithful Fido won't bark. (For an example of Fido in action, see 4.1.1.)</p>
<p>4 FACILITIES</p>
<p>Facilities are stations that serve one transaction at a time. The transaction acquires it, is served by it for some period and finally frees it (see figure 18). While it serves one transaction, a facility is Inaccessible to all others; new arrivals must wait in its queue until it has been freed. Then one of the waiting transactions will be chosen from the queue to be served.</p>
<p>I ACQUIRE&nbsp;| | PROCESS |</p>
<p><a href="#bookmark262">&gt;1 THE&nbsp;|---&gt;| THE&nbsp;|</a></p>
<p><a href="#bookmark263">I FACILITY&nbsp;| | TASK&nbsp;|</a></p>
<p><a href="#bookmark264">I FREE&nbsp;I</a></p>
<p><a href="#bookmark265">&gt;| THE&nbsp;-&gt;</a></p>
<p><a href="#bookmark266">| FACILITY&nbsp;I</a></p>
<p>FIGURE 18&nbsp;A TASK'S OCCUPATION OF A FACILITY</p>
<p>Examples:</p>
<p>*&nbsp;A supermarket checkout-stand handles only one customer at a time. If a customer's groceries are being checked, arriving customers must stand in line; they form the queue.</p>
<p>•&nbsp;A certain computing system's CPU can process only one task at a time. All tasks competing for CPU time are placed in a queue. When the CPU is freed, one of the tasks in the queue is selected according to a policy and acquires the CPU. If the system sup« ports preemptions, an incoming task can insist that it be pro-cessed, assuming the policy gives it preference, thereby forcing the currently processing task back into the queue.</p>
<p>Data area:</p>
<p>When a facility is to be acquired, two data areas are needed: the state vector and the facility matrix. The state vector specifies whether the facility is accessible or not. When it is accessible, a transaction can acquire it; when not, the transaction must wait. A facility is accessible precisely when it is free, I.e. when it isn't processing a transaction. The facility matrix specifies the facility's parameters and is defined as follows:</p>
<p>INTEGER FAC</p>
<p>DIMENSION FAC( &quot;FACI<sup>w</sup> ,3)</p>
<p>The individual alésants have the following meanings:</p>
<p>FAC(NFA,1) Occupation code</p>
<p>This field shows which transaction occupies the facility. It also specifies whether or not the transaction is interruptible (preemptible) or not. FAC(NFA,1)*0 The facility is free. FAC(NFA,1)«LTX The transaction whose line is LTX in</p>
<p>the activation list occupies the facility; it is interruptible. FAC(NFA,1)*-LTX The transaction whose line is LTX in</p>
<p>the activation list occupies the facility; it is not interruptible.</p>
<p>FAC(NFA,2) Preemption code</p>
<p>The code shows whether or not a preemption is in progress.</p>
<p>FAC(NFA,2)*0 A preemption is not in progress. The</p>
<p>transaction occupying the facility is in its normal service phase. FAC(MFA<sub>t</sub>2)x1 A preemption is in progress.</p>
<p>FAC(NFA,3) Service phase</p>
<p>This element specifies which phase the transaction currently being served is in: setup, work or knockdown (see 4.2). FAC(NFA<sub>f</sub> 3)st Setup FAC(NFA<sub>f</sub>3)*2 Work FACOJFA, 3)-3 Knockdown</p>
<p>Note:</p>
<p>• For facilities without preemption, only FAC(N^A<sub>f</sub>1) is actually used.</p>
<p>4.1 Acquiring and Freeing a Facility</p>
<p>SEIZE acquires and CLEAR frees a facility for the active transaction. WORK simulates the time a transaction spends being served.</p>
<p>».1.1 SEIZE Purpose:</p>
<p>The active transaction tries to acquire a facility by calling SEIZE, which tests the facility's accessibility. If the facility is free, the active transaction acquires it; the facility is then inaccessible. If the facility is inaccessible to begin with, SEIZE blocks the active transaction and enters it in the facility's queue.</p>
<p>Calling sequence</p>
<p>CALL SEIZE (NFA<sub>9</sub>ID<sub>9</sub> &amp;1005 <sub>f</sub>IPRINT) Parameters:</p>
<p>NFA&nbsp;Facility number (Type number)</p>
<p>Facillties^are identified by consecutive numbers* ID&nbsp;SEIZE CALL's statement number</p>
<p>If SEIZE blocks an arriving transaction, ID specifies the target where the transaction will continue its activity when it is re-activated. At that time, its activity should be to acquire the station. Therefore, ID should specify the same CALL SEIZE statement that caused the transaction to enter the wait queue. 41005 Blocking exit</p>
<p>Vhen a transaction tries to acquire a facility that is currently occupied, it must be blocked. Then transaction management must receive control again. Hence, the statement number of CALL ACTIV2 must always be specified here.</p>
<p>IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0. ♦</p>
<p>Data area:</p>
<p>SEIZE uses the activation list, the TX matrix, the FAC matrix and the state vector.</p>
<p>•Algorithm description:</p>
<p>&quot;Blocking Decision&quot;</p>
<p>IF(OK.EQ.O) GOTO 100 OK s 0</p>
<p>IF(FAC(NFA<sub>f</sub> D.NE.0) GOTO 100</p>
<p>First, the watchdog sniffs the calling transaction. Only in case OK.NE.O has it already competed with the others for selection; otherwise it may not acquire the facility. OK is reset immediately. Then SEIZE checks whether or not the facility is already occupied. If FAC(NFA,1) is 0, i.e. if the facility is free, the program continues with the &quot;Acquire&quot; section; otherwise it jumps to the &quot;Block&quot; section.</p>
<p>%</p>
<p>&quot;Acquire&quot;</p>
<p>FAC(NFA,1) = LTX STATE(NFA) s 0 TX(LTX,5) * ID TX(LTX,8) s 0 RETURN</p>
<p>SEIZE sets the acquiring transaction's line number, LTX, in FAC(NFA,1). Since the facility is now occupied again, it marks the station inaccessible by zeroing its state-vector entry. Finally, it elears the acquiring transaction's block time. •Block&quot;</p>
<p>100 AL(LTX,1) s ID</p>
<p>AL(LTX,2) a - NFA TX(LTX,8) * 7 RETURN 1 END</p>
<p>The transaction to be blocked has the line numbered 'LTX' in the activation list. SEIZE enters a block code for it there. When it is re-activated, its activity continues with the statement whose statement number is ID; SEIZE sets that number in the activation list as target. For certain policies, such as FIFO, which use the block- time, it enters the current clock time in the TX matrix.&nbsp;~</p>
<p>Note:</p>
<p>•&nbsp;There can be several points of entry to a given facility, i.e. several CALL SEIZE statements in the model can specify the same facility number, NFA. (Examples are discussed in section 4.3*)</p>
<p>•&nbsp;When a transaction first arrives at an accessible facility, where no other transactions are waiting, it will call SEIZE twice in a row. The first time, the watchdog, whose function is explained in 3-5, causes the arrival to be blocked and SEIZE returns to flow management. ACTIV2 then finds the accessible facility with a waiting transaction, which it now activates. The newly re-activated transaction is targeted to call SEIZE again. This time, OK will be 1. Since the transaction has been selected from the queue, the watchdog lets it acquire the facility.</p>
<p>4.1.2 U0RK Purpose:</p>
<p>By calling WORK, the active transaction simulates the time it spends being served at a facility. WORK schedules the transaction to call it again after it has been served, then returns to flow management. At the end of its service phase, when the transaction calls WORK again, the program recognizes it and, leaving it active, returns normally to the statement following the call.</p>
<p>Calling sequence:</p>
<p>CALL WORK (WT,NFA,ID,IEX,41005,41006,IPRINT)</p>
<p>Parameters:</p>
<p>WT&nbsp;Work time</p>
<p>The active transaction requests to be served for WT time units. If the simulator's clock shows time T, WORK schedules the transaction to be re-activated at T ♦ WT.</p>
<p>UFA&nbsp;Facility number (Type number)</p>
<p>The facilities are identified by sequential numbers.</p>
<p>ID&nbsp;WORK CALL'S statement number</p>
<p>WORK targets the transaction to call it again at the end of its work phase. It does that by entering its own statement number, which is passed to it in ID, and the re-activation time in the ?&quot;tivation list.</p>
<p>TEX&nbsp;Preemption code</p>
<p>*&nbsp;This parameter specifies whether the active transaction</p>
<p>may be preempted once it has acquired the facility. IEX s 0 The transaction now acquiring the facility may be preempted in case a higher-priority transaction desires to be served. IEX * 1 The transaction may not be preempted. Any transaction arriving while it is being served will be blocked.</p>
<p>41005 Scheduling exit</p>
<p>WORK deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another transaction.</p>
<p>&amp;1006 Error exit</p>
<p>The subroutine returns via this exit if ^a transaction tries to be served at a facility it doesn't occupy.</p>
<p>IPRIHT Trace control</p>
<p>Trace printouts are suppressed'when IPRIHT s 0.</p>
<p>Data area:</p>
<p>WORK uses the activation list, the TX matrix and the FAC matrix.</p>
<p>Algorithm description:</p>
<p>Since WORK sometimes operates in tandem with PREEMP, (see 4.2.1), the reader should learn their algorithms together, unless he has no use for preemptions. A first reading could skim WORK'S algorithm or skip directly to the notes at the end of this section.</p>
<p>•Error check*</p>
<p>IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</p>
<p>The program tests wether the calling transaction actually occupies the facility it specifies in the NFA parameter. If not, the error exit is taken.</p>
<p>&quot;Serving decision&quot;</p>
<p>100 IF(FAC(NFA, 2 ).EQ.O ) GOTO 150</p>
<p>IF(FAC(NFA,3).EQ.1) TX(LTX,6) s WT RETURN</p>
<p>150 IF(FAC(NFA,3).EQ.2) RETURN</p>
<p>This section culls out returning or preempted transactions and iaaues a normal return when it finds them« If a preemption Is in progress, PAC(NFA<sub>f</sub>2) will be non-zero. If the transaction has just completed its setup phase, FAC(NFA,3) will be 1, In which case its remaining work time (TX(LTX,6)) is the entire time it would have been served, WT. Preempted transactions remain active and WORK returns to the statement following its call.</p>
<p>If a preemption isn't in progress, the subroutine culls out transactions returning to report the end of their work phase; they will have a phase code of 2 in FAC(MFA,3) • Those transactions also remain active and WORK returns normally.</p>
<p>Transactions at the start of their work phase fall through to the next section, if a preemption isn't in progress.</p>
<p>•Serve<sup>11</sup></p>
<p>IF(IEX.EQ.O) FAC(NFA,1) « LTX IF(IEX.EQ.1) FAC(NFA,1) s - LTX FAC(NFA,3) * 2 IF(TX(LTX,6).NE.O) GOTO 200 AL(LTX,1) s ID AL(LTX,2) s I ♦ BT RETURN 1</p>
<p>The facility's entry in the FAC matrix is set to show that it is in its work phase (FAC(NFA,3) = 2) and that its occupant is interruptible or not. If the transaction was once preempted and hasn't yet been completely served, TX(LTX,6) will show how much time it has left to spend in the work phase; WORK jumps to &quot;Serve reacquiring transactions&quot;. Finally, if the facility is serving the calling transaction from scratch, WORK schedules it by setting a time and target in its activation-list entry and then returns to flow management.</p>
<p>&quot;Serve reacquiring transactions&quot;</p>
<p>200 AL(LTX,1) s ID</p>
<p>AL(LTX,2) s T ♦ TX(LTX,6) ?X(LTX,6) s 0 RETURN 1 END</p>
<p>In a re-acquisition, WORK schedules the calling transaction to be served for the remainder of its processing time*</p>
<p>Note:</p>
<p>• Were it npt for preemption, WORK would be a very simple program. In fact, a programmer who doesn't use preemption could assume that the entire subroutine consists of nothing more than the four statements:</p>
<p>if(fac(nfa,3).eq.2) return fac(nfa,3) * 2</p>
<p>AL(LTX,1) s ID AL(LTX,2) s T ♦ WT</p>
<p>«.1.3 CLEAR</p>
<p>Purpose:</p>
<p>By calling CLEAR, the active transaction frees the facility it</p>
<p>occupies.</p>
<p>Calling sequence:</p>
<p>CALL CLEAR (NPA,EXIT1,41006,IPRINT)</p>
<p>Parameters:</p>
<p>NFA&nbsp;Facility number (Type number)</p>
<p>The facility's identifying number is given here.</p>
<p>EXIT1 Preemption exit</p>
<p>CLEAR takes this exit when the calling transaction is being preempted from the facility. If the user chooses, he may have the subroutine return to a section of his own code, so as to count preemptions or whatever. Then, since CLEAR has blocked the preempted transaction, he must jump to flow management. If the user need take no special action when a preemption occurs, he should code 41005 here; then CLEAR returns directly to ACTIV2.</p>
<p>41006 Error exit</p>
<p>CLEAR exits to this statement number when the active transaction doesn't occupy the facility it is trying to free.</p>
<p>I PR INT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>CLEAR uses the FAC matrix, the state vector and the TX matrix. Algorithm description: &quot;Error check&quot;</p>
<p>. IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</p>
<p>A transaction that doesn't occupy the facility numbered 'NFA' has no business trying to free it; the model is incorrectly designed .</p>
<p>&quot;Free&quot;</p>
<p>100 DO 150 I s 1 , 3 150 FAC(NFA,I) r 0 STATE(NFA) s 1</p>
<p>The program clears the facility's data areas and marks it accessible.</p>
<p>•Block a preempted transaction&quot;</p>
<p>IF(TX(LTX<sub>t</sub>6).EQ.O) GOTO 200 AL(LTX,1) * TX(LTX,5) AL(LTX<sub>9</sub>2) ж - NPA TX(LTX<sub>9</sub>8) » T • 200 TX(LT£,5) » 0</p>
<p>If the calling transaction has been preespted<sub>9</sub> it belongs In the facility's queue again, since it has to come back to finish being served. CLEAR recognizes preempted transactions from the fact that their residual-processing-time field, TX(LTX<sub>f</sub>6), has been filled in. The blocked transaction is targeted to the call to PREEMP that caused it to be preempted.</p>
<p>•Return*</p>
<p>IP(TX(LTX<sub>9</sub>6).EQ.O) RETURN</p>
<p>RETURN 1</p>
<p>END</p>
<p>This section chooses the correct return for each kind of transaction. If the transaction is leaving the facility of its own free will, it remains active and CLEAR returns to the statement following the call. If the transaction is being preempted, though« CLEAR has blocked it and must return via the preemption exit.</p>
<p>Notes:</p>
<p>• A facility at which preemptions don't occur, like the facility in figure 18, is modelled by the following sequence of statements, in which HORK's IEX parameter is, of course, meaningless:</p>
<p>2&nbsp;CALL SEIZE (NFA,2,41005,JPRIN7)</p>
<p>3&nbsp;CALL WORK (WT,flPA,3tIEX,41005,41006,TPRIMT) CALL CLEAR (ЯРА,41005,41006,IPRINT)</p>
<p>4.2 Preemption</p>
<p>Preemption interrupts a facility's service to let a more important transaction acquire it. ^he preempted transaction returns to the queue with a code showing how much time it had left to be served. The facility finishes serving it later, when it is selected from the queue.</p>
<p>4.2.1 PREEMP Purpose:</p>
<p>PREEMP acts like SEIZE, except that it preempts a facility's current occupant, if the new arrival is important enough to warrant Immediate service.</p>
<p>If PREEMP finds the facility free, the calling transaction ac-<a name="bookmark267"></a>•a</p>
<p>quires it; then the facility is inaccessible* Since no preemption occurs, PREEMP does exactly what SEIZE would have done.</p>
<p>If, on the other hand, PREEMP finds the facility occupied, it lots the policy decide which transaction should occupy it. If the policy decides in favor of the facility's occupant, PREEMP simply blocks the calling transaction and returns to flow aanagement. But if the policy decides against the facility's occupant, PREEMP Initiates a preemption: it blocks the arriving transaction, but it cuts off the occupant's remaining serving time.</p>
<p>Calling sequence:</p>
<p>CALL PREEMP (NFA,ID,&amp;1005,IPRINT)</p>
<p>Parameters:</p>
<p>UFA&nbsp;Facility Number (Type number)</p>
<p>This parameter identifies the facility whose current occupant is to be preempted. The facilities are Individ-ualy, consecutively numbered. ID&nbsp;PREEMP CALL's statement number</p>
<p>Tf PREEffP blocks an arriving transaction, ID-specifies the target where the transaction will continue its» activity when it is re-activated. At that time, its activity should be to acquire the station. Therefore, ID should specify the sane CALL PREEMP statement that caused the transaction to enter the queue. &amp;1005 Blocking exit</p>
<p>PREEMP takes this exit whenever it blocks the arriving transaction. That occurs in every case, except when the transaction acquires the facility* IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRIN? s 0.</p>
<p>Data area:</p>
<p>PREEMP uses the activation list, the TX matrix, the FAC matrix and the state vector.</p>
<p>Algorithm description:</p>
<p>A first reading could overlook references to the facility's setup and knockdown phases; they are inessential to an understanding of PREEMP's workings.</p>
<p>&quot;Blocking decision&quot;</p>
<p>K1 s 1</p>
<p>TF(FAC(NFA<sub>f</sub> U.NE.O) GOTO 200 K 1 s 0</p>
<p>IF(OK.EO.O) GOTO 200 OK s 0</p>
<p>If the facility is already occupied, or if the watchdog barks<sub>9 </sub>the above statements jump to &quot;Block&quot;, setting K1 along the way, in order to show why the arrival is being blocked.</p>
<p>acquire-</p>
<p>FAC(NFA, 1) m LTX STATE(MFA) »0 TX(LTX<sub>f</sub>8) s 0 7X(LTX<sub>f</sub>5) « ID RETURN</p>
<p>PREEMP sets the acquiring transaction's line number, LTX, in FAC(NFA,1). Since the facility is now occupied again, it marks the station inaccessible by zeroing its state-vector entry. Finally, it clears the acquiring transaction's block time.</p>
<p>A preempted transaction finds its way, via subroutine CLEAR, back into the queue. Eventually, the policy responsible for that queue will select it to re-acquire the facility. When that happens, the activated transaction should call PREEMP again. Since CLEAR must target the preempted transaction to PREEMP (see 4.1.3 &quot;Block a preempted transaction&quot;), the transaction carries PREEMP's statement number around in the TX(LTX,5) field.</p>
<p>&quot;Block&quot;</p>
<p>200 AL(LTX,1) s ID</p>
<p>AL(L7X,2) s - NFA TX(LTX<sub>f</sub>8) x T IF(KI.EQ.O) RETURN 1</p>
<p>If the watchdog blocks the arriving transaction, PREEMP takes the blocking exit without further adieu. Otherwise, it continues on to the next section.</p>
<p>&quot;Suppress the preemption&quot;</p>
<p>300 IF(FAC(NFA,1).LT.O.AND.FAC(NFA,3bEQ.2) RETURN 1 IF(FAC(NFA,3).E0.3.0R.FAC(NFA,2).EQ.1) RETURN 1</p>
<p>This section suppresses the preemption, if the facility's occupant is in a non-interruptible work phase, or if it is in the process of leaving the facility anyway. The latter is the case when the facility is in its knockdown phase (зее 4.2.4).</p>
<p>&quot;Call the policy&quot;</p>
<p>P0LVECO) s TABS(FAC(NFA, 1) ) P0LC s 1</p>
<p>DO 350 1x1, LAL IF(AL(I,2).ME.-MrA) GOTO 350 P0LC = P0LC ♦ 1 POLVEC(POLC) s I 350 CONTINUE</p>
<p>CALL POLICYOJFA)</p>
<p>I<sup>C,</sup>(LTX.EQ.TABS(FAC(NFA, 1))) RETURN 1</p>
<p>Here, the policy decides whether a preemption is called for or not. Just as in ACTIV2, PREEMP gathers in P0LVEC the line numbers</p>
<p>of mil transactions waiting at the facility, inserting the facll~ ity's occupant as the first entry<a name="footnote6"></a><sup><a href="#bookmark268">6</a></sup> Then it calls POLICY (see 3*3)» which returns the line number of the transaction it selects In LTX. If the policy has selected the facility's occupant, no preemption is called for*</p>
<p>&quot;Preempt&quot;</p>
<p>LTX s IABS(FAC(HFA<sub>f</sub>1)) FACOIFA,2) s 1</p>
<p>IF(FAC(NFA,3).E0.1) RETURN 1 TX(LTX,6) s AL(LTX,2) - T AL(LTX,2) s T RETURN 1 END</p>
<p>First, we set the preemption code, so that WORK will know what has happened (see 4*1.2 &quot;Serving decision&quot;). If the facility's occupant is being set up, it may not be interrupted, but we set the preemption code, so that it will skip its work phase and go directly to its knockdown phase (if there is one).</p>
<p>If the facility's occupant is in its work phase, PftEEMP sets its remaining processing time in TX(LTX,6) ajnd schedules it*to be reactivated immediately: we have cut off the occupant's service. Now the occupant will again call WORK,, which recognizes it and returns to the next statement in the model.</p>
<p>Notes:</p>
<p><sup>9</sup> To simulate a facility with preemptions, but without considering setup and knockdown phases, merely substitute PREEffP for SEIZE, as follows:</p>
<p>2&nbsp;CALL PREEMP (NFA,2,41005,IPRIN?)</p>
<p>3&nbsp;CALL WORK (WT,NFA, 3 •IEX,41005<sub>f</sub>41006<sub>f</sub>IPRINT) CALL CLEAR (NFA,41005,41006,IPRINT)</p>
<p>No other changes whatever are necessary. The IEX parameter I can, of course, specify for each transaction individually, whether or not it is interruptible.&nbsp;- ■''^■^■H</p>
<p>pant is In the process of leaving anyway.</p>
<p>• The only reason for having the policy look over all transactions is that their priorities could have changed since the facility began serving its present occupant. If priorities aren't assigned dynamically, though, we can be sure that the facility's occupant has a higher one than any transaction waiting in the queue. In that case, PREEMP could decide whether or not to preempt, merely by comparing the occupant's priority with the arriving transaction's. If the new arrival has the higher priority, it preempts the occupant. The user can implement that simpler, time-saving procedure by replacing &quot;Call the policy<sup>11</sup> with the following section:</p>
<p>&quot;Compare priorities&quot;</p>
<p>LTX1 « IABS(FAC(NFA,1)) IF(TX(LTX,4).LE.TX(LTX1,4)) RETURN 1</p>
<p>4.2.2 Setup and Knockdown in Case of Preemption</p>
<p>If we just look closely enough, most serving processes actually consist of three phases:</p>
<p>*&nbsp;a setup phase in which the station and its new task are made ready for work,</p>
<p>*&nbsp;a work phase in which the station serves or processes the task and finally,</p>
<p>•&nbsp;a knockdown phase in which the station is set back in its original state and its task is dismounted or removed.</p>
<p>Example:</p>
<p>•&nbsp;At a car-repair shop, the setup phase consists of driving the car in from the parking lot and setting out the tools. The mechanic repairs the car during the work phase. During the knockdown phase, he clears away his tools and drives the car back on to the lot.</p>
<p>If work at a facility is never preempted, we lump all three phases together, as we did in the example at the end of section 4.1.3. But if a transaction is ever preempted, it will have to be set up and knocked down once more* each time it makes room for a more pressing case. Its total service time could be considerably longer than it would otherwise have been. Hence, we shall often want to model each phase separately. Each time its service is interrupted, the facility loses the old transaction's knockdown time , plus the new one's setup time (see figure 19).</p>
<p><a name="bookmark269"></a>Example:&nbsp;•</p>
<p><sup>11</sup> An emergency patient arrives at a doctor's office. The patient he is treating at the moment has to get dressed and return to the</p>
<p>waiting room while the doctor clears his Instruments away and washes his hands. All in all<sub>9</sub> it takes two minutes of knockdown time before the pressing case can be admitted. Then it takes the doctor another three minutes of setup time to figure out precise« ly what's the matter and to get his Instruments ready.</p>
<p>Subroutine PREEMP occasions preemptions, when they are called for, and subroutines SETUP and KNOCKD simulate the time ft takes to set the facility up or to knock it back down. Of course WORK simulates the facility's normal working phase.</p><div>
<p>FIGURE 19</p></div>
<p>OCCUP</p>
<p>FREE</p>
<table border="1">
<tr><td>
<p>1 SERVICE</p></td><td>
<p>STATION'S</p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1 STATE</p>
<p>I 1</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1</p></td><td>
<p>1 I</p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1</p></td><td>
<p>1 •• 1</p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>1 1</p></td><td>
<p>I SETUP PHASE |</p></td><td>
<p></p></td><td>
<p>•</p></td></tr>
<tr><td>
<p>1</p></td><td>
<p>-</p></td><td>
<p></p></td><td>
<p></p></td></tr>
</table>
<p>A</p>
<p>I</p>
<p>PREEMPTION</p>
<p>A</p>
<p>I</p>
<p>ACQUISITION</p>
<p>TIME FLOW FOR PREEMPTIONS WITH KNOCKDOWN AND SETUP</p>
<p>4.2.3 SETUP Purpose:</p>
<p>By calling SETUP, the active transaction simulates the time it spends being set up at a facility. SETUP schedules the transaction to be activated at the end of its setup phase, targeting it to a specified statement number. During its setup phase, the transaction is not preemptible.</p>
<p>Calling sequence:</p>
<p>CALL SETUP (ST,UFA,IDN,41005,41006,IPRINT)</p>
<p>Parameters:</p>
<p>ST&nbsp;Setup time</p>
<p>The active transaction requests to be set up for ST time units.</p>
<p>UFA&nbsp;Facility number (Type number)</p>
<p>The facilities are identified by sequential numbers»</p>
<p>ION&nbsp;Target</p>
<p>SETUP targets the transaction to this statement number, where it is to continue its activities at the end of its setup phase. That will normally be a call to WORK.</p>
<p>A1005 Scheduling exit</p>
<p>SETUP deactivates the calling transaction by placing it in the scheduled state. Then flow management must re* ceive control again, so that it can activate another transaction, ft 1006 Error exit</p>
<p>The subroutine returns via this exit if a transaction tries to be set up at a facility it doesn't occupy. IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT «0.</p>
<p>Data area:</p>
<p>SETUP uses the activation list, the TX matrix and the FAC matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Error check&quot;</p>
<p>IF(IABS(FAC(NFA,1)).EQ.LTX) GOTO 100 RETURN 2</p>
<p>A transaction that doesn't occupy the facility numbered 'NFA' has no business trying to be set up there; the model is incor~ rectly designed.&nbsp;.&nbsp;i</p>
<p>•Set up the facility&quot;</p>
<p>100 FAC(NFA,1) s - LTX FAC(NFA<sub>f</sub>3) * 1 AL(LTX<sub>9</sub>1) s IDN AL(LTX,2) s T ♦ ST RETURN 1 END</p>
<p>We mark the facility occupied<sub>9</sub> non-interruptible and setting up. Then we schedule the transaction and return to flow management.</p>
<p>4.2.4 KNOCKD Purpose:</p>
<p>By calling KNOCKD, the active transaction simulates the time it spends being knocked down at a facility. KNOCKD schedules the transaction to be activated at the end of its knockdown phase, targeting it to. a specified statement number. During its knockdown phase, the transaction is not preemptible.</p>
<p>Knockdown time</p>
<p>The active transaction requests to be knocked KT time units,</p>
<p>Pacility number (Type number)</p>
<p>The facilities are identified by sequential numbers. Target</p>
<p>KNOCKD targets the transaction to this statement number, where it is to continue its activities at the end of its knockdown phase. That will normally be a call to CLEAR. Scheduling exit</p>
<p>KNOCKD deactivates the calling transaction by placing it In the scheduled state. Then flow management must re* ceive control again, so that it can activate another transaction. Error exit</p>
<p>The subroutine returns via this exit if a transaction tries to be knocked down at a facility it doesn/t occupy.</p>
<p>Trace control</p><div>
<p>KT</p>
<p>UFA IDN</p>
<p>A1005</p></div><div>
<p>down for</p></div><div>
<p>41006</p>
<p>IPRINT</p></div><div>
<p>Calling sequence:</p>
<p>CALL KNOCKD &lt;KT<sub>t</sub>MFA<sub>f</sub>IDII,*1005t4t006<sub>f</sub> IPItlMT) Parameters;</p></div>
<p>Trace printouts are suppressed when IPRXNT</p>
<p>0.</p>
<p>Data area:</p>
<p>KNOCKD uses the activation list, the TX matrix and the PAC matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Error check&quot;</p>
<p>IF(IABS(FAC(NFA,1)).E0.LTX) GOTO 100 RETURN 2</p>
<p>A transaction that doesn't occupy the facility numbered <sup>#</sup>NFA' has no business trying to be knocked down there; the model is incorrectly designed.*</p>
<p>&quot;Knock down the facility&quot;</p>
<p>100 FAC(NFA,1) * - LTX FAC(NFA,3) - 3 AL(LTX,1) x IDN AL(LTX,2) s T ♦ KT RETURN 1 END</p>
<p>We mark the facility occupied, non-interruptible and knocking down. Then we schedule the transaction and return to flow management .</p>
<p>t</p><div>
<p>TASK-PROCESSING BRANCH</p>
<p>GENERA</p></div>
<p>ZNTERROPT-PROCESSINO BRANCH</p>
<p>GENERA</p>
<p><a href="#bookmark155">I&nbsp;I&nbsp;I&nbsp;I</a></p>
<p>I SEIZE ' I&nbsp;I&nbsp;PREEMP I</p>
<p><a href="#bookmark270">I&nbsp;I&nbsp;I&nbsp;I</a></p>
<p><a href="#bookmark271">I&nbsp;I</a></p>
<p><a href="#bookmark272">I&nbsp;II&nbsp;I</a></p>
<p>I WORK&nbsp;I&nbsp;I&nbsp;WORK I</p>
<p><a href="#bookmark273">I&nbsp;III</a></p>
<p><a href="#bookmark274">I&nbsp;I</a></p>
<p>I ------------------------------</p>
<p>I</p>
<p><a href="#bookmark275">I&nbsp;I</a></p>
<p><a href="#bookmark276">I CLEAR&nbsp;I</a></p>
<p><a href="#bookmark277">I&nbsp;I</a></p>
<p>I</p>
<p><a href="#bookmark278">I&nbsp;I</a></p>
<p><a href="#bookmark279">I TERMIN&nbsp;I</a></p>
<p><a href="#bookmark280">I&nbsp;I</a></p>
<p>FIGURE 20&nbsp;PREEMPTION OF A TRANSACTION BÏ</p>
<p>A CLOCK SIGNAL</p>
<p>Notes:</p>
<p>* To simulate a facility with all three service phases, use the following sequence of statements:</p>
<p>2&nbsp;CALL PREEMP (NFA,2,41005,XPRTNT)</p>
<p>CALL SETUP (ST,UFA,3,41005,41006,IPRINT)</p>
<p>3&nbsp;CALL WORK (WT,NFA,3,IEX,41005,41006,TPRTNT) CALL KUOCKD (KT,fJPA,J4,41005,41006, IPRINT)</p>
<p>H CALL CLEAR (NFA,41005,41006,IPRINT)</p>
<p>The sequence differs from that in section 4.2.1 only in that the calls to SETUP and nJOCKD have been inserted and the call to CLEAR has a statement number. Of course a facility could also</p>
<p>have any two of the three phases, or It could have any number of work phases.</p>
<p>• SETUP and ICNOCfCD are similar to ADVANC (see 2.5.1), except that they mark the facility's service phase and decree the facility's occupant non-lnterruptible.</p>
<p>H.3 Multiple Entries to a Facility</p>
<p>Transactions can easily acquire a facility from various processing paths in a model; some of them could acquire the facility by means of one call to SEIZE; others acquire it by means of a second. Both calls would specify the same facility number (UFA). Multiple entries are especially useful where transactions in one processing path preempt transactions that acquired the facility in another.</p>
<p>Exaaple:&nbsp;r</p>
<p>• A computer's central processing unit is to be time-sliced: whichever task is being processed should be preempts after so and so much time, to give other tasks a shot at the CPU. ^e preempted task returns to the queue, along with a code showing how auch processing time it has left. Then the other tasks have a chance at the CPU.</p>
<p>In the system's model, the transactions representing tasks acquire the facility (CPU) by means of a call to SEIZE. The interrupting signals, which the model generates at regular intervals, are highest-priority transactions. Their only purpose in life is to interrupt the tasks, which they do by calling PREEMP from the second processing path. After it has processed the interruption, the CPU is again free, whereupon the next task in the queue acquires it. Figure 20 shows the tasks' and interruptions' paths through the model.</p>
<p>NULTIFACILITIES</p>
<p>Multifacilities are, in M9«not<sub>9</sub> a group of facilities that share a queue.</p>
<p>5.1 The Structure of Multifacilities</p>
<p>A aultifacility consists of entities we shall call service elements, each of which serves one transaction at a time, A aultifacility 's service elements operate in parallel and they all take transactions from the same queue. A aultifacility may contain any number m of service elements. In case m*1, it works just like a simple facility.</p>
<p>Example:</p>
<p>* A computing system with multiple processors is simulated most easily using a multifacility. Each processing unit is a service element and the jobs being processed form a ready queue, from which they acquire whichever processor happens to be free.</p>
<p>A multifacility's queue is administered by a policy and in its service elements by a plan. The policy selects from among the waiting transactions the one to be processed next, just as a normal facility's policy would. The plan is a procedure that decides which of a multifacility's service elements a transaction should acquire (see figure 21). The plan serves a further function during preemptions: it decides which service element to clear to make room for the preempting transaction.</p>
<p>Examples:</p>
<p>*&nbsp;Under the plan 'FIRST', a task acquires the first free service element in the multifacility, whichever that may be. Since FIRST searches the service elements sequentially, starting at the first, the earlier ones will be used more heavily. FTRST-M (First-Modified) uses the service elements more uniformly by starting its search where it left off the last time.</p>
<p>•&nbsp;In preemptions, the plan 'PRIOR' (Priority dependence) clears whichever service element happens to be processing the lowest— -priority transaction.</p>
<p>A multifacility is homogenous if each task can be served by any of its elements; no task is ever assigned to a special element. Real systems are often non-homogenous in this sense, especially if tasks can be preempted. A preempted task may have to come back to the same service element where it began. GPSS^F s multifacilities are homogenous, so far as arriving transactions are concerned<sub>f</sub> but each preempted transaction can specify whether it shall be bound to the element that began serving it.</p><div>
<p>5</p></div>
<p><a name="bookmark231"></a>WAIT QUEUE</p>
<p><a href="#bookmark281">I---I</a></p>
<p><a href="#bookmark282">I--I</a></p>
<p><a href="#bookmark283">I---I</a></p>
<p><a href="#bookmark284">I---I</a></p>
<p>I</p>
<p><a href="#bookmark285">I POLICY FOR&nbsp;I</a></p>
<p><a href="#bookmark286">I MANAGING THE&nbsp;I</a></p>
<p><a href="#bookmark287">I WAIT QUEUE&nbsp;I</a></p>
<p><a href="#bookmark288">I PLAN FOR&nbsp;I</a></p>
<p><a href="#bookmark289">I ASSIGNING&nbsp;I</a></p>
<p>I SERVICE ELEMENTS I</p>
<p><a name="bookmark270"></a>I &quot; I</p>
<p>I SERVICE I I SERVICE (&nbsp;I SERVICE |</p>
<p>I ELEMENT 1 | | ELEMENT 2 I&nbsp;I ELEMENT M |</p>
<p>I&nbsp;I I&nbsp;I&nbsp;I&nbsp;I</p>
<p>FIGURE 21&nbsp;MULTIFACILITY STRUCTURE</p>
<p>Data area:</p>
<p>Each multifacility has a line in the MFAC matrix, which is defined as follows:</p>
<p>INTEGER MFAC</p>
<p>DIMENSION MFAC(&quot;MFACI&quot;,2)</p>
<p>The matrix's elements are used as follows:</p>
<p>MFAC(MFA<sub>t</sub>1) Count of occupied service elements</p>
<p>The count for the multifacility whose type number is MFA is stored here.</p>
<p>MPAC(MFA,2) Capacity</p>
<p>This number tells how many service elements the multifacility has.</p>
<p>The MFAC matrix contains the parameters that describe a multi-facility as a whole. The SE matrix, on the other hand, contains the data relevant to its service elements. It is defined:</p>
<p>DIMENSION SE(*3R1»<sub>9</sub>3&gt;</p>
<p>Its fields are used as follows:</p>
<p>SE(LSE<sub>9</sub>1) Occupation code</p>
<p>This field shows which transaction occupies the serv-ice element. It also specifies whether or not the transaction is Interruptible (preemptible) or not. SE(LSE,1)sO The service element is free. SE(LSE<sub>9</sub>1)sLTX The transaction whose line is LTX in</p>
<p>the activation list occupies the service element; it is interruptible. SE(LS£<sub>9</sub>1)a-LTX The transaction whose line is LTX in</p>
<p>the activation list occupies the ser-vice element; it is not interrupt« ible.</p>
<p>SE(LSE<sub>9</sub>2) Preemption code</p>
<p>The code shows whether or not a preemption is in progress.</p>
<p>SE(LSE<sub>9</sub>2)sO A preemption is not in progress. The</p>
<p>transaction at this service element is in its normal processing phase. SE(LSE<sub>f</sub>2)s1 A preemption is in progress.</p>
<p><a name="bookmark290"></a>SE(LSE»3) Service phase</p>
<p>This field shows the service element's current service phase (see 4.2.2): SE(LSE<sub>f</sub>3)*1 Setup SE(LSE<sub>t</sub>3)*2 Work SE(LSE<sub>9</sub>3)s3&nbsp;Knockdown</p>
<p>Since each service element in the whole of GPSS-f has a line in the SE matrix<sub>9</sub> its &quot;SE1* dimension limits the number of serv-ice elements that a given model can simulate. a multifacility basis vector (MBV) divides up the SE matrix to show which lines belong to which multifacility. It is defined as follows:</p>
<p>INTEGER MBV</p>
<p>DIMENSION f!EV( &quot;fTFACI*)</p>
<p>Each field in the vector has the following meaning:</p>
<p>MBV(MFA) Pointer to the multifacility*s first service element</p>
<p>A single multifacility's service elements have consecutive lines in the SE matrix. The multifacility whose number is MFA has the SE matrix lines starting with the one pointed to by this field.</p>
<p>Subroutine INIT2 (see 2.6.3) assigns service elements to mul-tifacilities at simulation startup and initializes the basis vector. Figure 22 diagrams the structure that the basis vector imposes on the SE matrix.</p>
<p>SB MATRIX</p>
<p>I I</p>
<p>HULTI- &lt; FACILITY | MFA m 1 |</p>
<p>I SE(1,1) | SE(1,2)</p>
<p><a name="bookmark291"></a>T</p>
<p><a name="bookmark292"></a>I SB(1,3) |&lt;~</p>
<p>—------- I</p>
<p>I -«BY VECTOR I MBV(1)</p>
<p>I</p><div>
<p>&lt;—</p>
<p>I I I</p></div><div>
<p>I I</p>
<p>HULTI* &lt; FACILITY I MFA&nbsp;|</p></div><div>
<p>1</p></div><div>
<p>™| HBV(NFA)</p></div>
<p>I</p>
<p>&lt;---1 MBV(&quot;ftFAC1&quot;) |</p>
<p>I I</p>
<p>MULTI« &lt; FACILITY I MFA « I -&quot;MFAC1&quot; —I</p>
<p>FIGURE 22&nbsp;THE SE MATRIX AMD THE MULTIFACILITY BASIS VECTOR</p>
<p>Not«:</p>
<p>* The total number of service elements available to the user is set when the simulator is dimensioned (see appendix A3). A model may assign the available service elements to multifacilitles any way it sees fit. The model specifies each multifacility's capacity in Section 4 of the chassis by means of a direct entry in the MFAC matrix (see 2.6.1 and 11.5).</p>
<p>5.2 Acquiring and Freeing a Multifacility</p>
<p>HSEIZE acquires and MCLEAR frees a multifacility fer the ae-tive transaction. MWORK simulate» the time a transaction speeds being served.</p>
<p>9.2.1 HSEIZE Purpose:</p>
<p>A transaction tries to acquire a service element at a multifa-cllity by calling MSEIZE. The program looks to see if the multl-facility has an element free. If so<sub>9</sub> the active transaction acquires it. When the element was the last one free<sub>9</sub> HSEIZE marks the aultlfacility inaccessible. If there are no free elements, the calling transaction is blocked and entered in the aultifacuity's queue.</p>
<p>Calling sequence:</p>
<p>CALL MSEIZE CftFA, ID,REP ,A 1005, &amp; 1006 ,IPRINT)</p>
<p><a name="bookmark293"></a>Parameters:</p>
<p>The parameters whose descriptions differ essentially from those for subroutine SEIZE are REP and A1006.</p>
<p>UFA&nbsp;Multifacility number (Type number)</p>
<p>Yfultifacilities are identified by consecutive numbers. ID&nbsp;HSEIZE CALL'S statement number</p>
<p>If îtSEIZE blocks an arriving transaction, ID specifies the target where the transaction will continue its activity when it is re-activated. At that time, its activity should be to acquire a service element. Therefore, ID should specify the same CALL MSEIZE statement that caused the transaction to enter the queue. REP&nbsp;Repeat code</p>
<p>Since a transaction that acquires a service element by means of MSEIZE can be preempted, REP provides a means of specifying whether the transaction must be boun4 to the element that began serving it, i.e. whether it must come back to that element when it is re-activated. REP s 0 The transaction need not be bound to its initial element; it may acquire any element when it is re-activated.</p>
<p>REP s 1 The transaction must be bound to its initial element. §1005 Blocking exit</p>
<p>When a transaction tries to acquire a multifacility that is fully occupied, it must be blocked. In that case transaction management must again receive control. MG06 Plan-error exit&nbsp;&quot;</p>
<p>If no plan is provided for this multifacility, or if no service element can be found, even though the multi-facility isn't fully occupied, then MSEIZE returns via</p>
<p>this wit. It is recommended to terminate simulation la</p>
<p>__ such eases.</p>
<p>IPKirr Trace control</p>
<p>Trace printouts are suppressed when IPtltfT » 0.</p>
<p>Data area:</p>
<p>MSEIZE uses the net i vat ion list, the TX matrix <sub>9</sub> the MPAC matrix, the SE matrix and the state vector«</p>
<p>Algorithm description:</p>
<p>&quot;Determine the station number&quot;</p>
<p>K « &quot;EFAC&quot; ♦ MFA</p>
<p>The station number K is computed from the type number MFA.</p>
<p>^Blocking decision&quot;</p>
<p>IF(OK.EQ.O) GOTO 300 OK s 0</p>
<p>IF(ftFAC(MFA<sub>f</sub>1).EQ.HFAC(MFA<sub>f</sub>2)) GOTO 300&nbsp;*</p>
<p>The watchdog sniffs the arriving transaction to see whether or not it has been in the queue; If not<sub>9</sub> it must be blocked. Then the program checks whether or not the transaction can acquire, an element in the muitifacility. If the multifacility has any free elements, the program continues with &quot;Assign a service element according to the plan&quot;; otherwise it jumps to &quot;Block&quot;.</p>
<p>&quot;Assign a service element according to the plan&quot;</p>
<p>IF(TX(LTX,7).EQ.0) GOTO 100 LSE * TX(LTX<sub>f</sub>7) IF(SE(LSE,1) .NE.0) GOTO 200 GOTO 150 100 CALL FLA Hi(MFA ,&amp;400) IF(LSE.EQ.O) GOTO 200</p>
<p>If a transaction is coming back after having once been empted, MSEIZE asks whether the returner is bound to its original element. If so<sub>9</sub> only that element need to be tested; when it is occupied, the program jumps to &quot;Lock*. New arrivals and non-bound returners are assigned an element according to the plan responsible for this multifacility. If the plan's search is successful, it returns the element's line number, LSE. The program can then continue with &quot;Acquire*. If the plan can find no element, MSEIZE jumps to &quot;Lock&quot;.</p>
<p>&quot;Acquire&quot;</p>
<p>150 MFAC(MFA,1) s MFAC(MFA,1) v 1</p>
<p>IF(MFAC(MFA,1).E0.MFACC MFA,2)) STATE(K) = O SE(LSE,1) « LTX -TX(LTX<sub>f</sub>5) • ID</p>
<p>' IP(REP.EQ.1) TX(LTX,7) » LSI TX(LTX,8) * 0 RETURN</p>
<p>Ifi as a result of the acquisition, the aultifacility is fully occupied, MSEIZE sets the state vector to show it inaccessible. Then, SEIZE sets the acquiring transaction's line number, LTX, la SE(LSE,1), clears the transaction's bloek time and sets its re* peat code.</p>
<p>•Lock&quot;</p>
<p>200 AL(LTX, 1) s ID&nbsp;.&nbsp;' ;</p>
<p>AL(LTX,2) * - &quot;KEND&quot; - X IF(TX(LTX,8) .EQ.O) TX(LTX,8) * T RETURN I&nbsp;. - &quot; . •&nbsp;'^^^jKfm</p>
<p>A transaction is locked if the multifsieility haai free elements, but cannot assign one of them to the calling transaction. Such cases arise, e.g., when a preempted transaction tries to reacquire the element at which it started processing. (REPst), but that element isn't free. If the transaction wer$'merely blocked, Instead of being locked, the simulator would go into aij endless loop: since the multifacility is free, that transaction would be chosen over and over to acquire an element that actually unavailable.&nbsp;': J tC^? r^l^lS</p>
<p>When a transaction leaves the multifacility* 1*&nbsp;happen</p>
<p>to free precisely the element on which such a locked transaction is waiting. Hence, MCLSAR will have to place all locked transactions in the blocked state, each time an element is freed (see 5.2.3 &quot;Start the locked transactions&quot;).</p>
<p>&quot;Block&quot; '</p>
<p>300 AL(LTX, t) s 10 AL(LTX,2) * X TX(LTX,8) s T RETURN 1</p>
<p>.'•SEIZE blocks a transaction, if the multifacility has no free elements, or if the watchdog forbids acquisition.</p>
<p>&quot;Incorrect multifacility occupation&quot;</p>
<p>400 RETURN 2 END</p>
<p>If there is no plan for this multifacility, or if no element can be found, even though the multifacility isn't&quot; folly occupied, the program returns via the error exit.</p>
<p>5+2.2 H WORK Purpose:</p>
<p>By calling flWORK, the active transaction simulates the tine It spends being served at a multlfacility's service element. MWORK schedules the transaction to call It again after it has been served, then returns to flou management. At the end of its service phase, when the transaction calls MWORK again, the program recognises it and, leaving it active, returns normally to the statement following the call.</p>
<p>Calling sequence:</p>
<p>CALL MWORK (WT,MFA,ID,IEX,41005,41006,IPRIHT)</p>
<p>Parameters:</p>
<p>Work time</p>
<p>The active transaction requests to be served for HT time units. If the simulator's clock shows time T, MWORK schedules the transaction to be re-activated at T ♦ WT. Multifacillty number (Type number)</p>
<p>The multifacllities are identified by sequential numbers.</p>
<p>MWORK CALL'S statement number</p>
<p>MWORK targets the transaction to call it again at the end of its work phase. It does that by entering its own statement number, which is passed to it in ID, and the re-activation time in the activation list. Preemption code</p>
<p>This parameter specifies whether the active transaction may be preempted once it has acquired a service element. IEX * 0 The transaction may be preempted in case a higher-priority transaction desires to be served.</p>
<p>IEX * 1 The transaction may not be preempted. Scheduling exit</p>
<p>MWORIC deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another transaction. Error exit</p>
<p>The subroutine returns via this exit if a transaction</p>
<p>tries to be served at a service element it doesn't occupy.</p>
<p>Trace control</p>
<p>Trace printouts are suppressed when IPRIMT s 0.</p><div>
<p>ІГГ</p>
<p>MFA ID</p>
<p>IEX</p></div><div>
<p>«1005</p>
<p>A 1*006</p>
<p>IPRIMT</p></div>
<p>Data area:</p>
<p>MWORt uses the activation list, the TX matrix апф thé art! СОММОН/MFA/. .;' ***</p>
<p>Algorithm diterlptloa:</p>
<p><a name="bookmark294"></a>•Plod the transaction's strviet tltMnt&quot;</p>
<p>11&nbsp;a IfBV(MFA)</p>
<p>12&nbsp;s 11 ♦ НГАС(ПГА<sub>9</sub>2У ~ 1 00 100 LSB s II <sub>f</sub> 12 IF( IABS(SE(LSE<sub>t</sub>1)).EQ.LTX) GOTO 200</p>
<p>100 CONTINUE •&nbsp;ЩЩр RETURN 2</p>
<p>First MVORK finds&nbsp;out which service eleeent the transaction occupies. If its search falls, it takes the error exit.</p>
<p>&quot;Serving decision&quot;</p>
<p>200 IF(SE(LSE,2).EQ.O) GOTO 250</p>
<p>IF(SE(LSE,3bBQ.1) TX(LTX,6) s ИТ/ RETURN</p>
<p>250 IF(SE(LSE<sub>t</sub>3).EQ.2) RETURN</p>
<p>This section culls out returning or preempted transactions aiut issues a normal return when it finds them. If a preemption is In progress, SE(LSE,2) will be non-zero. If the transaction has Just completed its setup phase, SE(LSE,3) will be 1, in which ease -its remaining work time (TX(LTX,6)) is the entire time it would/;have been served, VT. Preempted transactions remain active and HV0RK returns to the statement following its call.</p>
<p>If a preemption isn't in progress, the subroutine culls out transactions returning to report the end of their work phase; they will have a phase code of 2 in SB(LSE<sub>9</sub>3K Those transactions also remain active and WORK returns normally.</p>
<p>Transactions at the start of their work phase fall through to the next section, if a preemption isn't in progress.</p>
<p>&quot;Serve&quot;</p>
<p>IF(IEX.EQ.O) SE(LSE,1&gt; a LTX IF(IEX.EQ.1&gt; SE(LSS<sub>t</sub>1) * - LTX SE(LSE<sub>f</sub>3) « 2</p>
<p>IF(TX(LTX,6).NE.0) GOTO 400&nbsp;v</p>
<p>AL(LTX,1) a ID AL(LTX,2) a T ♦ VT RETURN 1</p>
<p>The service element's data area is set to show that it is in its work phase (S!£(LSE,3) a 2) and that its occupant is inter-ruptible or ^ot.Jtf the transaction was once preempted and hasn't yet been completely served, TX(LTX,6} will show how much time it has left to ярепЛ' in the work phase; J*W0RK jumps to &quot;Serve reacquiring transactions&quot;. Finally, if the calling transaction is being served from scratch, tfWORK schedules it by setting a time and target in its activation-list entry and then returns to flow management .</p>
<p>dvrr« ruau4uiriiis wranaavwiuna</p>
<p>300 AL(LTX<sub>f</sub>1) « ID</p>
<p>AL(LTX,2) s T ♦ TX(LTX,6) TX(LTX,6) «0 RETURN 1 END</p>
<p>In a re-acquisition, MWOR* schedules the calling transaction to be served for the remainder of its processing time.</p><div>
<p>EXIT 1</p></div><div>
<p>41006</p></div><div>
<p>IPRIMT</p></div>
<p>5*2.3 MCLEAR Purpose:</p>
<p>By calling MCLEAR, the active transaction frees the service element it occupies.</p>
<p>Calling sequence:</p>
<p>CALL MCLEAR (T1FA , EXIT1<sub>1</sub>A1006,1 PR I NT )</p>
<p>Parameters:</p>
<p>«FA&nbsp;Multifacility number (Type number)</p>
<p>The multifacility*s identifying number is given here. Preemption exit</p>
<p>MCLEAR takes this exit when the calling transaction is being preempted from the multifacility. If the user chooses, he may have the subroutine return to a section of his own code, so as to count preemptions or whatever. Then, since MCLEAR has blocked the preempted transac-tion, he must Jump to flow management. If the user need take no special action when a preemption occurs, he should code &amp;10Q5 here; then MCLEAR returns directly to ACTIV2. Error exit</p>
<p>MCLEAR exits to this statement number when the active transaction doesn't occupy a service element in the multifacility it is trying to leave. Trace control</p>
<p>Trace printouts are suppressed when IPRINT * 0* Data area:</p>
<p>MCLEAR uses the MFAC matrix, the state vector, the TX matrix, the SE matrix and the basis vector, MBV.</p>
<p>Algorithm description:</p>
<p>&quot;Find the transaction's service element&quot;</p>
<p>IT» MBV(MFA)</p>
<p>tZ s II ♦ MFAC(MFA <sub>f</sub> 2) - 1</p>
<p>DO 50 LSE s 11 , 12</p>
<p>IF(IABS(SE(LSE,1 )).EQ.LTX) GOTO 100 50 CONTINUE</p>
<p>RETURN 2 ■</p>
<p>first MCLEAR finds out vhich clmtot tlM transaction occupies, if its search fails, it takes the error exit. .</p>
<p>•Free&quot;&nbsp;*</p>
<p>100 DO 150 I » 1 , 3 150 SE(LSE,I) » 0</p>
<p>HFACOlFA, 1 ) a f1FAC(HFA, 1 ) - 1</p>
<p>The program clears the service element's data area and decrements the count of occupied elements.</p>
<p>•Determine the station number&quot;</p>
<p>К ш &quot;EFAC&quot; ♦ MFA</p>
<p>The station number К is co&lt;»pu&amp;4d fro« the type number MlFA.</p>
<p>&quot;Terminate the occupation&quot; .&nbsp;-л аШ^^ШШ^^^^^МИ</p>
<p>IF(TX(LTX<sub>f</sub> 6) .EÛ.0) GOTO ■ AL(LTX<sub>t</sub> 1) s TX(LTX,5) ^ &quot;</p>
<p>AL(LTX,2) x - К&nbsp;-</p>
<p>TX(LTX<sub>f</sub>8) s T&nbsp;ЩШЁ Щ</p>
<p><a name="bookmark295"></a>2oo tx(ltx,5&gt; « a .&nbsp;gaégl■</p>
<p>IF(TX(LTX,6).EQ.0) TX(LTX,7) * О</p>
<p>If the calling transaction has been preempted, it belongs in the facility's queue again* since it has to come back to finish being served. MCLEAR recognizes preempted transactions from the fact that their residual-preecssing-time field <sub>r</sub> TX{LTX.,é), been filled in. The blocked transaction is targeted to the call to MPREEM that caused it to be preempted^ Transactions leaving the multifacility for good don't need the return code in TX(LTX,7l any more, so it is cleared.&nbsp;V'V '&nbsp;'</p>
<p><a href="#bookmark296">&quot;Start the locked transactions&quot;&nbsp;1</a></p>
<p><a href="#bookmark297">state(k) * 1&nbsp;tf :</a></p>
<p>CALL UNLOCK (*C,IPR INT)</p>
<p><a href="#bookmark298">IF(TX(LTX,6).EQ.0) RETURN&nbsp;'</a></p>
<p>RETURN 1</p>
<p>Transactions locked in front of a multifacility are always waiting on a specific element, even though others may be free. When an element is freed by means of MCLEAR<sub>t</sub> the locked transactions must be given a chance to try to acquire the one on which they are waiting* They are given that chance by being started, i.e. by being placed in the blocked state.</p>
<p>preemption vorks at nulti/*acllltl«3 pretty »uch Ilk* It does at facilities: M PRE Et* cuts off a transaction's service without ceremony and starts it on Its way back to the qu«u«.</p>
<p>5*3* 1 MPRBEtt&nbsp;'</p>
<p>purpose: . v.'vV. /•</p>
<p>MPREEM acts like MSEIZE, except that it preempts on« of a mul-tifacility's current occupants, if the new arrival is important enough to warrant immediate service.</p>
<p>j/ MPREEti finds a service element free, the calling transaction acquires it; if the multifacility runs out-Tree. elements as a result, it has become inaccessible. Since no,iprectt&amp;fc£oa occurs, MPREEM does exactly what MSEIZE would bave&nbsp;; 1/7 oc the other hand, MPREEMP finds the booked up, it lets a plan decide whether on* of tliè éould be cleared to make vay for the new arrival and, It,one. Then It calls the policy to let it decide wf^e^^ensaetion should occupy the element chosen by the plan, tW policy ./decide* in favor, of the element's occupant, rf^^^ eiaply blobks t/re calling transaction and returns to flov aariagefient. But if the policy decides against the element -s ^HMEEM initi-êtes a preemption: it blocks the arriripg transaction, but it cuts off the occupant's remaining serving- tiêéiï^ufiv</p>
<p><a name="bookmark299"></a>Calling sequence:&nbsp;' &gt; &quot;; SSSfeBl</p><div>
<p>aBBI</p></div>
<p><a name="bookmark300"></a>«U /«PJttffff (UFA,ID, REP,St 1005iSt 1006, 1 Parameters: '&nbsp;ot; .: v:-<sup>;</sup></p>
<p>BBKf*'' '&quot;a.' ■ ' r <sup>v</sup> '' &quot;&nbsp;V&nbsp;;&nbsp;'&nbsp;'''.V&nbsp;• ^ .,'.&gt;J&nbsp;• V&nbsp;I *&nbsp;■ \ ffiH</p>
<p><a name="bookmark301"></a>The parameters uhose descriptions ditfy^] Otsi^iMlly frost those for subroutine PRBEVP are REP and</p>
<p><a name="bookmark302"></a>MFA ' Hultifacility number (Type number)</p>
<p><a name="bookmark303"></a>ffuitifacilities are identified by constculVr* (lunbers*</p>
<p><a name="bookmark304"></a>^ ' MPREEM CALL 'S statement number</p>
<p>If HPREEV blocks an arriving tranwction, ID specifies tAe target uhere the transaction vi 11 continue its ac* tifity when It is re-activatedt ilt that time, its activity should be to acquire a service element*;: Therefore <sub>9 </sub>- ID should specify the same&nbsp;that</p>
<p>caused the traiftfSctloh to</p>
<p><U| Repeat code v lilliftll^^M Since 9 transaction that acquires an element by,Means of <MPREEti can be preempted, REP provides, a jteans'.ot, . sped« fying whether the transaction oust be fepund to the ele-</p>
<p><aent that began serving it,</p>
<p>HEP » 1 The transaction «ust be bound to Its Initial element. A1005 Blocking exit</p>
<p>FfPREEW takes this exit whenever it blocks the arriving transaction. That occurs In every case, except when the. transaction acquires the facility.« &amp; 1006 Plan-error exit •&nbsp;. &gt;</p>
<p>If no plan is provided for this aultifaeillty, or if no service element can be found, even though the multifacility isn't fully- occupied, thenc'to^EM returns via this exit. It is recommended to terminate simulation in such cases. •&nbsp;M&nbsp;<sup>r</sup> '.V<sup>;</sup>;&nbsp;W^m</p>
<p>IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area: <sup>#</sup>&nbsp;' ,,.&quot;&gt;;:&nbsp;;;</p>
<p>MPREEM uses the activation list* the TX matrix, ;WFAC matrix, the SE matrix and the state vector. -&nbsp;•</p>
<p>Algorithm description:</p>
<p>&quot;Determine the station number&quot;</p>
<p>E * &quot;EPAC&quot; ♦ MFJt</p>
<p>The station number K is computed from the type number ftFA.</p>
<p>&quot;Blocking decision&quot;</p>
<p><a name="bookmark305"></a>K1 s 1&nbsp;V</p>
<p>IF( WFAC(MFA , 1) . EQ.MFAC&lt;MFA ,2) ) COT^IjOO&nbsp;^</p>
<p><sup>;</sup> v Ki * 0 ■ IF(OK.EO.O) GOTO 300 -0K V Q</p>
<p>If there are no more free elements at thi$ multJ. facility, or if the watchdog barks, the above statements JM^p*^B1 ock••, setting K1 along the way, in order to show^ wHj^^lKf^S^^val is being blocked. . *&nbsp;:<sub>f</sub> ...&nbsp;Vj;'-:</p>
<p>&quot;Find a free service element&quot;</p>
<p>IF(TX(LTX,7) .E0.0) GQÏ0 100&nbsp;-</p>
<p>LSE s TX(LTX,7) IF(SE(LSE,1).NE.0) GOTO 200 GOTO 150 100 CALL PLANK MFA ,4400) IF(LSE.EO.O) GOTO 200</p>
<p>Transactions reacquiring an element are weeded out, if t^Rey are bound to the. element they once had. If that element; is free at thç môment, they jump to &quot;Acquire&quot;; it flot, they ' Jump to &quot;Lock&quot;. The multifacility's plan tries to find a free element for any remaining transactions. If it finds one, it returns the element's line number, LSE, and the program continues to &quot;Acquire*;</p>
<p>Ж*</p>
<p><a name="bookmark306"></a>otherwise, it jumps to &quot;Lock*.</p>
<p>&quot;Acquire<sup>11</sup>&nbsp;<sub>:</sub></p>
<p><a name="bookmark307"></a>150 MFAC(MFA<sub>f</sub>1) » MFAC(MFA.I) &gt; 1</p>
<p><a name="bookmark308"></a>IF(MFAC(MFA,1).EQ.MFAC(MFA,2)) STATE(K) * 0 SE(LSE,1) s LTX TX(LTX,5) s ID</p>
<p><a name="bookmark309"></a>IF(REP.EQ.I) TX(LTX,7) s LSE</p>
<p><a name="bookmark310"></a>TX(LTX,8) * 0 V</p>
<p><a name="bookmark311"></a>RETURN</p>
<p>If<sub>f</sub> as a result of the acquisition, the multifacility is fully occupied<sub>9</sub> HSEIZE sets the state vector to show it inaccessible. Then<sub>9</sub> SEIZE sets the acquiring transaction's line number, LTX<sub>f</sub> in SE(LSE,1), clears, the transaction's block time and sets its repeat code.&nbsp;v</p>
<p>&quot;Lock&quot;'. ' &gt;</p>
<p>200 AL(LTX, 1) s ID</p>
<p>V.. AL(LTX<sub>f</sub>2) «* - &quot;KEND&quot; - K&nbsp;&quot;&nbsp;'</p>
<p>. IF(TX(LTX,8).EQ.O) TX(LTX, 8 ) x T RETURN 1&nbsp;&quot;&nbsp;f/v*;</p>
<p>A transaction Is locked if the multifacility has free elements, but cannot assign one of them to the calling transaction. Such cases arise, e.g., when a preempted transaction tries to reacquire the element at which it started processing (REPsI), but that element isn't free. If the transaction were merely blocked, instead of being locked, the simulator would go into an endless loop: since the multifacility is free that transaction would be chosen oyer and over to acquire an element that is-actually unavailable.&nbsp;;&nbsp;w-</p>
<p>When a transaction leaves the multifacility, it could happen to free precisely the element on which such a locked transaction is waiting. Hence, TtCLEAK will have to place all locked transactions in the blocked state*.each time an element is freed (see 5.2.3 &quot;Start the locked transaction&quot;).</p>
<p><a name="bookmark312"></a>&quot;Block&quot;&nbsp;V <sub>;</sub>&nbsp;&quot;&quot;//:</p>
<p>300 AL(LTX,1) = ID</p>
<p>AL(LTX,2) = - . TX(LTX<sub>&gt;</sub>8) = T IF(Kl.EQ.O) RETURN 1</p>
<p>If the watchdog blocks the arriving transaction, MPRESM takes the blocking e*it without further adieu. Otherwise, it continues on to the next -sectionv-T'.fe. ^</p>
<p>&quot;Find a preemption candidate&quot;</p>
<p>CALL PLAllO&lt; **FA, &amp;U 00 )</p>
<p>IF(iSE.EfiJi0. OR. SE&lt; LSE, 1). LT.0;.AND.SE(LSE, 3).EQ.2) RETURN 1 IFISE(LSE-,3).EQ.3&gt; RETURN 1</p>
<p>First, the plan seeks an element it deems fit for preemption. If it cannot find anything, or if .the element it finds is in a non-interruptible work phase or knockdown phase, this section suppresses the preemption.^</p>
<p>•»Call the policy*</p>
<p>P0LVECO) s IABS(SE(LSE, 1) &gt; POLC x 1</p>
<p>DO 350 I s 1 <sub>f</sub> LAL IF(AL(I,2).NE.-K) GOTO 350 POLC s POLC ♦ 1 POLVEC(POLC) s I 350 CONTINUE</p>
<p>CALL POLICY(K)</p>
<p>IF(LTX.EQ.IABS(SE&lt; LSE,1))) RETURN 1&nbsp;;</p>
<p>Here, the policy decides whether a preemption is called for or not. Just as in ACTIV2, MPREEM gathers in POLVEC the line numbers of all transactions waiting at the multifacility<sub>f</sub> inserting the chosen element's occupant as the first entry. Then it calls POLICY (see 3.3). which returns the line number of the transaction it selects -in LTX. If the policy has selected the element's occupant, no preemption is called for.</p>
<p>•Preempt*</p>
<p>LTX = IABS(SE(LSE,1)) SE(LSE,2) s 1</p>
<p>IF(SE(LSE,3).E0.1) RETURN I TX(LTX<sub>f</sub>6) = AL(LTX,2) ~ T -AL(LTX<sub>f</sub>2) x T&nbsp;'</p>
<p>RETURN 1</p>
<p>First, we set the preemption code, so that MWORK will know what has happened. If the element's occupant is being set up, it may not be interrupted, but we set the preemption code, so that it will skip its work phase and go directly to its knockdown phase (if there is one) .</p>
<p>if the occupant is in its work phase, MPREEM sets its remaining processing time in ?X(LTX,6) and schedules it to be reactivated immediately: we have cut off the occupant's service/Now the occupant will again call <sup>M</sup>W0RX, which recognizes it and returns to the next statement in the model/</p>
<p>•Incorrect multifacility. occupation* ;&nbsp;^ .</p>
<p>400 RETURN 2&nbsp;'&nbsp;pi'</p>
<p>END&nbsp;. • ;;</p>
<p>If there is no plan for this multifacility, or if no element jattl b« found, even though the multifacility isn't fully occupied, then the program return's via the error exit.</p>
<p>5.3*2 Setup and Knockdown In Case of Preemption</p>
<p>HSETUP and MKNOCK correspond to SETUP and KHOCKD. We shall describe only MSETUP, since HKHOCK differs from it only slightly.</p>
<p>5.3.3 MSETUP</p>
<p>V „ -</p>
<p>Purpose:</p>
<p>By .calling MSETUP, the active transaction simulates the time . it spends being set up at a multifacility's service element. MSETUP schedules the transaction to be activated at the end of its setup phase, targeting it to a specified statement number. During its setup phase, the transaction is not preemptible.</p>
<p>Calling sequence:</p>
<p>CALL MSETUP (ST,MFA,IDN,41005,41006,IPRINT)</p>
<p>Parameters:</p>
<p>ST&nbsp;SetuJ&gt; time&nbsp;•</p>
<p>£ The active transaction requests to be set up for ST time units.</p>
<p>MFA&nbsp;Multifacility number (Type number)</p>
<p>The - multifacilities are identified by sequential numbers. I DM&nbsp;Target</p>
<p>MSETUP targets the transaction to this statement number, where it is to continue its activities at the end of its setup phase. That will normally be a call to MW0RK.</p>
<p>41005&nbsp;Scheduling exit</p>
<p>MSETUP deactivates the calling transaction by placing it in the scheduled state. Then flow management must receive control again, so that it can activate another «■W transaction.</p>
<p>41006&nbsp;. Error exit</p>
<p>The subroutine returns via this exit if a transaction tries to be set up at a multifacility where it doesn't occupy a service element. IPRIHT Trace control</p>
<p>Trace printouts are suppressed when IPRIWT = 0.</p>
<p>Data area:</p>
<p>MSETUP uses the activation list, the TX matrix and the area COrntON/MFA/.</p>
<p><a name="bookmark313"></a>A1 go r it hm ;;d £s c r i p t i o n:</p>
<p>&quot;Find the transact ion's service element&quot;</p>
<p>. II s MBV(MFA)</p>
<p>12 r 11 ♦ MFAC(MFA.,2) - 1 DO 100 LSE r II , 12</p>
<p>IF(IABS(SE(LSE<sub>f</sub>1)).EQ.LTX) GOTO 200 100 CONTINUE RETURN 2</p>
<p>First MSETUP finds out which service element the transaction occupies. If its search fails, it takes the error exit.</p>
<p>&quot;Set up the service element*</p>
<p>200 SÉ(LSE,t)&nbsp;s - LTX</p>
<p>SE(LSE,3)&nbsp;= 1</p>
<p>AL(LTX<sub>t</sub>1)&nbsp;s IDN</p>
<p>AL(LTX<sub>f</sub>2)&nbsp;s T ♦ ST RETURN 1 END.</p>
<p>We mark the&nbsp;multifacility's service element non-interruptible</p>
<p>and setting up.&nbsp;Then we schedule thg^transaction and return to flow management.</p>
<p>5:4 The Plan: Service-Element Management</p>
<p>A multifacility needs a procedure that decides which of its service elements is to be acquired and;, during preemptions, which is to be cleared. That procedure is called a plan. When a transaction tries to acquire a service element, the plan-in decides which of the free ones it gets. Similarly, the plan-out decides which element should be cleared for a preempting transaction.</p>
<p>5.4.1 PLAN! and PLAWO Purpose:</p>
<p>PLAN! and PLAN0 select the plan that decides, for a given multifacility, which of its elements is to be acquired or freed. GPSS-F provides for up to five different plans of each kind: in and out. Further, GPSS-F has two pre-programmed plans: LFIRST (a plan-in) and PRIOR (a plan-out). The user is free to write additional ones.. We describe only PLANI, since PLANO is similar.</p>
<p>Calling sequence:&nbsp;-. ;§t</p>
<p>CALL PLANT. (MFA ,FXIT1)</p>
<p>Parameters: '&nbsp;. v</p>
<p>MFA&nbsp;Multifacility number (Type number)</p>
<p>The number of the multifacility whose plan is to be se-. .lected. EXXT1 Plan-error exit</p>
<p>If no plan is provided for- the multifacility, or if no service element can be found, even though the multifacility isn't-fully occupied -<sub>9</sub> the program that called PLAHI should return to simulator termination.</p>
<p>Data area:</p>
<p>PLANI and PLANO use the plan matrix, PLAMA. Each multifacility has a line in the matrix, which specifies that multifacility's plans. It is defined as follows:</p>
<p>INTEGER PLAMA</p>
<p>DIMENSION PLAMA( &quot;MFAC1* <sub>f</sub> 2 )</p>
<p>Its elements have the following meanings:</p>
<p>PLAMA(MFA,1) Plan-in</p>
<p>Each plan is denoted by a number. The user enters that number in the matrix in section 4 of the chassis, by which means he assigns each multifacility a specified plan-in.</p>
<p>PLAMA(MFA<sub>f</sub> 2) Plan-out</p>
<p>In the same way, the user assigns each multifacility a plan-out.</p>
<p>Algorithm description:&nbsp;-</p>
<p>.</p>
<p>&quot;Find the plan&quot;&nbsp;.</p>
<p>IF(PLA'4A(MFA, D.ME.O) GOTO 100 50 RETURN 1 100 IADDR = PLAMA(MFA,1)</p>
<p>GOTO (1,2,3,4,5) V IADDR</p>
<p>We find the multifacility's plan in the plan matrix and jump to the appropriate call.</p>
<p>&quot;Call the PLANI subroutine&quot;</p>
<table border="1">
<tr><td>
<p>1</p></td><td>
<p>CALL LFIRST(MFA,450)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>'t i:</p></td><td>
<p>CALL PLANI2(MFA)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>3</p></td><td>
<p>CALL PLANI3CMFA)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>4</p></td><td>
<p>CALL PLANI4(MFA)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>5</p></td><td>
<p>CALL PLANI5(KFA)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p></p></td><td>
<p>END</p></td></tr>
</table>
<p>The subroutine provides for five different jxlans. The plan-in whose number is 1 is assigned to the pre-programmed plan, LFIRST.</p>
<p>Noter •&nbsp;.&nbsp;:</p>
<p>* <sup>Ir the use</sup>r writes a plan, he gives it a number and a Fortran</p>
<p>name, Theq he enters its number in the appropriate linfcs in the</p>
<p>Plan matrix and its name in the appropriate CALL statements in PLANI and PLANO.</p>
<p>5.4.2 LFIRST</p>
<p>Purpose:</p>
<p>LFIRST assigns a multifacility's service elements sequentially, It always begins its search for a free one from the beginning.</p>
<p>Calling sequence:</p>
<p>CALL LFIRST (MFA,EXIT1) Parameters:</p>
<p>MFA&nbsp;Multifacility number (Type number)</p>
<p>The number of the multifacility whose service element is to be acquired is specified. EXIT! Plan-error exit</p>
<p>If LFIRST cannot find a free service element, even though the multifacility isn't yet fully occupied, the program that called it should exit to simulator termination.</p>
<p>Data area:</p>
<p>LFIRST uses the TX matrix and the area COMMON/MFA/. Algorithm description: &quot;Find a free service element&quot;</p>
<p>11&nbsp;= MBV(MFA)</p>
<p>12&nbsp;= 11 ♦ MFAC(MFA,2) - 1 DO 100 LSE = 11 , 12 IF(SE(LSE, D.EQ.O) RETURN</p>
<p>100 CONTINUE</p>
<p>We find the first free service element.</p>
<p>&quot;Error&quot;</p>
<p>RETURN 1 END</p>
<p>If no service element can be found, the error exit is taken.</p>
<p>5.4.3 PRIOR Purpose:</p>
<p>During preemptions, an out-plan decides which service element to clear. PRIOR selects the service element whose transaction has the lowest priority. It considers only transactions whose priority is. lower than the preempting transaction's and those which are marked preemptible.</p>
<p>Calling sequence:</p>
<p>CALL PRIOR(M<sup>p</sup>A)</p>
<p>Parameters:</p>
<p>MFA&nbsp;Multifacility number (Type number)</p>
<p>The number of the multifacility where the preemption is to take place is specified.</p>
<p>Data area:</p>
<p>PRIOR uses the TX matrix and the area COMMOM/MFA/.</p>
<p>Algorithm description:</p>
<p>&quot;Initialize the search&quot;</p>
<p>LSE = 0</p>
<p>PR = TX(LTX,4)</p>
<p>11&nbsp;= MBV(MFA)</p>
<p>12&nbsp;r 11 ♦ MFAC(MFA,2) - 1</p>
<p>The search for the lowest-priority transaction runs through precisely that part of the SE matrix belonging to the multifacility whose type number is MFA. The active transaction's priority is set in PR.</p>
<p>&quot;Search out the service element&quot; DO 100 I s 11 , 12</p>
<p>IF(SE(I,1).LT.0.AMD.SE(I,3).EQ.2) GOTO 100 IF(SE(I,2).E0.1) GOTO 100 LTX1 = IABS(SE(I,1)) IF(TX(LTX1,4).GE.PR) GOTO 100 PR = TX(LTX1,J|) LSE = I 100 CONTINUE RETURN END</p>
<p>We seek out the element whose occupant has the lowest priority, counting only those with priorities even lower than the active transaction's. At the end of the search, that element's line number will be in LSE.</p>
<p>6 STORAGES</p>
<p>6.1 The Structure of Storages</p>
<p>Storages are characterized by their capacities and contents. Transactions acquire and free a specific number of storage spaces; those whose demands cannot yet be met<sub>9</sub> queue up to wait«</p>
<p>Example:</p>
<p>• The supervisor at a downtown parking garage assigns each car a space. When the garage Is full, arriving cars must wait in line.</p>
<p>GPSS-F has addressible and non-addressible storages. In a non-addressible storage, the elements are fully undifferentiated; a space is just a space. It distinguishes itself in no way from any other space, not even by its location in the storage. For such storages, GPSS-F keeps track of nothing more than their total capacity and present vacancy rate. There is no way to acquire a particular space in the storage.</p>
<p>Addressible storages have elements that are distinguished from one another by their locations, called their addresses, and by their contents. GPSS-F keeps track of both. A transaction can request more than one element in an addressible storage. Procedures called strategies, which may vary from storage to storage, assign the spaces to requesting transactions.</p>
<p>Example:</p>
<p>* In a normal engagement at a mov*e theater, each seat is, from the management's point of view, like every other. The theater could be modelled by a non-addressible storage. Tickets are sold until the theater ir. full and, finding a seat, the buyer fends for himself. For special engagements, the management sells reserved-seat tickets at various prices. The buyer sits in the seat he paid for. Here, the theater would be modelled by an addressible storage, since the sold seats have quite specific locations, which make a difference dear to management's heart. Each seat's location is its address.</p>
<p>We shall use the terms &quot;storage elements&quot; and &quot;storage spaces&quot; interchangeably. By &quot;storage space&quot;, however, we shall mean one or more storage spaces, taken as a whole.</p>
<p>Transactions waiting to acquire space at a storage wait in the locked state, not in the blocked state (see 2.2.2). The user specifies when they should again try to acquire space. That process is called a start and is occasioned by a call to UNLOCK (see 2.5.3). A3 a result of the start, ACTIV2 activates each transaction at a storage, one after the other, in the order determined by the policy; each tries its luck at getting its required space. When it doesn't get space, it is relocked to wait for the next start.</p>
<p>It would not suffice, as with other stations, merely to activate the highest-priority in the queue, since lowerpriority transactions may have satisfiable space requirements, even if the first transaction selected doesn't. To put it differently, the wait condition at a storage contains transaction-specific parameters, namely their space requirements. Thus the condition must be tested for each waiting transaction (see 7.2.2).</p>
<p>When a transaction comes to a storage, there are two possible courses of action: either we lock it immediately and place it in the queue, or we can let it try once to get its space. In the one case, the transaction waits for a start before it tries to acquire its space; following the start, it competes with other transactions for the space available. In the other case, the transaction tries once to get into the storage; if there is space enough for it, it acquires that space; otherwise it is locked and placed in the queue to wait on the next start.</p>
<p>Each storage has a line in the storage matrix (STO matrix), which is defined as follows:</p>
<p>INTEGER STO</p>
<p>DIMENSION ST0(&quot;ST01&quot;,2)</p>
<p>The individual elements have the following meanings:</p>
<p>STO(NST,1) Content</p>
<p>The total number of occupied spaces is specified for the storage whose number is NST.</p>
<p>ST0(NST,2) Capacity</p>
<p>The capacity specifies the total number of spaces in the storage. The number of vacant spaces is the storage's capacity minus its content.</p>
<p>Unlike the data areas for facilities and multifacilities, the data areas for storages don't show which transactions occupy their elements. That opens the possibility of designing models in which transactions don't occupy the storage at all: instead, they just deposit items, which take up space, or they withdraw items, thereby freeing space.</p>
<p>Example:</p>
<p>• At a hot-dog stand, the transactions are the delivery boy, who delivers cold hot dogs and the customers, who buy hot hot dogs. The delivery boy delivers two thousand dogs three times a day; the customers buy one to five at a shot. The stand could be modelled by a storage. Three times a day, at the right times, a transaction would be generated that &quot;acquires&quot; two thousand &quot;spaces&quot; at the storage; transactions are generated at random that &quot;free&quot; one to five of the &quot;spaces<sup><a name="footnote7"></a><a href="#bookmark314">7</a></sup>*.</p>
<p>Since the transactions' only purpose is to raise or lower the number of hot dogs at the stand, they are annihilated as soon as they have acquired or freed space. In this model, they would not remain at the storage as the cars in the parking-garage model do.</p>
<p>6.2 Non-Addressible Storages</p>
<p><a name="bookmark315"></a>Non-addressible storages have&nbsp;only the S?0 matrix as data</p>
<p><a name="bookmark316"></a>area. Space in them is acquired or&nbsp;freed by means of the subroutines ENTER and LEAVE.</p>
<p>6.2.1 ENTER Purpose:</p>
<p>Subroutine ENTER tests whether there is enough vacant space in a given storage to fill an arriving transaction's demand. If there is<sub>t</sub> it raises the storage's total content by the requested amount and returns to the statement following the call. Since ENTER processes only non-addressible storages, it keeps no account of which spaces the transaction acquired. If there is not space enough to accommodate the arriving transaction's request, it is locked and placed in the queue.</p>
<p>Calling sequence:</p>
<p>CALL ENTER (NST,NE,ID,LOCK,&amp;1005,IPRINT)</p>
<p>Parameters:</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>Storages are numbered sequentially. The number given specifies from which storage the space is to be acquired. It must specify a non-addressible storage. NE&nbsp;Number of elements requested</p>
<p>The transaction requests NE spaces. ID&nbsp;ENTER CALL's statement number</p>
<p>If a transaction must be locked or blocked, it is given this statement number as target; when it is re-activated, it continues its activity at the statement whose number this is. Normally, that would be the call to ENTER that originally caused the transaction to be locked. LOCK Lock flag</p>
<p>The lock flag specifies whether the transaction should be locked immediately when it first arrives at the storage, or whether it should try to acquire its space. LOCK = 0 The transaction should try to acquire its space.</p>
<p>LOCK = 1 The transaction should be locked immediately when it first arrives. &amp;1005 Locking and blocking exit</p>
<p>If there is not space enough for the transaction, it must be locked. Then flow management should regain control, whence statement number 1005 is always be specified here. The exit is also taken when a new arrival should be given a chance to try to get its space: the</p>
<p>transaction is blocked first (see notes). I PRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT = 0.</p>
<p><a name="bookmark317"></a>Data area:</p>
<p><a name="bookmark318"></a>ENTER uses the activation list, the TX matrix and the STO matrix.</p>
<p><a name="bookmark319"></a>Algorithm description:</p>
<p><a name="bookmark320"></a>&quot;Determine the station number*<sup>9</sup></p>
<p>K s &quot;EMFAC&quot; ♦ NST</p>
<p><a name="bookmark321"></a>The station number K is computed from the type number NST.</p>
<p><a name="bookmark322"></a>&quot;Watchdog<sup>11</sup></p>
<p>IF(OK.EQ.O) GOTO 10 OK S 0</p>
<p>ENTER recognizes by means of 0K<sub>f</sub> whether a transaction is trying for the very first time to get space, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated. If the transaction is arriving for the first time, it is sent to &quot;First acquisition attempt&quot;,</p>
<p>&quot;Test the space request&quot;</p>
<p>IF(ST0(NST,1)+NE.GT.ST0(NST,2)) GOTO 20</p>
<p>If the requested space is available, the program proceeds to &quot;Acquire&quot;; otherwise, it jumps to &quot;Lock&quot;.</p>
<p>&quot;Acquire&quot;</p>
<p>ST0(NST,1) = ST0(NST,1) ♦ NE</p>
<p>TX(LTX,8) = 0</p>
<p>RETURN</p>
<p>The acquisition consists of raising the content counter by the number of spaces the transaction acquires. In case the transaction comes from the queue, its lock time is cleared.</p>
<p>&quot;First acquisition attempt&quot;</p>
<p>10 CONTINUE</p>
<p>IF(LOCK.GT.O) GOTO 20 AL(LTX,1) = ID AL(LTX,2) = - K TX(LTX,8) = T RETURN 1</p>
<p>If a transaction is arriving at a storage for the first time, it can choose to be locked immediately, or to try its luck at getting its required space. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock&quot;.</p>
<p>If LOCK is 0, the transaction is given a chance to acquire its required storage. But first, it competes for that space with any</p>
<p>transactions that have Just been started (see notes): it la thrown In among the started transactions, if there are any, by being blocked (not locked) and placed in the queue.</p>
<p>Now, since storages are not directly under transaction manage« ment's supervision, they are always marked free, ACTIV2 finds the station free with at least one blooked transaction waiting; it begins undertaking conditioned activations/ activating the blocked transactions at the station, one after the other, until all of them (which may be just the new arrival) have either acquired space or been relocked. This time, when the new arrival is activated, it is routed to the &quot;Test the space request* section, since it has been in the queue (0Ks1),</p>
<p>&quot;Lock&quot;</p>
<p>20 AL(LTX, V) * ID</p>
<p>AL(LTX,2) * - &quot;KEND&quot; - K IF(TX(LTX,8).FQ.O) TX(LTX,8) s T RETURN 1 END</p>
<p>A transaction executes this section when its storage request isn't satisfiable or when it is required to be locked immediately when it first arrives. A lock code is set in its activation-list entry.</p>
<p>Notes:</p>
<p><sup>9</sup> Flow management will not, of course, activate locked transactions. Before it can activate them, to let them try to get space, the user must block them by means of a start, i.e. by calling UNLOCK.</p>
<p>•&nbsp;There are several ways a transaction can arrive for the first time at a storage where a start has just taken place. The most plausible situations would be in models where each transaction that leaves a storage calls UNLOCK, giving the waiting transactions a chance to acquire the space it has Just freed. Following the start, for example, a transaction barred at a gate (see chapter 7) could be sent to the storage, if the start causes the gate's wait condition to be fulfilled.</p>
<p>•&nbsp;When an arriving transaction tries immediately to acquire space, it calls ENTER twice in a row. The first time, ENTER blocks it and returns control to flow management. Flow management takes no special notice of what has happened, but it fihds (at least) the new arrival blocked at the storage. Since storages are always marked accessible, ACTIV2 activates whichever transaction the storage's policy selects; the transaction is, of course, targeted to call ENTER. Its first call to ENTKR merely created a situation in which it could be given a chance to acquire its space by means of a second call to ENTER.&nbsp;11188</p>
<p>•&nbsp;ENTER deals only with non-addrcssiblo storages. The user should take care not to specify the storage number of an address-ible storage in calls to this routine. Non-addressible storages</p>
<p>have no entries under their line numbers in the strategy matrix (see 6.5.1)•</p>
<p>• Addressible and non-addressible storages are stations of the same type: they are numbered consecutively without regard to ad-dressibillty; both kinds are jumbled together in the STO matrix.</p>
<p>6.2.2 LEAVE Purpose:</p>
<p>LEAVE frees a specified number of spaces at a storage. Since LEAVE deals only with non-addressible storages, it does no bookkeeping on the locations of the freed spaces. If the transaction tries to free more spaces than the total number currently held, a special exit is taken to give the user the opportunity to take any special actions.</p>
<p>Calling sequence:</p>
<p>CALL LEAVE (NST,NE,EXIT1,IPRINT)</p>
<p>Parameters:</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>Storages are numbered sequentially. NST specifies the. storage in which spaces are to be freed; it must specify a non-addressible storage. NE&nbsp;Number of elements to be freed</p>
<p>The transaction frees NE spaces. EXIT1 Aborted-freeing exit</p>
<p>When a transaction tries to free more space than is currently occupied, this exit is taken. IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>LEAVE uses the STO matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Free*</p>
<p>IF(ST0(NST,1).LT.NE) GOTO 10 ST0(NST,1) = ST0(NST,1) - NE RETURN 10 RETURN 1 END</p>
<p>When the transaction t^ies to free more space than is currently occupied, leave takes its abort exit. Otherwise, it reduces the content counter by the amount of space to be freed and returns normally; the active transaction remains active and continues its activity with the statement following the call.</p>
<p>Notes:</p>
<p>* When LEAVE takes its abort exit, the user must decide what to do next. If the model has made a mistake, he should jump to statement 1006 to break off simulation. Certain models could conceivably have built-in aborted freeings, for instance at a storage like the hot-dog stand, where the stand has just sold out or at a store, where the clerk must check the stock to see if he can fill an order. In those cases, the model's design dictates what should happen next: relock the transaction and let it try its freeing request again later, or perhaps forget the freeing request altogether, or whatever.</p>
<p>6.3 Strategies</p>
<p>Addressible storage is acquired and freed by a multitude of strategies. They depend even more strongly on the problem to be solved than do policies. A bird's-eye view of the simplest ones follows. Strategies that fill up storage are called allocation strategies (a-strategies); those that free it, freeing strategies (f-strategies).</p>
<p>Example:&nbsp;.</p>
<p>* A mail-order company's warehouse is organized, by means of an a-strategy, to minimize access time to the highest-turnover items.</p>
<p>* At a warehouse for highly perishable foods, an f-strategy sees to it that orders are filled with those items closest to their sale-limit dates.</p>
<p>Don't confuse policies with strategies. Policies determine in which order started transactions try their luck at getting space. Strategies decide which storage spaces are acquired or freed. Each storage has a policy and two strategies; the former administers its queue, the latter, its space.</p>
<p>6.3-1 Storage Acquisition</p>
<p>An a-strategy fulfils two tasks: first, it decides whether or not to fill a request for space and, assuming there is space enough, it decides which storage elements to allocate. If there is not space enough to meet its request, a transaction waits in the queue.</p>
<p>6.3.2 First-fit</p>
<p>First-fit selects the first space it finds large enough to meet the request. The strategy doesn't consider how well the request fits in the free area. As a result, odd-sized holes arise, scattered throughout the storage, which is then said to be fragmented. The strategy's advantage is its low search time.</p><img src="Untitled.FR10_files/Untitled.FR10-7.jpg" style="width:93pt;height:15pt;"/>
<p>I I</p>
<p>v</p><div>
<p>1*1 Ml</p>
<p>I «1</p></div><div>
<p>I I***; I2|2 I 1***1</p></div><div>
<p>1***1 I 2 | 1***1</p></div><div>
<p>I 3 I</p></div>
<p>storage</p>
<p><a name="bookmark323"></a>1***1 |*|#**»«| |</p>
<p>I 2 | 2 |1| 3 I 2 I l*#*l 1*1*****1 |</p><div style="border-left:solid;">
<p>*******</p>
<p>*******</p>
<table border="1">
<tr><td>
<p></p></td><td>
<p>***</p></td></tr>
<tr><td>
<p>2</p></td><td>
<p>2</p></td></tr>
<tr><td>
<p></p></td><td>
<p>***</p></td></tr>
</table></div><div>
<p>*********</p></div>
<p>FIGURE 23&nbsp;THE FIRST-FIT STRATEGY</p>
<p>Figure 23 depicts a partially filled storage. The starred fields represent occupied areas; the clear fields, free areas. First-fit fills a request for three storage elements from the first area large enough to handle it. In the example shown, it generates a free remainder, 2 spaces long.</p>
<p>6.3-3 Best-fit</p>
<p>Best-fit is similar to first-fit, except that it doesn't necessarily fill the request from the first free space large enough to handle the request. Instead, it finds the free space where the request fits most snugly.</p>
<p>Best-fit's disadvantage is its longer search time; its advantage is better use of the storage. Figure 2M shows the same example as figure 23» except that best-fit allocates the space.</p>
<p>Example:</p>
<p>■ A shipping-company's warehouse is divided into equal-area parcels, each identified numerically. The parcels are the smallest units assigned to a given shipment. On demand, the warehouse manager assigns a contiguous space large enough to accommodate a shipment. Using a first-fit strategy, he would assign the space nearest the warehouse door. Using best-fit, he would assign the space where the shipment fits best.</p>
<p>I I</p>
<p><a name="bookmark324"></a>V</p>
<table border="1">
<tr><td>
<p>1***1</p></td><td>
<p></p></td><td>
<p>1*1</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p></p></td><td rowspan="3">
<p>|*.*|</p>
<p>1 2 | I***!</p></td></tr>
<tr><td>
<p>1 2 |</p></td><td>
<p>2</p></td><td>
<p>111</p></td><td>
<p>5</p></td><td>
<p>1 5 1</p></td><td>
<p>3</p></td><td>
<p>1 1</p></td><td>
<p>1</p></td><td>
<p>2</p></td></tr>
<tr><td>
<p>1***1</p></td><td>
<p></p></td><td>
<p>1*1</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p>1</p></td><td>
<p></p></td></tr>
<tr><td colspan="2">
<p>STORAGE</p></td><td>
<p>4</p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td><td>
<p></p></td></tr>
<tr><td>
<p>| r** |</p></td><td>
<p></p></td><td>
<p>1*1</p></td><td>
<p></p></td><td>
<p>|««*»***** j</p></td><td>
<p>*****</p></td><td>
<p>1 *******</p></td><td>
<p>1</p></td><td>
<p></p></td><td rowspan="2">
<p>1***1 1 2 |</p></td></tr>
<tr><td>
<p>1 2 |</p></td><td>
<p>2</p></td><td>
<p>Ml</p></td><td>
<p>5</p></td><td>
<p>1 5 1</p></td><td>
<p>3</p></td><td>
<p>I 4</p></td><td>
<p>1</p></td><td>
<p>2</p></td></tr>
<tr><td>
<p>| **« |</p></td><td>
<p></p></td><td>
<p>l«l</p></td><td>
<p></p></td><td>
<p>|********* j</p></td><td>
<p>*****</p></td><td>
<p>1 *******</p></td><td>
<p>1</p></td><td>
<p></p></td><td>
<p>|*»*|</p></td></tr>
</table>
<p>FIGURE 24&nbsp;THE BEST-FIT STRATEGY</p>
<p>6.3.4 Conditioned Storage Assignment</p>
<p>This class of strategies allocates storage space on the basis of the type of item being stored. For example: as a precaution</p>
<p>against fire,&nbsp;a warehouse stores important or expensive items so that they can be removed quickly.</p>
<p>6.3.5 Segmenting</p>
<p>It is easy to optimize the use of storage, if incoming items need not be stored together, that is if they can be divided up and distributed over free areas of whatever size. Dividing up a block of items is called segmenting. The disadvantage of the method is that it takes a lot of bookkeeping. Figure 25 shows an allocation by a segmenting a-strategy. The request for 8 storage elements is broken up into requests for 2 and 5 elements and a single element.</p>
<p>6.3.6 Collecting Free Space</p>
<p>In strategies without segmenting, the items in a storage may have to be shifted together from time to time, to make room for new requests. The mechanism fry means of which the Items are shoved together is variously called shifting or collecting free space (see figure 26).</p>
<p>I <sub>:</sub> J</p>
<p>I 2 I 5 Ml</p>
<p>&quot;&quot;1 I II</p>
<p>| ------- |</p>
<p>----- | |</p>
<p>v&nbsp;v&nbsp;v</p>
<p><a name="bookmark329"></a>(•••I |.|&nbsp;I •••••»»••!&nbsp;(••«.«••I I»»«I</p>
<p>I 2 | 2 11 I 5 I 5 I3I t |2|2| !••«( |.| | ........| |***|</p>
<p>(•••I•{•«**«*»•*( *•**»*•••|*| |***««««| 1***1</p>
<p>I 2 | 2 |1| 5 I 5 Ml 2 | 4 | 2 | 2 | ,...<sub>t</sub>.,*««...... ......|***|</p>
<p>FIGURE 25 SEGMENTING</p>
<p><a name="bookmark330"></a>I ***I 1*1&nbsp;|••»•»»*»*, || |«*«|</p>
<p>I 2 | 2 11 | 5 I 5 131 * |2|2| |»| |*««**•**» | |•••«•*•j |«*«|</p><div>
<p>I I</p>
<p>V</p></div>
<p>I I</p>
<p>I&nbsp;|2</p><div>
<p>2 |1|</p></div><div>
<p>12</p></div>
<p>FIGURE 26 COLLECTING FREE SPACE</p>
<p>6.3*7 Freeing Space</p>
<p>When a transaction requests that specific items be removed from a storage, no f-strategy need decide which spaces to free. F-strategies are needed only when the request doesn't specify which items to remove.</p>
<p>Examples:</p>
<p>•&nbsp;At a railway station, a traveller takes her suitcase from the storage locker uniquely identified by her key number. No f-strat-egy is needed.</p>
<p>•&nbsp;A widget manufacturer keeps a large stock, against a sudden run on widgets. When an order arrives, even though it specifies the color, an f-strategy has to decide precisely which widgets to send, or, in other words, which warehouse spaces to free.</p>
<p>The established names for f-strategies are identical with policies' names. The usage is justified, in that the selection procedures are similar; it is confusing, in that policies and f-strategies pull different objects from different bins. Policies select transactions from queues and strategies select spaces from storages. Since policies' selection procedures have already been explained (chapter 3)» the parallel procedures for strategies are not set out again here.</p>
<p>6.4 Addressible Storages</p>
<p>Addressible storages keep track of filled locations and their contents. Each location has a unique, identifying number, called its address. Locations are numbered consecutively, starting with 1, just as in a one-dimensional Fortran array.</p>
<p>For addressible storages, we shall use the terms &quot;spaces*, &quot;elements&quot; and &quot;locations&quot; interchangeably. We shall also use &quot;location&quot; synonymously with &quot;address&quot;, where no confusion could arise.</p>
<p>6.4.1 The Structure of Addressible Storages</p>
<p>The STO matrix suffices to describe non-addressible storages, but addressible storages require tne SM (segment) matrix as well. Every storage location in every addressible storage in the model has a line in the SM matrix, which depicts the storages' contents,&nbsp;- - ; .^^^^HB^B</p>
<p>In order to administer storages more easily, we group together, all consecutive, free locations or consecutive locations that were allocated simultaneously. Those groups of consecutive locations are called segments. The length of a segment, whether free or occupied, is stored in the SM-matrix line belonging to the first space in the segment.</p>
<p>SM MATRIX</p><div>
<p>I I</p>
<p>SECTION &lt; FOR STORAGE | NST s 1&nbsp;j</p></div>
<p>SM(1,1) | SH(1,2) |&lt;~ SBV VECTOR</p>
<p>---| SBV(1)</p><div><img src="Untitled.FR10_files/Untitled.FR10-8.jpg" style="width:132pt;height:276pt;"/></div><div>
<p>SECTION FOR STORAGE NST</p></div>
<p>&lt;—</p>
<p>&lt;----1 SBV(&quot;ST01<sup>M</sup>) |</p>
<p>I</p>
<p>SECTION&nbsp;&lt;</p>
<p>FOR STORAGE | NST = &quot;ST01<sup>H</sup> |</p>
<p>SM MATRIX AND STORAGE BASIS VECTOR</p>
<p>The segment matrix is defined as follows: INTEGER SM</p>
<p>DIMENSION SM(&quot;SMI<sup>M</sup>,2)</p>
<p>The individual elements have the following meanings:</p><div>
<p>FIGURE 27</p></div>
<p>Segment length</p>
<p>A segment consists of one or more contiguous locations that are either free or that were allocated together. If line number LSM belongs to the first location in a segment, this element specifies the number of locations in the segment; otherwise, it contains zero.</p><div>
<p>SM(LSM,1)</p></div>
<p>SM(LSM,2) Code</p>
<p>Each segment has a code. GPSS-F marks this element for the first location in a free segment with the code, •1. The first location in an occupied segment is marked with any code the user specifies (see 6.4.2).</p>
<p>Subroutine INIT3 (see 2.6.4) subdivides the segment matrix into sections, each belonging to a particular storage, and each containing as many lines as the storage has locations. The line number of the first line in each section is stored by INIT3 in the storage basis vector (SBV). The storage basis vector divides the segment matrix into sections as shown in figure 27. It is defined as follows:</p>
<p>INTEGER SBV DIMENSION SBV(&quot;ST01&quot;)</p>
<p>Notes:</p>
<p>*&nbsp;Space in addressible storages is always acquired and freed in segments, i.e. in groups of consecutive locations. A segment is characterized by its beginning location, its length and its code.</p>
<p>V Sections of the segment matrix are not to be confused with segments. The segment matrix is divided up into sections, each belonging to a specific, addressible storage. Each section is further subdivided into segments, each representing a free area or an area that was allocated all at one time. The beginning of each section in the segment matrix is noted in the storage basis vector. The beginning of each segment is noted in the segment matrix itself by the segment's length entry, SM(LSM<sub>f</sub>1), all subsequent locations in the segment being marked zero.</p>
<p>*&nbsp;When part of a free segment is allocated, the segment is divided into two: an allocated segment with a user-specified code and a free segment with the standard free code, -1.</p>
<p>*&nbsp;Only the first line in a segment is marked with its code and length.</p>
<p>*&nbsp;The total number of storage locations available to the user is fixed when the simulator is dimensioned (see appendix A3). Building a model, the user may assign the available storage locations to individual storages any way he sees fit. He must specify each storage's capacity in section 4 of the chassis by means of a direct entry in the STO matrix (see 2.6.1 and 11.6).</p>
<p>6.4.2 ALLOC Purpose:</p>
<p>ALLOC tests whether there is enough vacant space in a given storage to fill the calling transact ion's request. If there is, it assigns the space in the form of a segment and returns to the statement following the call. Since ALLOC deals only with ad-dressible storages, ;it keeps account in the segment matrix of which spaces the transaction acquired. The calling transaction is locked and placed In the queue, if there is not space enough to accommodate its request.</p>
<p>Calling sequence:</p>
<p>CALL ALLOC (NST,NE,MARK,ID,LINE,LOCK,41005,41006,IPRINT)</p>
<p>Parameters:</p>
<p>The parameters whose descriptions differ essentially from</p>
<p>those in subroutine ENTER are: MARK, LINE and 41006.</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>Storages are numbered sequentially. NST denotes the storage where the calling transaction requests space. It must specify an addressible storage.</p>
<p>NE&nbsp;Number of elements requested</p>
<p>The transaction requests NE spaces.</p>
<p>MARK Segment code</p>
<p>All segments receive a positive integer as code when they are allocated; this parameter specifies the code for the segment allocated to the active transaction.</p>
<p>ID&nbsp;ALLOC CALL's statement number</p>
<p>If a transaction must be locked or blocked, it is given this statement number as target; when it is reactivated, it will continue its activity at the statement whose number this is. Normally, that would be the call to ALLOC that originally caused the transaction to be locked.</p>
<p>LINE Storage address</p>
<p>In this parameter, ALLOC passes the address of the first location of the segment it assigns back to the caller.</p>
<p>LOCK Lock flag</p>
<p>The lock flag specifies whether the transaction should be locked immediately when it first arrives at the storage, or whether it should try to acquire its space. LOCK s 0 The transaction should try to acquire its space.</p>
<p>LOCK = 1 The transaction should be locked immediately when it first arrives.</p>
<p>41005&nbsp;Locking exit</p>
<p>If there is not space enough for the transaction, it must be locked. Then flow management must receive control again, whence statement number 1005 is always specified here. The exit is also taken when a new arrival is to be given a chance to get its space: the transaction is blocked first (see notes).</p>
<p>41006&nbsp;Error exit</p>
<p>If NST specifies a non-addressible storage, subroutine STRATA prints an error message. Then ALLOC takes this exit to termination.</p>
<p>1PRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT ? 0.</p>
<p>Data area:</p>
<p>ALLOC uses the activation list, the TX matrix and the areas COMMON/STO/ and COMMON/SBV/.</p>
<p><a name="bookmark331"></a>Algorithm description:</p>
<p><a name="bookmark332"></a>&quot;Determine the station number&quot;</p>
<p><a name="bookmark333"></a>K s &quot;EMFAC&quot; ♦ NST</p>
<p><a name="bookmark334"></a>The station number K is computed from the type number NST.</p>
<p><a name="bookmark335"></a>&quot;Watchdog&quot;</p>
<p>IF(OK.EQ.O) GOTO 50 OK s 0</p>
<p>IF(NE.LE.O) RETURN</p>
<p>ALLOC recognizes by means of OK, whether a transaction is requesting space for the first time, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated. If the transaction is arriving for the first time, it is sent to &quot;First acquisition attempt&quot;.</p>
<p>&quot;Storage-space assignment by the strategy&quot;</p>
<p>CALL STRATA(NST,NE,&amp;70) IF(LSH.EQ.O) GOTO 60</p>
<p>The strategy responsible for this storage finds a segment to allocate; it is called by means of the call to STRATA (see 6.5.1). The strategy sets the value of the system variable, LSM, which is in the area COMMON/SBV/, with the line number of the first location in the segment it assigns, or zero, if it cannot assign any space.</p>
<p>If NST specifies a non-addressible storage, STRATA takes an addressed exit to statement &amp;70, the section labelled &quot;Storage error&quot;. If no space could be assigned, the program jumps to &quot;Lock&quot;; otherwise, execution continues with the section below.</p>
<p>&quot;Set the segment matrix&quot;</p>
<p>IF(SM(LSM,1).NE.O) GOTO 30 DO 100 1=1, &quot;SM1&quot; J = LSM - I</p>
<p>IF(SM(J, U.NE.0) GOTO 20 100 CONTINUE</p>
<p>20 SM(LSM,1) = SM(J,1) - I SM(J,1) s I</p>
<p>It is possible for a particular a-strategy to assign a segment from the middle of a free segment, so that free remainders are left both ahead of and behind the allocated segment. Here ALLOC finds the beginning of the free segment from which the assignment was made, which may coincide with the start of the assigned seg-</p>
<p><a name="bookmark336"></a>ment. If there is a residual free one<sub>9</sub> it is marked free*</p>
<p>30 IF(SM(LSM<sub>f</sub> D.EQ.NE) GOTO U0 J s LSM + ME</p>
<p>SM(J<sub>9</sub>1) = SM(LSM, 1) - NE SM(J,2) = - 1</p>
<p><a name="bookmark337"></a>Then the residual free segment marked, assuming there is one.</p><div>
<p>segment ahead of&quot; the assigned</p></div><div>
<p>at the end of the assignment is</p></div>
<p><a name="bookmark338"></a>40 SM(LSM,1) s NE</p>
<p>SM(LSM,2) s MARK</p>
<p>ST0(NST,1) s ST0(NST,1) ♦ NE</p>
<p>TX(LTX<sub>f</sub>8) = 0</p>
<p>LINE s LSM - SBV(NST) ♦ 1</p>
<p>RETURN</p>
<p>ALLOC marks the segment with its length and the user's code. Then it raises the content counter by the number of spaces acquired. In case the transaction comes from the queue, its locking time is cleared. Finally ALLOC sets the LINE parameter to show the starting address of the segment acquired.</p>
<p>&quot;First acquisition attempt&quot;</p>
<p>50 IF(HE.LE.O) RETURN</p>
<p>IF(LOCK.GT.O) GOTO 60 AL(LTX<sub>9</sub>1 ) = ID AL(LTX,2) = - К TX(LTX,8) = T RETURN 1</p>
<p>If a transaction is arriving at a storage for the first time, it can choose to be locked immediately, or to try its luck at getting its required space. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock&quot;.</p>
<p>If LOCK is 0, the transaction is given a chance to acquire its required storage. But first, it competes for that space with any transactions that have just been started (see notes for subroutine ENTER): it is thrown in among the started transactions, if there are any, by being blocked (not locked) and placed in the queue.</p>
<p>Now, since storages are not directly under transaction management's supervision, they are always marked free. ACTIV2 thus finds the station free with at least one blocked transaction waiting; it begins undertaking conditioned activations, activating the blocked transactions at the station, one after the other, until all of them (which may be just the new arrival) have either acquired space or been relocked. This time, when the new arrival is activated, it is routed to the &quot;Storage-space assignment&quot; section, since it has been in the queue (0K=1).</p>
<p>&quot;Lock&quot;</p>
<p>60 AL(LTX,1) s ID</p>
<p>AL(LTX <sub>f</sub> 2) r - <sup>W</sup>KEND&quot; - K IF(TX(LTX<sub>f</sub>8)•EO.O) TX(LTX<sub>f</sub>8) s T RETURN 1</p>
<p>A transaction executes this section, if its storage request isn't satisfiable, or if it is required to be locked immediately when it first arrives. A lock code is set in its activation-list entry.</p>
<p>&quot;Storage error&quot;</p>
<p>70 RETURN 2 END</p>
<p>If NST denotes a non-addressible storage, ALLOC takes the error exit, cutting off simulation.</p>
<p>Notes:</p>
<p>*&nbsp;The notes for subroutine ENTER apply, with appropriate modification, to subroutine ALLOC.</p>
<p>*&nbsp;Addressible storages are distinguished from non-addressible by having an entry in the STRAMA matrix, which specifies at least an a-strategy for the storage. The user must specify, for each storage, which strategies are responsible for its management (see 2.6.1 and 6.5.1).</p>
<p><sup>§</sup> The segment's code, MARK, could be U3ed to give an f-strategy a selection criterion. It could, for example, specify the allocation time or the acquiring transaction's identifying number (from TX(LTX, 1)) or similar information. If the user need not code his entries in the storage, he can specify any value at all for MARK.</p>
<p><sup>*</sup>&nbsp;Each occupied segment is uniquely identified by its storage number and its starting address in that storage. It is not uniquely identified by its starting address (LINE) alone, unless there is only one storage.</p>
<p>*&nbsp;If storage locations are always occupied one at a time, all of the segments will be of length 1. This special case is, of course, handled automatically by the algorithm for the more general case.</p>
<p>6.4.3 FREE Purpose :</p>
<p><sup>p</sup>REE frees a specified number of spaces from a specified segment in a storage. Since FREE processes only addressible storages, bookkeeping is involved in the operation. If the transaction tries, to free more spaces than are in the segment specified, a special exit is taken to give the user the opportunity to take any special actions.</p>
<p><a name="bookmark339"></a>Calling sequence</p>
<p><a name="bookmark340"></a>CALL FREE (NST, NB, KEY <sub>9</sub> LIKE, EXIT1, &amp;1006,IPRINT) Parameters:</p>
<p><a name="bookmark341"></a>The parameters whose descriptions differ essentially from those of subroutine LEAVE are: KEY<sub>f</sub> LINE and &amp;1006.</p>
<p>Storage number (Type number)</p>
<p>Storages are numbered sequentially. NST specifies from which storage the space is to be freed; it must specify an addressible storage. Number or elements to be freed</p>
<p>The number of storage spaces to be freed is given. Freeing key</p>
<p>The key specifies from which segment the space is to be freed. It is used differently in storages with and without f-strategies. In storages without, there is no need for a strategy * hat decides which locations to free; KEY specifies the beginning address of the segment in which space is to be freed. The area freed is from KEY to KEY+NE-1. In storages with f-strategies, KEY* means nothing at all to subroutine FREE; it is merely passed along to the f-strategy, which uses it, in any way deemed fit, to find a segment from which FREE frees the first NE locations. Remainder address</p>
<p>If the segment is longer than NE spaces, FREE divides it into two: the first free and the remainder still occupied. The starting address of the remainder is returned to the caller in LINE. Aborted-freeing exit</p>
<p>When a transaction tries to free more space than the segment identified by KEY contains, this exit is taken. The exit is also taken when the f-strategy (assuming there is one) cannot find a segment identified by the KEY parameter. Error exit</p>
<p>This exit is taken when NST specifies a non-addressible storage. In that case, simulation is terminated. Trace flag*</p>
<p>Trace printouts are suppressed when IPRINT = 0.</p><div>
<p>NST</p>
<p>NE KEY</p></div><div>
<p>LINE</p>
<p>EXIT1</p></div><div>
<p>&amp;1006</p>
<p>IPRINT</p></div>
<p>Data area:&nbsp;.</p>
<p>FREE uses the areas C0MM0N/ST0/, COMMON/SBV/ and C0MM0N/STR/</p>
<p>Algorithm description:</p>
<p>&quot;Determine LSM&quot;</p>
<p>IF(STRAMA(HST,1)•EQ.0) GOTO 50 LStt s KEY ♦ SBV(NST) - 1</p>
<p>IF(STRAMA(NST,2).NE.O) CALL STRATF(NST,KEY,4 1 ) IF(LSM.EQ.O) GOTO 40</p>
<p>The variable LSM specifies the starting location of the area to be freed. If the storage has no f-strategy, LSH is computed directly from the value of KEY. If the storage has an f-atrategy (see 6.5.1), FREE calls it. The strategy sets the value of LSM, which is in COHHON/SBV/. If LSH has been set to zero, no area could be found. In this case, or in case the storage is non-ad-dressible, FREE jumps to the addressed-exit section.</p>
<p>&quot;Mark remainder&quot;</p>
<p>LINE x 0</p>
<p>IF(SM(LSM, D.LT.NE) GOTO 40 IF(SH(LSM,1).EQ.NE) GOTO 10 J = LSH + NE</p>
<p>SM(J,1) = SM(LSM,1) - NE SM(J,2) = SM(LSM,2) LINE = J - SBV(NST) ♦ 1 SM(LSM,1) s NE</p>
<p>If the segment is longer than ME spaces, FREE divides it into two: the first free and the remainder still occupied. The free segment is always built from the first part of the original and the remainder from the last part. The starting address of the remainder is returned to the caller in LINE.</p>
<p>&quot;Free the storage area<sup>11</sup></p>
<p>10 SM(LSM,2) = -1</p>
<p>ST0(NST,1) = ST0(NST,1) - NE</p>
<p>The freed area is marked free and the total storage content is decremented by the number of freed locations.</p>
<p>&quot;Lump contiguous free segments into one segment*<sup>1</sup></p>
<p>J = LSM ♦ SM(LSM,1)</p>
<p>IF(SM(J,2).NE.-1.0R.J.GE.SBV(NST)+ST0(NST,2)) GOTO 20 SM(LSM,1) r SM(LSM,1) ♦ SM(J,1) SM(J,1) = 0 SM(J,2) = 0 20 IF(LSM.EQ.SBV(NST)) RETURN DO 100 1=1, &quot;SMI&quot; J = LSM - I</p>
<p>IF(SM(J,1).NE.0) GOTO 30 100 CONTINUE</p>
<p>30 IF(SM(J,2).NE.-1) RETURN SM(J,1) = SM(LSM,1) ♦ I SM(LSM,1) = 0 SM(LSM,2) = 0 RETURN</p>
<p>The freeing^ of an area can yield two or even three contiguous free segments, which should be concatenated into one long segment. The algorithm insures that, if they occur, contiguous free segments fore and aft are both swallowed into the new segment.</p>
<p>&quot;Special exits<sup>19</sup></p>
<p>40 BETURN 1 50 BETURN 2 EXD</p>
<p>The appropriate special exits are taken: EXIT1<sub>f</sub> if the trans* action tried to free more space than is currently occupied; 41006, if the storage is non-addressible.</p>
<p>Notes:</p>
<p>•&nbsp;For storages without an f-strategy, KEY must specify the beginning address of the segment to be freed. Subroutine ALLOC passed this address back to the user in the LINE parameter, when it allocated the space.</p>
<p>•&nbsp;An f-strategy could use KEY to identify the segment from which space is to be freed. It could, for example, take the first segment where KEY matches the segment code set by ALLOC's MARK parameter.</p>
<p>•&nbsp;«hen only part of a segment is to be freed, FREE always frees the first part; it is incapable of freeing a chunk from the middle of a segment. If such freeings are needed in a particular model, the user must write the program for them himself.</p>
<p>u</p>
<p><sup>11</sup> The note for subroutine LEAVE (see 6.2.2) concerning the abort exit applies here too.</p>
<p>6.5 GPSS-F Strategies</p>
<p>GPSS—F knows both addressible and non-addressible storages. Only the former need strategies, since no account is kept for the latter of filled locations. Addressible storages need at least an a-strategy and in addition<sub>9</sub> an f-strategy, if freeing requests do not specify locations unambiguously (see 6.3*7).</p>
<p>Each addressible storage must be assigned an allocation strategy and, if need be, a freeing strategy. Since strategies are especially problem-dependent, the user has the opportunity to write his own. These can be added easily to GPSS-F. Two pre-written allocation strategies are provided: first-fit and best-fit.</p>
<p>6.5-1 STRATA and STRATF Purpose :</p>
<p>STRATA and STRATF select the strategy that decides, for a given storage, which locations are to be acquired or freed. GPSS-F provides for up to five different a-strategies and f-strategies. Furthermore, two allocation strategies are already pre-program-med: r FIT (first-fit) and BFIT (best-fit).</p>
<p><a name="bookmark342"></a>In the following documentation, only STRATA la described* STRATF is similar.</p>
<p><a name="bookmark343"></a>Calling sequence:</p>
<p>CALL STRATA (NST,NE,EXIT1)</p>
<p><a name="bookmark344"></a>Parameters:</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>The number of the storage whose strategy is to be selected•</p>
<p>NE&nbsp;Number of locations requested</p>
<p>The number of storage locations being requested is specified. EXIT1 Strategy-error exit</p>
<p>If no strategy is provided for this storage, then STRATA returns via this exit to the calling program, which should, in turn exit to simulator termination.</p>
<p>Data area:</p>
<p>STRATA and STRATF use the strategy matrix, STRAMA. Each storage, whether addressible or not, has a line in this matrix, which may specify an a-strategy and, if need be, an f-strategy for that storage. If there is neither an a-strategy nor and f-strategy for the storage numbered NST, it is non-addressible; if there is only an a-strategy<sub>f</sub> it is addressible, but freeing requests are always specified unambiguously. The STRAMA matrix is defined as follows:</p>
<p>INTEGER STRAMA DIMENSION STRAMA(&quot;ST01&quot;,2)</p>
<p>The individual elements have the following meanings:</p>
<p>STRAMA(NST,1) A-strategy</p>
<p>Each strategy is denoted by a number. The user enters that number in the matrix in section 4 of the chassis. In this manner, he assigns each addressible storage a specific a-strategy.</p>
<p>STRAMA(NST,2) F-strategy</p>
<p>In the same way, the user assigns an f-strategy to each storage that needs it.</p>
<p>Algorithm description:</p>
<p>&quot;Find the strategy&quot;</p>
<p>Ir(STRAMA(NST,1&quot;) . NE • 0 ) GOTO 100 RETURN 1 100 IADDR = STRAMA(NST,1)</p>
<p>GOTO (1,2,3,4,5) • IADDR</p>
<p>The storage's strategy is found in the strategy matrix and the appropriate call is jumped to.</p>
<table border="1">
<tr><td>
<p>•Call</p></td><td>
<p>the STRAA subroutine</p></td></tr>
<tr><td>
<p>1</p></td><td>
<p>CALL FFIT(MST.NE)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>2</p></td><td>
<p>CALL BFIT(NST.NE)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>3</p></td><td>
<p>CALL STRAA3(NST,NE)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>|</p></td><td>
<p>CALL STRAA4(NST,NE)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p>5</p></td><td>
<p>CALL STRAA5(NST,NE)</p></td></tr>
<tr><td>
<p></p></td><td>
<p>RETURN</p></td></tr>
<tr><td>
<p></p></td><td>
<p>END</p></td></tr>
</table>
<p>The subroutine provides for five different strategies. The a-strategies whose numbers are 1 and 2 are already assigned to the pre-programmed strategies, FFIT and B^IT.</p>
<p>Notes:</p>
<p>• If the user writes a strategy, he gives it a number and a Fortran name. Then he enters its number in the appropriate lines in the strategy matrix and its name in the appropriate CALL statements in STRATA and STRATF.</p>
<p>6.5.2 FFIT Purpose:</p>
<p>This subroutine searches free space according to the first-fit strategy.</p>
<p>Calling sequence:</p>
<p>CALL FFIT (NST,NE)</p>
<p>Parameters:</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>The storage number is used to find the section of the segment matrix belonging to the storage. NE&nbsp;Number of elements to be acquired</p>
<p>The first free segment that can accomodate a request for NE locations is found.</p>
<p>Data area:</p>
<p>FFIT uses the areas COMMON/SBV/ and COMMON/STO/. Algorithm description: &quot;Initialize the search&quot;</p>
<p>LSM r 0 I s SBV(NST)</p>
<p>IB « I ♦ STO(NST,2) - 1</p>
<p>The program searches only that section of the segment matrix belonging to the storage numbered NST.</p>
<p>&quot;Find a segment&quot;</p>
<p>10 IF(SM(I,2).NE.-1 ) GOTO 20 IF(SM(I,1).GE.NE) GOTO 30 20 I s I ♦ SH(I,1)</p>
<p>IF(I.LE.TE) GOTO 10 RETURN 30 LSM = I RETURN END</p>
<p>Among the segments marked free (—1), we find the first that Is at least NE locations long. The system variable, LSM, is set to the beginning address of this segment, or zero, if there is none.</p>
<p>6.5.3 BFIT Purpose:</p>
<p>This subroutine searches free space according to the best-fit strategy.</p>
<p>Calling sequence:</p>
<p>CALL BFIT (NST,NE)</p>
<p>Parameters:</p>
<p>NST&nbsp;Storage number (Type number)</p>
<p>The storage number is used to find the section of the segment matrix belonging to the storage. NE&nbsp;Number of elements to be acquired</p>
<p>The free segment is found that can best accomodate a request for NE locations.</p>
<p>Data area:</p>
<p>BFIT uses the areas C0MM0N/SBV/ and C0MM0N/ST0/. 1 &quot; ' &gt; \ ,&quot; . ■</p>
<p>Algorithm description: •'Initialize the search&quot;</p>
<p>1</p>
<p>LSM = 0</p>
<p>D r ST0(NST,2)</p>
<p>I r SBV(NST)</p>
<p>IE s I + ST0(NST,2) - 1</p>
<p>, The program searches only that section of the segment matrix belonging to the storage numbered NST.</p><img src="Untitled.FR10_files/Untitled.FR10-9.jpg" style="width:118pt;height:131pt;"/>
<p>&quot;Find a segment&quot;</p>
<p>10 IF(SM(I,2).NE.-1) GOTO 20 1F(SM(I,1).LT.NE) GOTO 20 IF(SM(I, U-NE.GE.D) GOTO 20 D * SM(I,1) - NE LSM s I 20 I s I ♦ SM(I,1)</p>
<p>IF(I.LE.IE) GOTO 10</p>
<p>RETURN</p>
<p>END</p>
<p>Among the segments marked free (-1), all those are found that are at least NE locations long. Then, among those, the one is found whose allocation would leave the least remainder, D. The system variable, LSM, is set to the beginning address of this segment, or zero, if there is none.</p>
<p>COORDINATING</p><div>
<p>7</p></div><div>
<p>TRANSACTIONS</p></div>
<p>The two mechanisms 'Branch on Condition' and 'Wait on Condition' suffice to coordinate the movement of tasks through a discrete system. One speaks of 'branching on condition', at points where a task can be sent through one of various processing paths, depending on the system's state. 'Waiting on condition' means that tasks are held at some point, until the system's state changes to meet specific conditions.</p>
<p>In GPSS-F, tasks can branch or wait at any point in the model. The user specifies the condition under which branching or waiting occurs by means of a logical expression.</p>
<p>7.1 Branching on Condition</p>
<p>We shall distinguish two kinds of branching: the first, deterministic, by reason of the system state; the second, stochastic, by reason of a random variable.</p>
<p>Examples:</p>
<p>*&nbsp;In a pariticular model, if there are already ten transactions waiting at a station, no more are accepted into the queue. The rerouting of transactions is deterministic and occurs only when the system fulfils specific criteria. Each arriving transaction can test the criteria to see whether they are fulfilled; the answer determines its subsequent path through the model.</p>
<p>*&nbsp;In an assembly line, eight from every thousand items are found defective and sent back for repairs. The rerouting occurs stochastically. The probability that an item will be sent to the repair station is 0.008.</p>
<p>7.1.1 Deterministic Branching</p>
<p>No subroutine is needed to effect a branch by reason of the system state. Such branching is easily implemented using a Fortran logical IF statement. The statement has the following form:</p>
<p>IF(logexp) command,</p>
<p>where 'logexp' is a logical expression and 'command' is a Fortran command, such as ' a GOTO. If the logical expression's value is .TRUE., the command is executed. To implement a deterministic branch, the user would code a logical IF statement whose expression tests the system state and whose command jumps to the part of the program to be executed when the state obtains.</p>
<p>7.1.2 Stochastic Branching: TRANSF Purpose:</p>
<p>From among the transactions that call subroutine TRANSF, some are picked at random to be sent to a specified statement in the model. The remainder continue their activity with the statement following the call to TRANSF.</p>
<p>Calling sequence:</p>
<p>CALL TRANSF (RATIO,EXIT1,RNUM,IPRINT)</p>
<p>Parameters:</p>
<p>RATIO Selection probability</p>
<p>This parameter specifies the probability with which transactions are sent to the statement number given by the parameter EXIT1. RATIO must be a real number between 0 and 1.</p>
<p>EXIT1 Exit for the selected transactions</p>
<p>The selected transactions continue their^activity at this statement number.</p>
<p>RNUM Random number generator's identifier</p>
<p>This parameter specifies which random number generator shall be used to decide whether the transaction is to be selected (see chapter 9).</p>
<p>IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>TRANSF requires only the random number generated by the random number generator RNUM.</p>
<p>Algorithm description :</p>
<p>Z = RN(RNUM)</p>
<p>IF(Z.LE.RATIO.AND.RATIO.GT.O) GOTO 100 RETURN 100 RETURN 1 END</p>
<p>The function, RN (see 9.4.1), generates a random number between 0 and 1, which is set in the variable Z. If Z is less than RATIO, the transaction is selected, i.e. the addressed exit is taken. Otherwise, TRANSF returns to the statement following the call.</p>
<p>7.2 Waiting on Condition</p>
<p>GPSS-F provides stations, called gates, at which transactions wait until the system is in a specified state. The state that determines whether transactions are to wait at the gate is described in a logical expression. We shall say that the expression</p>
<p>represents the gate's wait condition: when the condition obtains, a transaction can proceed; otherwise, it must wait. A gate is said to be op^n or closed, according as it lets a transaction pass or not.</p>
<p>From time to time, a waiting transaction tries the gate again to see if it is now open. If the expression's value has become .TRUE., it proceeds; otherwise it waits and tries again later.</p><div>
<p>; they do not have ac-ion leaves the sta-the expression to see</p></div>
<p>7.2.1 Trying the Gate</p>
<p>There are two procedures for deciding when waiting transactions shall try the gate again: either the user supervises the gates by specifying when they should be retried, or flow management supervises their retrial automatically. Gates subject to the user's supervision are of type 1; those supervised by flow management are of type 2.</p>
<p>Waiting transactions should retry their gates each time the system's state changes in some way that could affect the value of the gate's expression. The points in the model at which it makes sense to let waiting transactions retry a gate are usually made clear by the model's design. If so, the user can supervise the gate himself: each time the system's state changes in any way relevant to the gate, he can call for it to be retried. Here, he would use a type-1 gate.</p>
<p>Transactions waiting at a type-1 gate wait normally in the locked state, not in the blocked state (see 2.2.2). Locked transactions do not have access to their gates; they must be placed in the blocked state by means of a call to UNLOCK (see 2.5.3) before flow management can activate them to try the gate. The user calls for a gate's retrial by such a call to UNLOCK, called a start, specifying the gate he wants retried. The transactions locked at the gate are thereby blocked.</p>
<p>As a result of the start, the blocked transactions are activated, one after the other, in the order determined by the gate's policy. Each tries the gate in its turn. Transactions for which the gate is closed are relocked and placed back in the queue to wait for the next start.</p>
<p>Example:</p>
<p>* In a certain model, some transactions arrive at a facility via one path and others via a second. That would occur when they all acquire the facility using the same CALL SEIZE statement, but arrive at the CALL from different parts of the program. In our model, transactions arriving via the second path are to be held at a type-1 gate, unless the station's queue is empty.</p>
<p>In GPSS-F, the contents of queues can be tested by use of the BIN matrix (see 10.1), so our gate's logical expression would be:</p>
<p>BIN(NBN,1).EQ.O</p>
<p>Normally, waiting transactions are locked cess to the gate. But each time a transact tion's queue, it makes sense to re-evaluate whether Its value has changed. That Is accomplished by means of a start: locked transactions are given access to the gate by being blocked. Flow management vill then activate a blocked transaction which tries the gate.</p>
<p>%</p>
<p>The user can supervise his gates in most situations, especially where only a small number of system changes can affect the value of the gate's expression. But if a gate's expression is complex, state changes abound that could alter its value to .TRUE.. It may be easier or more comfortable, under the circumstances, to let GPSS-F supervise the gate. Here, a type-2 gate would be used.</p>
<p>When GPSS-F supervises a gate, it is tried nearly every time flow management receives control: ACTIV2 lets a waiting transaction try the gate each time it is called, assuming some state change has taken place since the last time it was called. Transactions waiting at a type-2 gate always wait in the blocked state. The gate is sometimes accessible to blocked transactions, sometimes not: ACTIV2 switches its state back and forth by juggling its entry in the state vector (see 3.4).</p>
<p>7.2.2 Local and Global Parameters</p>
<p>The system's state is given by the values of its parameters, private and relational. A gate's expression will contain variables referring to one or more parameters, so that its value, .TRUE, or .FALSE., depends on the current parameter values.</p>
<p>Parameters pertaining to the transaction trying the gate shall be called local; those not pertaining to it, global. Obviously, given a particular systea state, an expression that tests only global parameters will have the same value, no matter which transaction tries the gate, and an expression that tests any local parameter could have different values for different transactions trying the gate. Global parameters are those pertaining to other transactions or to stations or to the relation between any two or more system components, excluding the transaction trying the gate.</p>
<p>At a gate whose logical expression tests any local parameter, each waiting transaction should try the gate each time the relevant parameters change. The gate could be open to some transactions and closed to others.</p>
<p>The situation is different at gates whose logical expression contains only global parameters. When a transaction finds the gate closed, it makes no sense to let other waiting transactions try it until the relevant parameters have changed. For a given system state, if such a gate is closed to one, it will be closed to all. If the gate is open, though, waiting transactions can try it, one after the other, until they are all gone, or until the gate closes.</p>
<p>Examples :</p>
<p>* When the gate is down at a railroad crossing, arriving cars must wait. In a GPSS-F model, the gate's logical expression would</p>
<p>be the Fortran equivalent of: there is no train.^ The expression tests one global parameter, the train's approach or presence at the crossing. If the gate is down, it bars all waiting cars from proceeding; if it is up<sub>9</sub> waiting cars can proceed, one by one, until they are all gone, or until the gate recloses.</p>
<p>* Transactions arriving at a storage must wait until there is room for then (see chapter 6). If we think of the storage as a gate, its logical expression would be: there is room enough to accomodate the requesting transaction. The expression's value depends on two parameters, namely the transaction's request for space (a local parameter) and the availability of so much space in the storage (a global parameter). Thus each waiting transaction must try the gate each time storage space is freed, since the expression could be true for some transactions, but not for others. At * a storage, the loading strategy takes the place of a logical expression.</p>
<p>7.3 Gates</p>
<p>GPSS-F provides both types of gates. To try a type-1 gate, the active transaction calls GATE1; to try a type-2 gate, GATE2.</p>
<p>7.3.1 GATE1 Purpose:</p>
<p>When a transaction calls GATE1, the subroutine evaluates a specified logical expression. If its value is .FALSE., the transaction is locked and placed in the gate's queue; GATE1 returns to flow management. If the expression's value is .TRUE., the transaction remains active and GATE1 returns to the statement following the call.</p>
<p>For arriving transactions, the user can specify whether the gate is accessible for an initial trial. If so, the arriving transaction tries the gate immediately; otherwise, it is locked and placed in the queue. The gate is under initiated supervision, i.e. waiting transactions gain access to it each time the user calls UNLOCK for this gate.</p>
<p>For waiting transactions, the user can specify whether the gate's expression depends on local parameters. If so, each waiting transaction is given a chance to to try the gate, regardless whether the gate is open or closed to the others. Otherwise, waiting transactions try the gate until one of them finds it closed; then the remaining transactions are relocked to wait for the next start.</p>
<p>Calling sequence:</p>
<p>CALL GATE1 (LOGEXP,GLOBAL,NGATE,ID,LOCK,h 1005,1PRINT)</p>
<p>Parameters:</p>
<p>LOGEXP Wait condition</p>
<p>The logical expression is evaluated. If its value is .TRUE., the active transaction remains active and GATE1 returns to the statement following the call: the gate is open. If the expression's value is .FALSE., the transaction is locked.</p>
<p>GLOBAL Parameter code</p>
<p>This parameter specifies whether all waiting transactions should try the gate, one by one, or only until one of them finds the gate closed.</p>
<p>GLOBAL = 0 The logical expression contains local parameters. Every waiting transaction should try the gate.</p>
<p>GLOBAL s 1 The logical expression contains only global parameters.</p>
<p>NGATE Type-1 gate number (Type number)</p>
<p>Type-1 gates are numbered sequentially.</p>
<p>ID&nbsp;GATE1 CALL'S statement number</p>
<p>If a transaction must be locked or blocked, it is given this statement number as target; when it is re-activated to try the gate again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATE1 that originally caused the transaction to be locked.</p>
<p>LOCK Lock flag</p>
<p>The lock flag specifies whether the transaction should be locked immediately when it first arrives at the gate or whether it should try the gate. LOCK s 0 The transaction should try the gate. LOCK = 1 The transaction should be locked immediately when it first arrives.</p>
<p>&amp;1005 Locking and blocking exit</p>
<p>If the transaction is locked or blocked, flow management must be called; hence statement number 1005 should always be specified here.</p>
<p>IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>GATE1 uses the activation list and the TX matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Determine the station number&quot; K s &quot;ESTO&quot; ♦ NGATE The station number K is computed from the type number NGATE.</p>
<p>&quot;Watchdog&quot;</p>
<p>IF(OK.EQ.O) GOTO 10 OK S o</p>
<p>queue to be activated. If the transaction is arriving for the first time<sub>9</sub> it is sent to &quot;Mew arrival&quot;.</p>
<p>&quot;Locking decision&quot;</p>
<p>IF(.NOT.LOGEXP) GOTO 20</p>
<p>TX(LTX<sub>t</sub>8) s 0</p>
<p>RETURN</p>
<p>If the transaction isn't a new arrival, and if the expression's value is .TRUE., the transaction is to be allowed to pass.</p>
<p>&quot;New arrival&quot;</p>
<p>10 IF(LOCK.GT.O) GOTO 30 AL(LTX,1) s ID AL(LTX,2) * - K TX(LTX,8) s T RETURN 1</p>
<p>A new arrival can choose to be locked immediately, or to try the gate. If LOCK is 1, the transaction is to be locked immediately; the program jumps to &quot;Lock the active transaction&quot;.</p>
<p>If LOCK is 0, the transaction is given a chance to try the gate. But first, it competes with any transactions that have just been started (see notes): it is thrown in among the started transactions, if there are any, by being blocked (not locked) and placed in the queue. Then GATE1 returns control to flow management .</p>
<p>Now, since gates are not directly under transaction management's supervision, they are always marked accessible in the STATE vector. ACTIV2 thus finds the station accessible with at least one blocked transaction waiting. It undertakes a conditioned activation, activating one of the transactions blocked at the station, which may include only the new arrival. This time, the new arrival executes the &quot;Locking decision&quot; section, since it has been in the queue (0Ks1).</p>
<p>4ft</p>
<p>&quot;Test the parameter code&quot; 20 IF(GLOBAL.GT.O) GOTO 40</p>
<p>The user initiates the testing of a gate by starting the locked transactions waiting there. ACTIV2 finds them blocked at the gate and activates the one selected by the gate's policy. The activated transaction's target is the CALL GATE1 statement, which evaluates the logical expression to decide whether the transaction should pass or not.</p>
<p>Now if the expression's value depends only on global parameters, and if the gate is closed, then all of the started transactions are to be relocked immediately in the section &quot;Lock all started transactions&quot;. If, however, the expression's value depends on local parameters, just the one transaction Is relocked In the following section*</p>
<p>&quot;Lock the active transaction&quot;</p>
<p>%</p>
<p>30 AL(LTX,1) s ID</p>
<p>AL(LTX,2) s - &quot;KEND&quot; - K IF(TX(LTX,8).EQ.O) TX(LTX,8) s T RETURN 1</p>
<p>A transaction is locked by giving it a lock code, -&quot;KEND&quot;-K.</p>
<p>It can try the gate again only by being started.</p>
<p>&quot;Lock all started transactions&quot;</p>
<p>40 AL(LTX,1) s ID</p>
<p>AL(LTX,2) = - &quot;KEND&quot; - K IF(TX(LTX,8).EQ.O) TX(LTX,8) s T DO 100 I s 1 <sub>f</sub> LAL</p>
<p>IF(AL(I,2).EQ.-K) AL(I,2) r - &quot;KEND&quot; - K</p>
<p>100 CONTINUE RETURN 1 END</p>
<p>This section is executed when the transaction must be relocked and when the value of the gate's expression depends only on global parameters. When that is the case, the above loop relocks all other started transactions as well. The initiated trial of the gate is over.</p>
<p>Notes:</p>
<p>•&nbsp;If GLOBAL r 1, type-1 gates behave exactly like type-2 gates, except that they are under the user's supervision: locked transactions must be started by calling UNLOCK. Started transactions try the gate one by one until one of them finds it closed. Then any remaining blocked transactions are relocked to wait for the next start.</p>
<p>*&nbsp;When the user calls UNLOCK, he must specify the gate's station number. He can calculate the station number from the type number, NGATE, by considering the state vector's construction (see appendix A2).</p>
<p><sup>9</sup> Storages behave like type-1 gates with GLOBAL = 0, whose logical expression is: space is available to fill a given request. In this sense, there is a close parallelism between subroutines ALLOC and GATE1.</p>
<p>When a newly arriving transaction is to be permitted to try the gate, it usually calls GATE1 twice in a row. The first time, it is blocked and GATE1 returns control to flow management. Flow management takes no special notice of what has happened, but it finds (at least) the new arrival blocked at the gate. Since gates are always accessible to blocked transactions, the transaction selected by the gate's policy is activated and calls GATE1. The</p>
<p>first call to GATB1 merely creates a situation in which the new arrival is given a chance to try the gate by means of a second call to GATE1.</p>
<p>The new arrival doesn't get its chance to try the gate If GLOBAL s 1 and the policy selects a blocked transaction ahead of it that happens to close the gate.</p>
<p>7.3.2 GATE2</p>
<p>Purpose:</p>
<p>When a transaction calls GATE2<sub>t</sub> the subroutine evaluates a specified logical expression. If its value is .FALSE., the transaction is locked; GATE2 returns control to flow management. If the expression's value is .TRUE., the transaction remains active and GATE2 returns to the statement following the call.</p>
<p>The gate is under automatic supervision, i.e. waiting transactions try the gate each time ACTIV2 receives control. Waiting transactions try the gate one by one until one of them fails to pass; then the gate is inaccessible again until the next time ACTIV2 receives control.</p>
<p>Calling sequence:</p>
<p>CALL GATE2 (LOGEXP,NGATE,ID,&amp;1005<sub>f</sub>IPRINT) Parameters:</p>
<p>Wait condition</p>
<p>The logical expression is evaluated. If its value is .TRUE., the active transaction remains active and GATE2 returns to the statement following the call: the transaction has been allowed to pass. If the expression's value is .FALSE.<sub>t</sub> the transaction is blocked. Type-2 gate number (Type number) Type-2 gates are numbered sequentially. GATE2 CALL's statement number</p><div>
<p>LOGEXP</p></div><div>
<p>NGATE ID</p></div>
<p>If a transaction must be blocked</p>
<p>is given this statement number as target; when it is re-activated to try the gate again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATE2 that originally caused the transaction to be blocked. Blocking exit</p>
<p>If the transaction is blocked, flow management must called; hence statement number 1005 should always specified here. Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p><div>
<p>it</p></div><div>
<p>41005</p></div><div>
<p>be be</p></div><div>
<p>IPRINT</p></div>
<p>Data area</p>
<p>CATE2 uses the activation list and the TX matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Determine the station number&quot;</p>
<p>К « &quot;EGATE&quot; ♦ NGATE&nbsp;<sup>%</sup></p>
<p>The station number К is computed from the type number NGATE.</p>
<p>&quot;Blocking decision&quot;</p>
<p>IF(OK.EQ.O) GOTO 250 OK * 0</p>
<p>IF(.NOT.LOGEXP) GOTO 200 100 TX(LTX,8) s 0 IT = 0 RETURN</p>
<p>GATE2 recognizes by means of OK, whether a transaction is just now trying the gate for the first time, or whether it has been in the queue: if OK is non-zero, ACTIV2 just selected it from the queue to be activated.</p>
<p>If the transaction is arriving for the first time,_it is always blocked immediately, before it tries the gate. If the transaction isn't a new arrival, and if the expression's value is •TRUE., the transaction is to be allowed to pass.</p>
<p>&quot;Mark the gate inaccessible&quot;</p>
<p>200 STATE(K) = 0</p>
<p>The gate, which ACTIV2 marked inaccessible (see notes and 2.3.3), is made accessible again, as soon as it has been tried and found closed. Note that this statement is not executed when the gate is open.</p>
<p>&quot;Block&quot;</p>
<p>250 AL(LTX,1) r ID AL(LTX,2) =1- К</p>
<p>IF(TX(LTX,8).EQ.0) TX(LTX,8) = T</p>
<p>RETURN 1</p>
<p>END</p>
<p>When a transaction finds the gate closed, it is blocked in the section above. The block time should be set only when the transaction is a new arrival, i.e. when it doesn't yet have a block time. If it was selected from the queue to try the gate, it will already have a block time, which it keeps.</p>
<p>Notes:</p>
<p>*&nbsp;GATE2 uses the same two-pass algorithm for newly arriving transactions already described in the notes to subroutine GATE1.</p>
<p>*&nbsp;Each type-2 gate has an element in the state vector, where it is marked accessible or inaccessible to blocked transactions. If</p>
<p>it Is inaccessible, the following holds: STATE(&quot;EGATE1&quot;*NGATE) s 0</p>
<p>Each time a transaction undertakes state changes and returns control to flow management, ACTIV2 marks the gates accessible in the loop:</p>
<p>DO 100 I s &quot;BGATE2&quot; , &quot;EGATE2<sup>M </sup>100 STATE(I) s 1</p>
<p>Then a transaction is activated to try each type-2 gate. If the transaction finds that the gate's expression comes out .TRUE., it remains active, undertakes further state changes and the gate remains accessible. Then another transaction waiting at the gate (if there is one) is activated and the procedure continues. The first transaction that cannot pass, because the expression's value now comes out .FALSE., marks the gate inaccessible to the rest by zeroing its state-vector element.</p>
<p>*&nbsp;This behaviour means that GATE2's algorithm takes no notice of the expression's dependence on local and global parameters: there is no provision for letting all waiting transactions try the gate, regardless of the success or failure of previous trials.</p>
<p>*&nbsp;Facilities exhibit behaviour in some respects similar to type-2 gates. A call to SEIZE is analogous to a call to GATE2 with the logical expression: the facility is available.</p>
<p>*&nbsp;The type-2 gates are tried each and every time an activated transaction completes its activity and returns control to flow management. Since they are tried so often, their use can be extremely time-consuming. This is the reason why they don't provide for a distinction between expressions depending on local and global parameters. Type-2 gate's should be used as sparingly as possible.</p>
<p>7.3-3 The IT Mechanism</p>
<p>If, after the system's state has changed, a waiting transaction tries a type-2 gate and finds it closed, it is reblocked. Then flow management regains control and marks all the type-2 gates accessible again. The transaction that just finished trying the gate could now be the first transaction selected for a conditioned activation, even though no state change has occurred in the meantime. The transaction would again call GATE2 and GPSS-F would go into an endless loop, were it not for the IT mechanism.</p>
<p>The system's variable, IT, prevents trial of the type-2 gates twice at the same clock time, if no state change has taken place since the last trial. The variable is initially zero. Bach time ACTIV2 marks the type-2 gates available, it sets the time, T, in IT. Then by means of the statement:</p>
<p>IF(IT.EQ.T) GOTO 200</p>
<p><a name="bookmark345"></a>ACTIV2 jumps around its gate-trial loop, If IT * T. Each time a subroutine changes the system state, It sets 17 » 0<sub>f</sub> so the gates can be tried again.</p>
<p>7*4 Cather Stations</p>
<p>By the use of gates, completely general wait conditions can be programmed into a model. There are, however, certain kinds of gates that are often used to build models, whose functions and logical expressions are fixed. GPSS-F offers three specialized gates: gather stations, user chains and trigger stations.</p>
<p>7.4.1 Coordinating Transactions in one Processing Path</p>
<p>The coordination task that occurs most frequently in one processing path in a model consists of letting transactions collect at a station until some specified number have arrived and then letting them proceed.</p>
<p>Examples:</p>
<p>*&nbsp;In a medieval castle, the kindly old lady politely refuses to conduct tours until at least ten tourists are assembled. The first nine tourists have to wait until there is a tenth.</p>
<p>*&nbsp;A firm's mail department doesn't distribute the mail until some quantity has arrived. Only then is the clerk sent around to deliver it.</p>
<p>Stations that collect transactions before letting them proceed are called gather stations. They are of two types, depending on whether they pay attention to the transactions' family membership (see chapter 8) or not. In this chapter, we shall only consider those that don't. They are said to be of type 2 and are handled by subroutine GATHR2.</p>
<p>7.4.2 GATHR2 Purpose:</p>
<p>Transactions calling subroutine GATHR2 are locked until a certain number, specified by the user, have arrived. When that has happened, the gather station is opened and the transactions proceed, one by one, until they are all gone. GATHR2 pays no attention to the transactions' family membership. GPSS-F supervises the gather station.</p>
<p>Calling sequence :</p>
<p>CALL GATHR2 (NG,NGATH,ID,&amp; 1005,IPRINT)</p>
<p>Parameters:</p>
<p>NG&nbsp;Number of transactions to collect</p>
<p>The number of transactions to be gathered is specified. NGATH Type-2 gather station number (Type number)</p>
<p>Type-2 gather stations are numbered sequentially. ID&nbsp;GATHR2 CALL<sup>#</sup>s statement number</p>
<p>*&nbsp;If a transaction must be blocked, it is given this</p>
<p>statement number as target; when it is re-activated to try the gather station again, it will continue its activity at the statement whose number this is. Normally, that would be the call to GATHR2 that originally caused the transaction to be locked. &amp;1005 Locking exit</p>
<p>If the transaction, is locked, flow management must be called; hence statement number 1005 should always be specified here. IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>GATHR2 uses the actuation list, the TX matrix and the state vector. Further, GATHR? needs a counter that specifies, for each gather station, how many transactions have already arrived. It is defined as follows:</p>
<p>INTEGER GATHT DIMENSION GATHT(&quot;GATHT1<sup>11</sup> )</p>
<p>Each gather station has an element in the vector corresponding to its type number, NGATH.</p>
<p>Algorithm description :</p>
<p>&quot;Clear the blocking time&quot;</p>
<p>IF(TX(LTX,8).EQ.O) GOTO 100</p>
<p>TX(LTX,8) s 0</p>
<p>RETURN</p>
<p>When the process of letting gathered transactions past the station has begun, each of them tries the gather station. Here, GATHR2 recognizes such transactions by the presence of a block time, which it zeroes, and lets them pass. If a transaction has no block time, it is a new arrival and must be locked.</p>
<p>&quot;Compute the station number&quot;</p>
<p>100 K s &quot;EGATHF&quot; £ NGATH</p>
<p>The station number, K, is computed from NGATH.</p>
<p>&quot;Lock*&nbsp;H</p>
<p>AL(LTX,1) = ID</p>
<p>AL(LTX,2) r - &quot;KEND&quot; - K TX(LTX,8) s T</p>
<p><a name="bookmark346"></a>CATHT(NGATH) s GATHT(NGATH) ♦ 1</p>
<p><a name="bookmark347"></a>New arrivals at the gather station are alwayft locked. At the sane time, the count of locked transactions is incremented.</p>
<p><a name="bookmark348"></a>&quot;Test the count&quot;</p>
<p><a name="bookmark349"></a>IF(GATHT(NGATH).LT.NG) GOTO 200</p>
<p><a name="bookmark350"></a>If the new arrival raised the count of gathered transactions to the limit, the subroutine continues to &quot;Start the gathered transactions&quot;. Otherwise, it returns to flow management.</p>
<p><a name="bookmark296"></a>&quot;Start the gathered transactions&quot;</p>
<p>CALL UNL0CK(K,IPRINT) GATHT(NGATH) = 0 RETURN 1 200 CONTINUE RETURN 1 END</p>
<p>When the desired number of transactions has been gathered, they are started by calling UNLOCK. ACTIV2 activates them, one after the other, in the order determined by the station's policy, to try the gather station. Since they all now have block times, they will all find the gather station open.</p>
<p>7.5 User Chains and Trigger Stations</p>
<p>By the use of user chains and trigger stations, it is possible to gather transactions in one processing path, and to free them from a parallel processing path.</p>
<p>7.5.1 Coordinating Transactions in Parallel Paths</p>
<p>Arriving transactions are gathered at a user chain. Transactions arriving at. a trigger station can, on demand, open the user chain to let a specified number of waiting transactions past. The trigger station is also opened to the triggering transaction.</p>
<p>Example:</p>
<p>* Town-bound passengers wait for a cab at the airport's taxi stand. Each arriving cab picks up some number of passengers. If there are no passengers, the cabs wait. After each trip into town, a cab returns to the stand (see figure 28).</p>
<p>PASSENGERS</p>
<p>---------r~HM I—</p>
<p>----------ft |</p>
<p>I</p>
<p>V</p>
<p>Ï * &quot;l I USER CHAIN |</p>
<p>I&nbsp;I</p>
<p>J</p>
<p>PROCESSING PATH 1</p>
<p>CABS</p>
<p>— I Itll &lt;-----</p>
<p>I ft----------</p>
<p>I</p>
<p><a name="bookmark351"></a>v</p>
<p><a name="bookmark352"></a>ï Ï | TRIGGER&nbsp;|</p>
<p><a name="bookmark353"></a>j STATION&nbsp;j</p>
<p>r</p>
<p><a name="bookmark101"></a>PROCESSING PATH 2</p>
<p>USE OF USER CHAINS AND TRIGGER STATIONS TO SIMULATE A TAXI STAND</p>
<p>User chains are each paired with a specific trigger station. Each pair has adjoining elements in the state vector. A user chain's state-vector element shows it inaccessible when transactions are being gathered to be activated by a trigger station. Its trigger station has the next element in the state vector. It shows the trigger station inaccessible when a transaction is waiting there for a specified number of transactions to be gathered at the user chain. Each user chain has, in addition, an element in the UCHT matrix, which is defined as follows:</p>
<p>INTEGER UCHT</p>
<p>DIMENSION UCHT(<sup>l,</sup>UCHT1<sup>lf</sup> ,2)</p>
<p>The individual elements have the following meanings:</p><div>
<p>UCHT(NUCHN,1)</p></div>
<p>Number of transactions gathered</p>
<p>The number of transactions already gathered at the user chain is specified. A transaction arriving at a trigger station can check to see whether its requisite number of transactions is already there.</p><div>
<p>FIGURE 28</p></div>
<p>Number of transactions When a trigger station transactions activated one. GPSS-F needs a cou along It is in the act many transactions are 1 chain. The counter is station (UNLIN2) and de transaction let past until it reaches zero.</p><div>
<p>UCHT(NUCHN,2)</p></div>
<p>already activated wants a certain number of , they are activated one by nter that tells it how far ivation procedure, i.e. how eft to be let past the user initialized by the trigger cremented by one for each by the user chain (LINK2),</p>
<p><a name="bookmark354"></a>7.5.2 LINK2</p>
<p><a name="bookmark355"></a>Purpose:</p>
<p>A transaction that calls LINK2 is blocked <sup>%</sup>and placed in the user chain's queue. At the same time, LINK2 occasions a check to see whether the trigger station's requisite number of transactions has arrived. If so, a transaction-removal procedure begins.</p>
<p>A transaction removal begins when LINK2 marks the user chain accessible. Plow management begins activating blocked transactions, which then call LINK2 again. LINK2 recognizes them and lets them pass, one by one, until the desired number has been let through. Then the user chain is marked inaccessible again.</p>
<p>GPSS-F supervises the user chains automatically. This program pays no attention to a transaction's family membership.</p>
<p>Calling sequence:</p>
<p>CALL LINK2 (NUCHN,ID,41005,IPRINT) -</p>
<p>Parameters:</p>
<p>NUCHN Type-2 user chain number (Type number)</p>
<p>Type-2 user chains are numbered sequentially. Thte number is the same as the number of the trigger station that belongs to this user chain.-ID&nbsp;LINK2 CALL's statement number</p>
<p>Transactions activated by a trigger station are to try the user chain again where there wait; they execute the CALL LINK2 statement bearing the number here specified. 41005 Blocking exit</p>
<p>When an arriving transaction is blocked, flow management must receive control again. IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT = 0.</p>
<p>Data area:</p>
<p>LINK2 uses the activation list, the TX matrix, the state vector and the UCHT matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Determine the station number&quot;</p>
<p>K s &quot;EUCHF&quot; ♦ 2 « NUCHN - 1</p>
<p>The station number, K, is computed from NUCHN. The station number of the corresponding trigger station will be K+1.</p>
<p>&quot;Block&quot;</p>
<p>IF(TX(LTX,8).NE.O) GOTO 100 UCHT(NUCHN,1) = UCHT(NUCHN<sub>t</sub>1) * 1 IF(UCHT(NUCHN,2).GT.0) GOTO 50 STATE(K) = 0</p>
<p>50 ALCLTX,1) s ID AL(LTX,2) * - K TX(LTX<sub>f</sub>8) s T RETURN 1</p>
<p>Here, LINK2 recognizes, by the presence of a block time, the transactions being removed. If the calling transaction has a block time, it jumps to &quot;Remove&quot;. If a transaction has no block time, it is a new arrival and must be blocked. At the same time, the count of waiting transactions is incremented by one.</p>
<p>Since there is now one more transaction at the user chain, a transaction waiting at the trigger station should be activated to try its station again; the requisite number of user-chain transactions may now be available. The user chain's trigger station is therefore marked accessible. In case the user chain is still accessible from the last removal procedure, it is marked inaccessible.&nbsp;<sub>#</sub>&nbsp;'</p>
<p>Neither the user chain's nor the trigger station's present state may be disturbed, if a removal procedure is in progress. That is the case when UCHN(NUCHN,2) is non-zero. In that case, the new arrival just quietly takes its place among the waiting.</p>
<p>&quot;Remove&quot;</p>
<p>100 UCHT(NUCHN,1) = UCHT(NUCHN,1) - 1 UCHT(NUCHN,2) = UCHT(NUCHN,2) - 1 IF(UCHT(NUCHN,1).EQ.O) UCHT(NUCHN,2) s 0&nbsp;»</p>
<p>IF(UCHT(NUCHN,2).GT.O) GOTO 150 STATE(K) = 0&nbsp;/</p>
<p>STATE(K+1) = 1 150 TX(LTX,8) s 0 RETURN END</p>
<p>This section is reached only by transactions being let past the user chain in a removal. The removal counters are decremented. (The removal counter has been set initially by UNLIN2 to show the maximum number of transactions it wants.) If there simply are no more transactions to remove, the removal counter is zeroed. The triggering transaction is assured of removing the minimum number of transactions it requires, since the removal procedure doesn't even begin until there are at least that many. Transactions arriving during a removal will be taken too, if the maximum hasn't been reached before they arrive.</p>
<p>If the removal is over (UCHT(NUCHN,2)=0), the user chain is marked inaccessible. The trigger station is, however, made accessible again, since transactions could have arrived during the removal and still be left over. The next transaction to try the trigger station could perhaps remove them.</p>
<p>The block time is cleared for all transactions being allowed to pass.</p>
<p>T-5,3 UHLIH2</p>
<p><a name="bookmark356"></a>Purpose:</p>
<p>%</p>
<p>When a transaction calls UNLIN2, the subroutine checks the number of transactions waiting at the associated user chain. If it is at least as large as the minimum number thç calling transaction wants, a removal procedure is initiated.If, on the other hand, there are fewer transactions at the user chain than the requisite minimum, the transaction is blocked. New arrivals are also blocked, if there is already another transaction waiting at the trigger station. Each time another transaction arrives at the user chain, the trigger station is made accessible for trial again.</p>
<p>UNLIN2 pays no attention to a transaction's family membership. GPSS-F supervises the trigger stations.</p>
<p>Calling sequence:</p>
<p>CALL UNLIN2 (NUCHN,NUMIN,NUMAX,ID,&amp;1005,IPRINT)</p>
<p>Parameters:</p>
<p>NUCHN Type-2 user chain number</p>
<p>The trigger station's number is the same as that of its user chain. NUCHN gives the user chain's line in the UCHT matrix. NUHIN Minimum request</p>
<p>A removal can be initiated when there are at least so many transactions waiting at the user chain. NUMAX Maximum request</p>
<p>A removal will allow no more than so many transactions to pass the user chain. ID&nbsp;UNLIN2 CALL<sup>#</sup>s statement number</p>
<p>Transactions waiting at a trigger station are waiting for a certain number of transactions to have gathered at the user chain. Each time one arrives there, the trigger station is made accessible again to its waiting transactions. When they are activated, they execute the CALL UNLIN2 statement bearing this number. 41005 Blocking exit</p>
<p>A transaction whose requisite number of transactions has not yet been gathered at the user chain is blocked. Then flow management must receive control again. IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>UNLIN2 uses the activation list, the TX matrix, the state vector and the UCHT matrix.</p>
<p><a name="bookmark357"></a>Algorithm description:</p>
<p><a name="bookmark358"></a>&quot;Determine the station number&quot;</p>
<p><a name="bookmark359"></a>K * &quot;EUCHF&quot; ♦ 2 • NUCHN - 1</p>
<p><a name="bookmark360"></a>The user chain's station number, K, is computed from NUCHN. The trigger station's station number is K+1,</p>
<p><a name="bookmark361"></a>&quot;Blocking decision&quot;</p>
<p><a name="bookmark362"></a>IF(UCHT(NUCHN, 1) .GE.NUMIN.AND.STATE(K+1).EQ. 1) GOTO 100</p>
<p><a name="bookmark363"></a>If the trigger station has been made accessible, and if the calling transaction's minimum request is available at the user chain<sub>9</sub> the program jumps to &quot;Start a removal procedure&quot;. Otherwise, the calling transaction is blocked in the next section.</p>
<p><a name="bookmark364"></a>&quot;Block&quot;</p>
<p>STATE(K+1) s 0 AL(LTX,1) s ID AL(LTX,2) s - (K + 1) IF(TX(LTX,8).EQ.O) TX(LTX,8) = T RETURN 1</p>
<p>The trigger station is only marked accessible by LINK2. That happens when a new transaction arrives at the user chain, or at the end of the removal procedure. Here, the trigger station is marked inaccessible as soon as it has been tried. The calling transaction is blocked to wait for LINK2 to mark its trigger station accessible again. Its block code is -(K+1).</p>
<p>&quot;Start a removal procedure&quot;</p>
<p>100 UCHT(NUCHN,2) = NUMAX STATE(K+1) = 0 STATE(JC) = 1</p>
<p>IF(UCHT(NUCHN<sub>f</sub>1).EQ.O) UCHT(NUCHN,2) s 0</p>
<p>TX(LTX,8) = 0</p>
<p>RETURN</p>
<p>END</p>
<p>At start of the removal, UNLIN2 sets the removal count to the maximum number of transactions it wants to remove, regardless whether there are that many available or not. Subroutine LINK2 decrements the counter until the request is satisfied, or its supply of transactions is depleted.</p>
<p>Mo new arrival at the trigger station is allowed to disturb a removal procedure until it is over: The trigger station is marked inaccessible, for the time being. At the end of the removal, LINK 2 will mark it accessible again. The user chain must now be marked accessible, in order to initiate the removal.</p>
<p>The triggering transaction's block time is cleared and it is allowed to proceed on its way.</p>
<p>Notes:</p>
<p>•&nbsp;A newly arriving transaction is always blocked, if there is another waiting, even if it requests fewer*transactions from the user chain than the waiting transaction. If need be, the user can alter this behaviour.</p>
<p>*&nbsp;In terms of accessibility for trial, a trigger station behaves like a type-2 gate: waiting transactions try it one by one, until one of them finds it closed; then it is made inaccessible for further trial. It will be made accessible again the next time a transaction arrives at the user chain.</p>
<p>8 FAMILIES</p>
<p><a name="bookmark365"></a>Some simulations require that several transactions belong together. They shall be said to form a family.</p>
<p>8.1 Kindred Tasks</p>
<p>Family members are distinct from one another, but they carry extra codes or names that mark as being akin to one another. A transaction's duplicate number is its first name; its family number, which takes the place of an ordinary transaction number, is its last namfe. Families are useful whenever different groups of transactions travelling the same path must be processed differently.</p>
<p>Example:</p>
<p>* Two high-school classes spend the afternoon in the Smithsonian's Museum of Technology. The students are for the most part on their own, except that they are to gather, by class, at the start of the printing exhibit at 2:00 and at the collection of musical instruments at 4:00.</p>
<p>8.2 Data Areas for Families</p>
<p>A parent transaction begets offspring by calling SPLIT, which generates the requested number of new transact ions, using the parent's transaction number as family number. Duplicate numbers are assigned sequentially and entered in the progeny's TX(LTX,2) field. Each family member can, in turn, beget more kinsmen.</p>
<p>The parameters that characterize a family are kept in the FAM matrix, which is defined as follows:</p>
<p>INTEGER FAM</p>
<p>DIMENSION FAM(*FAM1<sup>H</sup>,3)</p>
<p>The FAM matrix has as many lines as the TX matrix, because in the worst case, every transaction could be a family unto itself.</p>
<p>When the active transaction happens to be a family member, the variable LFAM is set to point to its line in the FAM matrix. The individual elements of the matrix have the following meanings:</p>
<p>FA<sup>M</sup>(LFA!t, 1) Family number</p>
<p>All family members have the same family number, assigned to them at birth by subroutine SPLIT. A parent's transaction number becomes it3 family number. If this field is zero, the line in the FAM- matrix is free.</p>
<p><a name="bookmark366"></a>Number of present kinsmen</p>
<p><a name="bookmark367"></a>The number of family members in the system is given. The count is raised or lowered when new members are generated or old are annihilated.</p>
<p>Last duplicate number</p>
<p>The next duplicate number assigned will be one larg~ er than the number stored here.</p><div>
<p>PAM(LFAM,2)</p>
<p>FAH(LFAM,3)</p></div>
<p>8.3 The Birth and Death of Kinsmen</p>
<p>Transactions are split into family members or reassembled into single transactions again by running through splitting and assembling stations. A transaction begets offspring by calling SPLIT, which splits it into some specified number of family members. By calling ASSEMB, family members can reassemble themselves into one entity.</p>
<p>Examples:</p>
<p>*&nbsp;Aircraft engines are dismounted from time to time for a major overhaul. After being dismantled, the parts are adjusted, inspected and reassembled, one stage at a time, with reliability tests at each stage.</p>
<p><sup>#</sup>&nbsp;A job in a multi-tasking computing system splits into two concurrently active tasks with equal priority. ~he operating system treats both as equals, except that they must pull themselves together again before terminating. If not, the computer's operating system terminates the job abnormally.</p>
<p>Transactions that aren't family members run through assembly stations untoutched: transactions that were never disassembled using subroutine SPLIT can never be assembled using ASSEMB. Many real-world assembly procedures assemble components that were never disassembled from a single entity; families are not especially well-suited to simulate them. But procedures that assemble transactions that aren't kinsmen can be modelled easily using programming techniques like those in ASSEMB.</p>
<p>8.3-1 SPLIT Purpose:</p>
<p>A transaction that calls SPLIT begets a specified number of offspring. The parent remains active and SPLIT returns to the statement following the call; the offspring are all scheduled to be activated at the current clock time. If the parent is not a family member, a family is established by setting up a line for it in the FAM matrix.</p>
<p>Calling sequence:</p>
<p>CALL SPLIT (NDUP,DUPADD,41006,IPRINT)</p>
<p>parameters:</p>
<p>NDUP Number of duplicates</p>
<p>The number of offspring Is given. DUPID Target statement number for offspring</p>
<p>The offspring are all scheduled to be activated immediately and given this statement number as target. 41006 List-overrun exit</p>
<p>This exit is taken when either the family or the transaction matrix is full and no new entry can be made. It is recommended to break off the simulation. IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>SPLIT uses the activation list, the TX matrix and the FAM matrix.</p>
<p>Algorithm description: &quot;Test&quot;</p>
<p>IF(NDUP.EQ.O) RETURN IF(LFAM.NE.O) GOTO 300</p>
<p>If no offspring are to be generated, SPLIT returns on the spot. If the parent is not a family member, a family must be founded. Otherwise, the family merely grows.</p>
<p>&quot;Found a family&quot;</p>
<p>DO 100 LFAM = 1 , &quot;FAM1&quot; IF(FAM(LFAM,1).EQ.0) GOTO 200 100 CONTINUE RETURN 1 200 FAM(LFAM,1) = TX(LTX,1) FAM(LFAM,2) z 1 FAfKLFAM, 3) = 1 TX(LTX,2) = 1</p>
<p>A free line is found for the family in the FAM matrix and the number is set in LFAM. If no line can be found, the list-overrun exit is taken. At the moment, the family consists of nothing more than the parent. This state of affairs is noted in the second and third elements of the family's FAM-matrix entry. The parent is assigned the duplicate number 1.</p>
<p>&quot;Beget&quot;</p>
<p>300 DO 3^0 1 = 1, NDUP</p>
<p>FAM(LFAM,2) = FAM(LFAM,2) ♦ 1 FAM(LFAM, 3) • FAfKLFAM,3) ♦ 1 DO 310 IA = 1 , &quot;TX1&quot; IF(TX(IA,1).EQ.0) GOTO 320 310 CONTINUE</p>
<p>RETURN 1 320 LTXD x IA</p>
<p>TX(LTXD,1) * TX(LTX,1) TX(LTXD,2) s FAM(LFAM,3) TX(LTXD,3) * T DO 330 JC * 4 , »TX2&quot; 330 7X(LTXD,JC) s TX(LTX,JC)</p>
<p>This section finds and fills in lines in the TX matrix for the newly begotten transactions. Each time through the outer loop<sub>9 </sub>the family's counters are Incremented.</p>
<p>The inner loop looks for a free line in the TX matrix. When It finds one, it keeps the line number in LTXD; if it finds none, it returns via the overrun exit. The parameters of the father are visited upon the son, not counting first name and birth time.</p>
<p>IF(LTXD.GT.LAL) LAL r LTXD AL(LTXD,1) s DUPADD AL(LTXD,2) = T 340 . CONTINUE RETURN END</p>
<p>•</p>
<p>Each new transaction is scheduled to be activated at the present clock time, with the specified statement number as target. If need be, the activation-list list-end pointer, LAL, is reset.</p>
<p>8.3.2 ASSEMB Purpose:</p>
<p>Family members that call ASSEMB specify an assembly station where they are to be fused into one transaction. If the specified station is not already assembling members of the caller's family, an assembly is begun: the station notes how many members from this family are to be fused together.</p>
<p>Once an assembly is in progress, kinsmen arriving at the station are annihilated one by one, until the desired number is reached, except that the last arrival remains alive and active. It travels on to serve as the newly assembled unit.</p>
<p>Calling sequence:</p>
<p>CALL ASSEMB (NUMASS,NASSEM,41005,IPRINT)</p>
<p>Parameters:</p>
<p>NUMASS Assembly station number (Type number).</p>
<p>Assembly stations are numbered sequentially. NASSEM Number of transactions to be assembled</p>
<p>The number of family members to be fused together is specified. 41005 Annihilation exit</p>
<p>This exit is taken each time a family member is annihilated; the subroutine must return to flow management.</p>
<p>IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>ASSEMB uses the FAM and TX matrices. It needs a further data area, the ASM matrix, to keep track of assemblies in progress. Here it counts down the number of kinsmen to go, until the as« sembly is complete. Each station can assemble members concurrently from different families. Hence the ASM matrix is defined as fo 11 o ws:</p>
<p>INTEGER ASM</p>
<p>DIMENSION ASft(<sup>W</sup>FAM1 * ,*ASM1<sup>n</sup>)</p>
<p>Each station has as many elements in its column as there are families and each family has as many elements in its line as there are assembly stations.</p>
<p>Algorithm description:</p>
<p>&quot;Test for family membership&quot;</p>
<p>IF(LFAM.EO.O) RETURN</p>
<p>ASSEMB ignores transactions that don't belong to any family.</p>
<p>&quot;Initiate an assembly&quot;</p>
<p>IF(ASM(LFAM,NUMASS).EQ.0) ASM(LFAM,NUMASS) = NASSEM</p>
<p>If the&nbsp;assembly count for the caller's family and specified</p>
<p>station is&nbsp;zero, an assembly is begun by setting the count to NASSEM.</p>
<p>&quot;Decrement&nbsp;the count&quot;</p>
<p>ASM(LFAM,NUMASS) = ASM(LFAM,NUMASS) - 1</p>
<p>Each arriving kinsman decrements the count of transactions to be fused together.</p>
<p>&quot;Fuse&quot;</p>
<p>IF(ASM(LFAM,NUMASS).GT.O) GOTO 200 IF(FAM(LFAM,2).GT.1) GOTO 150 RETURN 150 CONTINUE RETURN</p>
<p>When the assembly count reaches zero, the transaction is not annihilated. Instead, it remains active and ASSEMB returns to the statement following the call.</p>
<p><a name="bookmark368"></a>* Annihilate<sup>19</sup></p>
<p><a name="bookmark369"></a>200 CALL TERMIN(4250 ,1PRINT) 250 RETURN 1 END</p>
<p><a name="bookmark370"></a>All arrivals except the last are annihilated. ASSEMB returns to flow management.</p>
<p>8.4 Coordinating Family Members</p>
<p>Type-2 gather stations, user chains and trigger stations are used to coordinate transactions without regard to family membership. GPSS-F provides type-1 stations that perform the same tasks, except that family members are gathered together.</p>
<p>8.4.1&nbsp;Gather Stations for Families</p>
<p>The new gather stations behave like the simple ones (see 7.4), with the proviso that:</p>
<p>.</p>
<p>a)&nbsp;transactions that aren't family members run through the station without being gathered at all. and</p>
<p>b)&nbsp;family members are sorted and gathered according to family.</p>
<p>The number of members to be gathered is specified individually for each family. When that many kinsmen have arrived, they are permitted to proceed.</p>
<p>8.4.2&nbsp;GATHR1</p>
<p>Purpose:</p>
<p>Transactions calling subroutine GATHR1 are locked until a certain number of their kinsmen, specified by the user, have arrived. When that has happened, the gather station is opened and the family reunion proceeds, one member at a time. GPSS-F supervises the gather stations automatically.</p>
<p>Calling sequence:</p>
<p>CALL GATHR1 (NG,NGATH,ID,41005,IPRINT)</p>
<p>Parameters:</p>
<p>Number of transactions to collect</p>
<p>The number of kinsmen to be gathered is specified. Type-1 gather station number (Type number) Type-1 gather stations are numbered sequentially. GATHR1 CALL's statement number</p>
<p>If a transaction must be locked, it is given this statement number as target; when it is re-activated to try</p><div>
<p>NG</p>
<p>NGATH</p>
<p>ID</p></div>
<p>the gather station again, It will continue its activity at the statement whose number this is. Normally, that would be the call to GATHR1 that originally caused the transaction to be locked. 61005 Locking exit</p>
<p>If the transaction, is locked, flow management must be called; hence statement number 1005 should always be specified here. IPRINT Trace flag</p>
<p>Trace printouts are suppressed when IPRINT = 0.</p>
<p>Data area:</p>
<p>GATHR1 uses the activation list, the TX matrix and the state vector. Each type-1 gather station has an entire section of the state vector to itself, one element for each family, since the gather station can be open to one family and at the same time closed to others. The gather station for families whose type number is NGATH has the state-vector elements from</p>
<p>STATE(&quot;EGATE2&quot;*(NGATH-1)*&quot;FAM11)</p>
<p>to</p>
<p>STATE(&quot;EGATE2&quot;*(NGATH-1)*&quot;FAM1&quot;+&quot;FAM1&quot;)</p>
<p>Further, a gather counter is needed for each family that specifies how many kinsmen have already arrived. It is defined as follows:</p>
<p>INTEGER GATHF</p>
<p>DIMENSION GATHF(&quot;FAM1&quot;,&quot;GATHF1&quot;)</p>
<p>Each gather station has a column in the matrix corresponding to its type number, NGATH, and each column has an element for each family.</p>
<p>Algorithm description:</p>
<p>&quot;Test for family membership&quot;</p>
<p>IF(LFAM.EQ.O) RETURN</p>
<p>If the calling transaction is not a family member, return immediately.</p>
<p>&quot;Clear the blocking time&quot;</p>
<p>IF(TX(LTX,8).EQ.O) GOTO 100</p>
<p>TX(LTX,8) = 0</p>
<p>RETURN</p>
<p>When the process of letting a family reunion past the station has begun, each kinsman tries the gather station. Here, GATHR1 recognizes such transactions by the presence of a block time, which it zeroes, and lets them pass. If a transaction has no block time, it is a new arrival and must be locked.</p>
<p>&quot;Determine the station number&quot;</p>
<p><a name="bookmark371"></a>100 K « &quot;EGATE2&quot; ♦ &quot;FAM1&quot; • (NGATH ~ tl ♦ LFAH The station number, K, is computed from NGATH. &quot;Lock*</p>
<p>AL(LTX,1) s ID AL(LTX,2) = - &quot;KEND&quot; - K TXCLTX,8) S T</p>
<p>GATHF(LFAM,NGATH) s GA THF(LFAM <sub>t</sub> HGA TH) ♦ 1</p>
<p>New arrivals at the gather station are always locked. At the same time, the count of locked kinsmen is incremented.</p>
<p>&quot;Test the count&quot;</p>
<p>IF(GATH<sup>P</sup>(LFAM,NGATH).LT.NG) GOTO 200</p>
<p>If the new arrival raised the count of gathered kinsmen to the limit, the subroutine continues to &quot;Start the gathered transactions&quot;. Otherwise, it returns to flow management.</p>
<p>&quot;Start the gathered transactions&quot;</p>
<p>CALL IJNL0CK(K, IPRINT) GATHF(LFAM<sub>f</sub>NGATH) s 0 RETURN 1 200 CONTINUE RETURN 1 END</p>
<p>When the desired number of kinsmen has been reunited, they are started by calling UNLOCK. ACTIV2 activates them, one after the other, in the order determined by the station's policy, to try the gather station. Since they all now have block times, they will all find the gather station open.</p>
<p>8.^.3 User Chains and Trigger Stations for Families</p>
<p>The families' user chains-and trigger stations behave like the old ones (see 7.5), with the proviso that:</p>
<p>a)&nbsp;transactions that aren't family members run through the stations completely untoutched and</p>
<p>b)&nbsp;family members are sorted and gathered according to family.</p>
<p>A family member arriving at a trigger station requests that a group of its kinsmen be let past the user chain. It cannot request members of another family. The kinsmen gathered at a user chain are let past only in case there are enough of them to cover &quot;he trigger station's request.</p>
<p>Each user chain and each trigger station has an entire area of the the state vector to itself, one element for each family, since the station can be open to one family and at the same time closed to others. The type-1 user chain and trigger station whose type number is NUCHN have the state-vector elements from</p>
<p>STATE( &quot;EGATHT&quot;* (NUCHN-1) •2*<sup>I,</sup>FAM1 1)</p>
<p>to</p>
<p>STATE( &quot;EGATHT&quot;* (NUCHN-1) »2+<sup>N</sup>FAM1 &quot;♦2»<sup>M</sup>FAH1<sup>11</sup>)</p>
<p>Just as for their type-2 analoga, type-1 user chains and trigger stations have adjoining elements in the state vector. If the Kth element belongs to a user chain, the (K+1)th element belongs to its trigger station.</p>
<p>There is-furthermore a UCHF matrix, corresponding to the UCHT matrix for type-2 user chains and trigger stations (see 7.5.1). Because all counters must be accumulated separately for each family, the matrix must be three-dimensional. It is defined as follows:</p>
<p>INTEGER UCHF</p>
<p>DIMENSION UCHF(&quot;FAM1&quot;,&quot;UCHF1&quot;,2)</p>
<p>8.4.4 LINK! Purpose:</p>
<p>A family member that calls LINM is blocked and placed in the user chain's queue. At the same time, LINK1 occasions a check to see whether the number of kinsmen being requested at the trigger station has arrived. If so, a kinsman-removal procedure begins.</p>
<p>A kinsman removal begins when LIMK1 marks the user chain accessible to a particular family. Flow management begins activating blocked kinsmen, which then call LINK 1 again. LINK1 recognizes them and lets then pass, one by one, until the desired number has been let through. Then the user chain is marked inaccessible again.</p>
<p>GPSS-<sup>P</sup> supervises the user chains automatically. Transactions that aren't family members are completely ignored.</p>
<p>Calling sequence:</p>
<p>CALL LIHK1 (NUCHN,ID,41005,IPRINT)</p>
<p>Parameters:</p>
<p>NUCHN Type-1 user chain number (Type number)</p>
<p>Type-1 user chains are numbered sequentially. The number is the same as the number of the trigger station that belongs to this user chain. ID&nbsp;LXNK1 CALL's statement number</p>
<p>Transactions activated by a trigger station are to try the user chain again where there wait; they execute the CALL LINK1 statement bearing the number here specified.</p>
<p>41005 Blocking exit</p>
<p>Vhen an arriving transaction is blocked, flow management must receive control again.</p>
<p>IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>LINK1 uses the activation list, the TX matrix, the state vector and the UCHF matrix.</p>
<p>Algorithm description:</p>
<p>&quot;Test for family membership<sup>99 </sup>IF(LFAM.EQ.O) RETURN</p>
<p>If the calling transaction is not a family member, return immediately.</p>
<p>&quot;Determine the station number&quot;</p>
<p>K s &quot;EGATHT&quot; ♦ 2 • &quot;FAM1&quot; « (NUCHN - 1) ♦ 2 <sup>41</sup> LFAM - 1*</p>
<p>The station number, K, is computed from NUCHN. The station number of the corresponding trigger station will be K+1.</p>
<p>&quot;Block&quot;</p>
<p>IF(TX(LTX,8).NE.0) GOTO 100</p>
<p>UCHF(LFAM,NUCHN,1) r UCHF(LFAM,NUCHN,1) ♦ 1 IF(UCHF(LFAM,NUCHN,2).GT.O) GOTO 50 STATE(K) s 0 STATE(K+1) s 1 50 AL(LTX,1) = ID AL(LTX,2) ? - K TX(LTX,8) = T RETURN 1</p>
<p>Here, LINK1 recognizes, by the presence of a block time, the transactions being removed. If the calling transaction has a block time, it jumps to &quot;Remove&quot;. If a transaction has no block time, it is a new arrival and must be blocked. At the same time, the count of waiting kinsmen is incremented by one.</p>
<p>Since there is now one more kinsman at the user chain, a transaction waiting at the trigger station should be activated to try its station again; the requisite number of kinsmen may now be available at the user chain. The user chain's trigger station is therefore marked accessible. In case the user chain is still accessible from the last removal procedure, it is marked inaccessible.</p>
<p>Neither the user chain's nor the trigger station's present state may be disturbed, if a removal procedure is in progress. That is the case when UCHF(NUCHN,2) is non-zero. In that case, the new arrival just quietly takes its place among the waiting.</p>
<p><a name="bookmark372"></a>&quot;Remove&quot;</p>
<p>100 UCHF(LFAM,NUCHN,1) s UCHF(LFAH,NUCHN,1) - 1 UCHF(LFAM,NUCHN,2) s UCH<sup>I?</sup>(LFAM,NUCHN,2) - 1 IF(UCHF(LFAM,NUCHN,1).EQ.O) UCHF(LFAM,NUCHN,2) s 0 IF(UCHF(LFAM<sub>t</sub>NUCHN,2).GT.O) GOTO 150 STATE(K) s 0 STATE(K+1) s 1 150 TX(LTX,8) s 0 RETURN END</p>
<p>This section is reached only by transactions being let past the user chain in a removal. The family's removal counters are decremented. (The removal counter has been set initially by UNLIN1 to shôw the maximum number of transactions being requested.) If there simply are no more transactions to remove, the removal counter is zeroed. The triggering transaction is assured of removing the minimum number of transactions it requires, since the removal procedure doesn't even begin until there are at least that many. Transactions arriving during a removal will be taken too, if the maximum hasn't been reached before they arrive.</p>
<p>If the removal is over (UCHF(NUCHN,2)=0), the user chain is marked inaccessible. The trigger station is, however, made accessible again, since transactions could have arrived during the removal. The next transaction to try the trigger station could perhaps remove them.</p>
<p>The block time is cleared for all transactions being allowed to pass.</p>
<p>8.4.5 UNLIN1 Purpose :</p>
<p>When a transaction calls UNLIN1, the subroutine checks the number of its kinsmen waiting at the associated user chain. If there are at least as many as the minimum number the calling transaction wants, a removal procedure is initiated. If, on the other hand, there are fewer kinsmen at the user chain than the requisite minimum, the transaction is blocked. New arrivals are also blocked, if there is already another transaction waiting at the trigger station. Each time another transaction arrives at the user chain, the trigger station is made accessible for trial again.</p>
<p>UNLIN1 pays no attention to transactions that aren't family members. GPSS-F supervises the trigger stations.</p>
<p>Calling sequence:</p>
<p>CALL UNLIN1 (NUCHN,NUMIN<sub>f</sub>NUMAX,ID,41005,IPRINT)</p>
<p>Parameters:</p>
<p>NUCHN Type-1 user chain number</p>
<p>The trigger station's number is the same as that of its user chain. NUCHN gives the user chain's line in the UCHF matrix. NUMIN Minimum request</p>
<p>A removal can be initiated when there are at least so many of the caller's kinsmen waiting at the user chain. NUMAX Maximum request</p>
<p>A removal will allow no more than so many transactions to pass the user chain. ID&nbsp;UNLIN1 CALL's statement number</p>
<p>Transactions waiting at a trigger station are waiting for a certain number of their kinsmen to have gathered at the user chain. Each time any family member arrives there, the trigger station is made accessible again to its waiting transactions. When they are activated, they execute the CALL UNLIN1 statement bearing this number. 41005 Blocking exit</p>
<p>A transaction whose requisite number of kinsmen has not yet been gathered at the user chain is blocked. Then flow management must receive control again. IPRINT Trace control</p>
<p>Trace printouts are suppressed when IPRINT s 0.</p>
<p>Data area:</p>
<p>UNLIN1 uses the activation list, the TX matrix, the state vector and the UCHF matrix.</p>
<p>Algorithm description:</p>
<p>••Test for family membership<sup>11</sup></p>
<p>IF(LFAM.EQ.O) RETURN</p>
<p>If the calling transaction is not a family member, return immediately.</p>
<p>••Determine the station number&quot;</p>
<p>%</p>
<p>K r &quot;EGATHT&quot; ♦ 2 * &quot;FAM1&quot; * (NUCHN - 1) ♦ 2 * LFAM - 1</p><div>
<p>NUCHN.</p></div>
<p>The user chain's station number, K, is computed from The trigger station's station number is £+1.</p>
<p>&quot;Blocking decision&quot;</p>
<p>IF(UCHF(LFAM<sub>t</sub>NUCHN,1).GE.NUMIN.AND.STATE(K+1).EQ.1) GOTO 1</p>
<p>If the trigger station has been made accessible, and if the bailing transact ion's minimum request is available at the user c.t ' the program jumps to &quot;Start a removal procedure&quot;. Other-wi rhe calling transaction is blocked in the next section.</p>
<p>&quot;Block<sup>11</sup></p>
<p>STATE(K+1) s 0 AL(LTX,1) s ID AL(LTX<sub>f</sub>2) » « (K ♦ 1) IF(TX(LTX,8).EQ.O) TX(LTX<sub>f</sub>8) = T RETURN 1</p>
<p>The trigger station is only marked accessible by LINK1. That happens when any family member arrives at the user chain, or at the end of a removal procedure. Here, the trigger station is marked inaccessible as soon as it has been tried. The calling transaction is blocked to wait for LINK1 to mark its trigger station accessible again. Its block code is -CK+1)»</p>
<p>&quot;Start a removal procedure&quot;</p>
<p>100 UCHF(LFAM,NUCHN,2) = NUMAX STATE(K) s 1 STATE(K+1) s 0</p>
<p>IF(UCHF(LFAM,NUCHN, 1) .EQ.O) UCHF(LFAM,NtJCHN<sub>f</sub>2) = 0</p>
<p>TX(LTX,8) = 0</p>
<p>RETURN</p>
<p>END</p>
<p>At start of the removal, IJNLIN1 sets the removal count to the maximum number of kinsmen it wants to remove, regardless whether there are that many available or not. Subroutine LINK1 decrements the counter until the request is satisfied, or its supply of kinsmen is depleted.</p>
<p>No new arrival at the trigger station is to be allowed to disturb a removal procedure until it is over. For that reason, the trigger station is marked inaccessible, for the time being; at the end of the removal, LINK1 will mark it accessible again. The user chain must now be marked accessible, in order to initiate the removal.</p>
<p>The triggering transaction's block time is cleared and it is allowed to proceed on its way.</p>
<p>Notes:</p>
<p>*&nbsp;A newly arriving transaction is always blocked, if there is another waiting, even if it requests fewer transactions from the user chain than the waiting transaction. If need be, the user can alter this behaviour.</p>
<p>*&nbsp;In terms of accessibility for trial, a trigger station behaves like a type-2 gate: waiting transactions try it one by one, until one of them finds it closed; then it is made inaccessible for further trial. It will be made accessible again the next time a family member arrives at the user chain.</p>
<p><a name="bookmark373"></a>9 RANDOM SEQUENCES</p>
<p>Random numbers Help to simulate stochastic systems (see 1.1.2): unpredictable sequences of numbers determine when or how the system's unpredictable events occur. With careful rigging, this contrivance will model any randomly recurring event. We shall call a sequence of numbers random, when it fulfils two criteria:</p>
<p>a)&nbsp;the sequence's terms recur with a given frequency and</p>
<p>b)&nbsp;there is no relation between the terms. Example:</p>
<p>* The digits in the sequence 11 1 1 12222233333</p>
<p>are not random. They satisfy the first requirement, but not the second: each digit occurs with equal frequency in the whole sequence, but there is an obvious relation between its terms.</p>
<p>The first part of this chapter (through 9.3.6) hopes to illuminate the generation and use of random sequences in modelling, but a thorough introduction belongs in a book of its own. Random sequences are a kaleidoscope and the trick is to know which kind to use and when. For simple models, a couple of broad rules and a lot of common sense will suffice; for highly complicated models, the choice can be crucial. If you hate mathematics, read this chapter looking past the formulas. If you enjoy math look into (ft) or (8).</p>
<p>9.1 Random Number Generators</p>
<p>To say that a system is stochastic is just another way of saying that one or more of the system's parameters is a random variable: it takes on Values unpredictably, except that it may tend to prefer certain values. A. random variable's behaviour is determined by a distribution function that specifies which values it prefers and how much; its behaviour is modelled by a sequence of numbers that obeys the same distribution. Any manner of stochastic event can be simulated, assuming random sequences of the required distribution can be gotten.</p>
<p>A random sequence is distributed uniformly on an interval, if each of its terms is just as likely to turn up in one subinterval as in any other, disjoint subinterval of equal length; i.e. the sequence doesn't prefer any part of the interval. Uniform random Sequences are easily pressed into any distribution you please, &quot;bus the basis of stochastic simulation is a program that grinds out a uniform random sequence.</p>
<p>b3 Random number generators usually build each tern In the sequence according to a specific algorithm. The algorithmic method has two advantages. First, it is easily put on a computer. Second, it yields repeatable sequences: if the generator is put back In its Initial state, it manufactures the same sequence every time.</p>
<p>A computerized random number generator should fulfil the following requirements as well:</p>
<p>a)&nbsp;It should be simple and run fast. This requirement is usually fulfilled when the algorithm generates each random number R(j+1) using nothing more than the previous one R(j).</p>
<p>b)&nbsp;If it generates a repeating sequence, its period of repetition should be as large as possible.</p>
<p>9.2 Uniformly Distributed Random Sequences</p>
<p>Various methods generate pleasingly uniform random sequences. Only the multiplicative-congruence procedure will be discussed here, since it is used in GPSS-F. It computes terms in a random sequence from the equation:</p>
<p>X(i*1) s (DFACT*X(i)+DCONST) mod DMODUL</p>
<p>where DFACT, C and DMODUL must be chosen so as to guarantee randomness. According to (4), the following rules should be observed:</p>
<p>*&nbsp;If DMODUL is a power of two, DFACT should satisfy the relation:</p>
<p>DFACT mod 8=5</p>
<p>*&nbsp;The relation between DMODUL and DFACT should satisfy:</p>
<p>SORT( DMODUL) . LT. DFACT. LT. (DMODUL-SORT(DMODUL) )</p>
<p>where DMODUL is as large as possible. It is further desirable that:</p>
<p>DFACT.GT.DMODUL/100</p>
<p>*&nbsp;The additive constant C should be odd, if DMODUL is a power of two. In addition, C should be a multiple of 5, if DMODUL is a power of 10.</p>
<p>*&nbsp;The relation between DMODUL and C should satisfy:</p>
<p>DCONST/DMODUL = 1/2-1/6*SQRT(3) = 0.211</p>
<p>In GPSS-F*s random number generators, the values of DFACT, and DMODUL were chosen to meet the above requirements. Furthermore, they were tested for randomness according to the following tests (all (4)):</p>
<p>•&nbsp;Spectral test following Coveyou and MacPherson</p>
<p><a name="bookmark374"></a>•&nbsp;Chi-squared test</p>
<p>•&nbsp;Kolmogorov-Smirnov test</p>
<p>•&nbsp;Gap test</p>
<p><sup>11</sup> Permutation test</p>
<p>The results are given in the listing for subroutine INIT1 (appendix A5).</p>
<p>9-3 Arbitrarily Distributed Random Sequences</p>
<p>There are various methods for redistributing a uniform random sequence to meet a prescribed distribution. The techniques used in GPSS-F are reviewed below. They are described elsewhere in more detail, e.g. in (5).</p>
<p>The next section (9.3*1) discusses a standard redistribution technique. The subsequent three sections (9.3.2 -to 9.3.ft) describe four distributions used often in modelling. Each •section defines the circumstances under which that kind of randomness occurs, giving typical examples, followed by some brief notes on its computation. Finally, sections 9.3.5 and 9.3.6 discuss special topics in the use of GPSS-F's random number generators.</p>
<p>Further techniques are easy to find in books on simulation or in standard scientific-subroutine packages.</p>
<p>9.3.1 Using the Inverse Cumulative-Distribution ^unction</p>
<p>A random sequence's distribution is determined by its density function f(X), or by its cumulative-distribution function F(X), called its cdf for short. Very roughly speaking, a random sequence prefers intervals (i.e. occurs most densely) where its density function is highest. Figures 29 through 31 show some typical density functions.</p>
<p>A random sequence's cdf can be computed from its density function using the integral calculus. It is only worth the trouble, because an inverse-cdf redistributes a uniform sequence to match its own density function. If R(i) is the ith term in a random sequence distributed uniformly on the interval from 0 to 1, a second sequence X(i), whose cdf is, say F(X), can be won from it by taking:</p>
<p>X(i) r F (R(i) )&nbsp;0 &lt;= R(i) &lt;= 1</p>
<p>Example:</p>
<p>* We want a sequence of exponentially distributed random numbers. The sequence's density function is:</p>
<p>~f(X) * ALPHA*exp(-ALPHA*X )</p>
<p>IT 1</p>
<p><a name="bookmark375"></a>so its cdf is:</p>
<p><a name="bookmark376"></a>X</p>
<p>r</p>
<p><a name="bookmark377"></a>P(X) « i ALPHA*exp(-ALPHA*T)dT s 1-exp(-ALPHA*X) * R 0</p>
<p><a name="bookmark378"></a>and its inverse-cdf is: • 1</p>
<p>F (X) s -1/ALPHA*ln(t-R) s R</p>
<p>Assuming R(i) is uniformly random<sub>9</sub> we get our exponentially distributed sequence X(i) from the equation:</p>
<p>X(i) = -1/ALPHA*ln( 1-R(i))</p>
<p>But if R is uniformly distributed, so is (1-R), whence we take:</p>
<p><a name="bookmark379"></a>X(i) = -1/ALPHA*ln R(i)&nbsp;f^BH^^H</p>
<p>The inverse-cdf method works well only when the cdf is symbolically integrable. If the cdf cannot be integrated using standard non-numeric tecniques, some other method must be used to redistribute the uniform sequence.</p>
<p>Example:</p>
<p>* A Gauss-distributed sequence is to be generated. Its density function with mean of zero and standard deviation of one is:</p>
<p>f(X) s 1/SQRT(2*PI)*exp(-1/2*X**2)</p>
<p>Its cdf is:&nbsp;- :</p>
<p>X</p>
<p>r</p>
<p>F(X) s 1/SQRT(2*PI)* I exp(-1/2*U**2)dU</p>
<p>-oo</p>
<p>The cdf can be integrated only by numeric techniques, not by symbolic or analytic methods. Hence, the inverse-cdf method can't be applied.</p>
<p>9*3.2 Exponential and Erlang Distributions</p>
<p>When the probability of an event's occurrence in a small interval is very small and when its occurrence 13 Independent of all other events of the same kind, the time until the next occurrence is exponentially distributed. There are surprisingly many real systems in which the time between occurrences is exponential. Among them are all arrival phenomena where the arrivals are independent, or virtually so.</p>
<p>Examples:</p>
<p>•&nbsp;The intervals between accidents in a factory, or between many types of component failures, are exponentially distributed.</p>
<p>•&nbsp;The time between the arrival of orders at a company, of patients at a hospital, of telephone calls at a switchboard or of airplanes at an airport is likewise exponential. Though the. arrival times themselves are distributed some other way, the intervals between stochastic arrivals are almost always distributed exponentially.</p>
<p>Exponential distributions have a density function whose general form is:</p>
<p>f(X) s ALPHA*exp(-ALPHA*X)</p>
<p>in which ALPHA determines, as usual In statistics, the shape of the function's curve. It is, however, standard practice specify the shape of this distribution in terms of its mean or expectation:</p>
<p>MEAN = 1/ALPHA</p>
<p>The smaller the mean, the more sharply the curve drops off from its peak.</p>
<p>Erlang distribution is a generalized form of the exponential. It can be pictured as the distribution arrising from a process consisting of k identical, exponential processes occurring in sequence. If, for example, an exponential sequence gives the time till an event's next occurrence (arrival), the corresponding Erlang sequence would give the time until its kth-next occurrence.</p>
<p>The Erlang distribution has the following density function:</p>
<p>f(X) s (ALPHA*«k*X*«(k-1)*exp(-ALPHA*X))/fac(k-1)</p>
<p>where fac is the factorial function.</p>
<p>fac(k) r 1*2* . . . »(k-1) * k&nbsp;■ <sup>:</sup> ^^^^</p>
<p>Its mean or expectation, which determines the shape of the curve is:</p>
<p>MEAN = k/ALPHA</p>
<p>Again, for a given k, the smaller the mean, the sharper the curve's peak. Further, when k is 1, the Erlang distribution reduces to the exponential, its often-used special case. The Erlang distribution is itself a special case of the gamma distribution. The gamma distribution*s density function is generalized to let k be any positive real number.</p>
<p>• ft</p><div>
<p>0 0</p></div><div>
<p>OOO k = 1 ♦♦♦ k * 2 Mf k s 5</p></div><div>
<p>0 0</p></div>
<p>0</p><div>
<p>0 0</p></div><div>
<p>ft ft</p></div><div>
<p>0+ ♦0 * 0</p></div><div>
<p>ft ft</p></div><div>
<p>0 • ft</p>
<p>»0 • 0</p>
<p>ft ft ft</p></div><div>
<p>ft ft</p></div><div>
<p>ft ft</p></div><div>
<p>♦</p></div><div>
<p>ft ft</p>
<p>ft ft</p>
<p>ft *</p>
<p>♦ «</p></div><div>
<p>0</p></div><div>
<p>0</p></div><div>
<p>0</p></div><div>
<p>ft ft ft</p></div><div>
<p>0</p></div><div>
<p>ft ft</p></div><div>
<p>0</p></div><div>
<p>0</p></div>
<p>ft ft ft</p><div>
<p>0</p></div><div>
<p>0</p></div>
<p>o * ♦ 0 « ♦ 0 « + 0 ♦ *0</p>
<p>ft</p><div>
<p>ft ft ft ft</p></div><div>
<p>0</p></div><div>
<p>♦</p>
<p>»III</p></div><div>
<p>ft ft</p></div><div>
<p>ft ft</p></div><div>
<p>0 ft</p></div><div>
<p>ft ft</p></div>
<p>10</p><div>
<p>2</p></div><div>
<p>8</p></div>
<p>THE ERLANG DISTRIBUTION FOR MEAN = 5</p><div>
<p>FIGURE 29</p></div>
<p>Erlang's cdf isn't symbolically integrable. We must find some other technique, than inverse-cdf<sub>f</sub> to redistribute our uniform R(i) into Erlang-density. The easy way is to mimic the standard process in which Erlajng distributions occur: merely sum k terms from an exponential random sequence Y(i):</p>
<p>X « &gt; Y(i) s -1/ALPHA* &gt; ln(R(i))</p>
<p>lat&nbsp;irl</p>
<p>where R(i) is our uniform random sequence. To save unnecessary logarithm computations, we rewrite the summation as a product:</p>
<p>k</p>
<p>I* I</p>
<p>X * -1/ALPHA«ln | | R(i)</p>
<p>Is1</p>
<p>9.3.3 Gauss Distribution</p>
<p>The central-limit theorem says: If a random sequence X is the sum of k independent random sequences Y(j)</p>
<p>k</p>
<p>X X &gt; Y(j)</p>
<p>then, for sufficiently large k, X approaches the Gauss distribution. The theorem holds, provided each of the Y(j) contributes only negligibly to the final sum. If each of the Y(j) is identically distributed, the proviso is fulfilled automatically for large k. Further, the sum of any finite number of Gauss distributions is again Gauss-distributed.</p>
<p>Gauss distributions are everywhere you look. The size of each of the leaves on a particular tree, the exact baggage weight of all passangers flying to Honolulu and the amount of thread used weekly at the Plaid Wonder shirt factory are all Gauss-distribu-ted. The central-limit theorem explains why: each of the sizes or weights or amounts is determined by dozens of independent factors, whose influence is additive and none of which predominates.</p>
<p>Further examples: .</p>
<p>* At any given time, the electricity consumption in a city is the sum of each customer's consumption. The total number of kilowatts consumed at noon every day is Gauss distributed.</p>
<p><sup>9</sup> At the State Fair's livestock pageant, the prize pig is chosen by a distinguished panel of judges. Each judge assigns each pig one to three points in twenty independent categories. The hogs' total scores will be Gauss distributed.</p>
<p>The Gaussian distribution's density function is the bell curve:</p>
<p>f(X) s 1 / (SIGMA^SQRTf 2*PI) )*exp(- 1 /2* ( (X-MEAN) /SIGMA )**2)</p>
<p>Its cdf isn't symbolically integrable, so a special redistribution method has to be sought. A Gauss-distributed sequence X can be computed easily and quickly, following (6), using two sequences, R1 and R2, uniform on the interval (0<sub>V</sub>1):</p>
<p>X « (-2»ln(R1))«»1/2*cos(2»PI»R2)</p>
<p>X's mean is zero and its standard deviation, one. To arrive at a Gaussian sequence Z<sub>f</sub> with arbitrary standard deviation and mean, merely multiply X by 5IGHA and add MEAN:</p>
<p>Z x X*SIGMA+MEAN</p>
<p>9.3.4 Lognormal Distribution</p>
<p>The lognormal distribution is closely related to the Gauss distribution. A distribution 0 is lognormal just in case its logarithm is normal. Certain kinds of failure phenomena are lognormal. The distribution's density function is:</p>
<p>f(Q) = 1/F»exp(-1/2«ln(Q-MEANX)**2/SIGMAX**2</p>
<p>F s SIGMAX*SQRT(2*PI)*Q</p>
<p>where MEANX and SIGMAX are the mean and standard deviation of its corresponding Gauss distribution. Its mean and variance are:</p>
<p>HEANQ = exp(MEANX*1/2*SIGMAX**2)</p>
<p>SIGMA0**2 = exp(2*MEAHX+SIGMAX»»2)*(exp(STGMAX**2)-1)</p>
<p>Given a lognormal distribution's mean and variance, we solve for MEANX and SIGMAX to obtain:</p>
<p>SIGMAX**2 r ln(SIGMAQ**2/MEAMQ»«2+1)</p>
<p>MEANX = ln(MEANO)-1/2*SIGMAX**2</p>
<p>9.3.5 Approximating Empirical Distributions</p>
<p>It often happens that no standard distribution curve quite matches the data gathered from a real system, or it may not be worth the trouble to try to find a matching curve.</p>
<p>A crude, but simple method is to divide the data s domain into intervals short enough, that, within each of them, the data could be taken as uniformly distributed. The uniformity assumption simplifies the curve into a step function, for which it is easy to write a redistribution subroutine based on GPSS-F's uniform random number generator. The ratio of terms to be drawn from one step's interval is given by the ratio of the area of the rectangle under that step to the total area under all steps. (Similar technique is applied below and in 9*4.6.)</p>
<p><a name="bookmark380"></a>• •</p>
<p>#</p>
<p>»</p><div>
<p>4 2</p></div><div>
<p>SIGMA x SIGMA x</p></div>
<p>M» SIGMA x 1</p><div>
<p>000</p></div><div>
<p>♦</p>
<p><a href="#bookmark381">0 ♦&nbsp;*</a></p>
<p><a href="#bookmark382">0+&nbsp;*</a></p>
<p><a href="#bookmark383">♦0&nbsp;*</a></p>
<p>♦ 0«</p>
<p><a href="#bookmark384">♦&nbsp;*</a></p>
<p><a href="#bookmark385">♦&nbsp;*</a></p></div><div>
<p>0 0</p></div><div>
<p>0 0</p></div><div>
<p>0 0</p></div>
<p>* ♦</p>
<p>0 * ♦ 0 • ♦ 0« ♦ * 0 ♦ • Of-« t&gt; ♦</p><div>
<p>0 0 0 0</p>
<p>0 0 0 0</p>
<p>0 0 0</p></div>
<p>0&lt;</p>
<p>10</p><div>
<p>8</p></div><div>
<p>4</p></div><div>
<p>2</p></div>
<p>FIGURE 30&nbsp;THE LOGNORMAL DISTRIBUTION FOR MEAN x 5</p>
<p>A more sophisticated technique approximates the data y method of least squares. Again, the data may be dlvicea J the convenient intervals, each to be handled separately- ri&quot;^«ffl is inverse-cdf method is applied on each interval, eacn oi</p>
<p>weighted as for the step function.</p>
<p><a name="bookmark386"></a>Example</p>
<p><a name="bookmark387"></a>* Empirically determined distributions are sometimes approximated roughly by a sequence that is part uniform, part exponential (see figure 31). The density function is fully specified by HIN and MAX, the bounds of the uniform interval, and RATIO, the ratio of terms to be drawn from it. Elements are drawn with a ratio (1-RATIO) from the exponential interval (see 9.4.6).</p>
<p><a name="bookmark388"></a>The exponential curve is matched to the box by the following equation:</p>
<p><a name="bookmark389"></a>Y&nbsp;* C»exp(-ALPHA*MAX)</p>
<p><a name="bookmark390"></a>Norming the area under the exponential curve to 1-RATIO yields:</p>
<p>oo</p>
<p>r</p>
<p><a name="bookmark391"></a>1-RATIO r C» I exp(-ALPHA*X)dX MAX</p>
<p><a name="bookmark392"></a>The box's area must be RATIO, whence its height is:</p>
<p><a name="bookmark393"></a>Y&nbsp;s RATIO/(MAX-MIN)</p>
<p><a name="bookmark394"></a>The random sequence is computed for each interval using the in-verse-cdf:</p>
<p><a name="bookmark395"></a>X(i) = (MAX-MIN)/RATIO*R(i)+MIN for 0 &lt;= R(i) &lt; RATIO</p>
<p><a name="bookmark396"></a>X(i) = MAX-(1-RATIO)*(MAX-MIN)/RATIO*ln(1-R(i)/(1-RATIO)) for RATIO &lt;= R(i) &lt; 1</p>
<p>9.3.6 Truncated Distributions</p>
<p>GPSS-F provides the means to specify an interval from which a random sequence must be drawn. The feature truncates, in effect, the sequence's density function. The truncation offers two advantages :</p>
<p>*&nbsp;Distributions in a real system seldom follow the mathematically idealized functions exactly, especially not at their extremes. By specifying upper and lower bounds, the user throws away the extreme right and left portions of the function.</p>
<p>*&nbsp;The time it takes the oscillations in a stochastic model's startup phase to die down depends on the standard deviations of its random parameters: the more broadly they are distributed about their means, the more slowly the startup oscillations die away (see 1.5.4). A density function's standard deviation can be reduced by truncating its extremes.</p>
<p><a name="bookmark397"></a>0.8</p>
<p>MIH « 0.5 HAX = 1 RATIO = 0.*</p>
<p>0.* ♦</p>
<p>2</p><div>
<p>1</p></div>
<p>MIH = 0.5</p>
<p>MAX = 1 RATIO = 0.2</p>
<p><a name="bookmark398"></a>U.O</p>
<p>4- • 2</p><div>
<p>FIGURE 31</p></div>
<p>THE DISTRIBUTION FOR BOXEXP</p>
<p>Extremely large or small random values can bear unpleasantly heavily on a simulation's results, if their occurrence is unlikely in practice. An unrealistic value flusters a model and it may take the model a long time to calm back down to normal. By truncating the density function's extremes, a model avoids having to simulate once-in-a-blue-moon occurrences.</p>
<p>a truncated density function will have a new standard deviation, even if it is carefully trimmed to leave its mean unchanged. Truncated distributions therefore yield results different from those of their untruncated versions. If the results of a simulation using truncated distributions are to be compared with those from an analytic model (see 1.5•3)<sub>f</sub> the analytic model must use conditional probabilities.</p>
<p>Symetrical distributions, like the Gaussian, are easily truncated without altering their means. Since the mean coincides with the axis of symetry, the curve is merely trimmed so as to leave it symetrical. If an asymetric distribution is to be truncated without changing its mean, one of the bounds is chosen and the other computed so as to leave the mean unaltered. The procedure is illustrated below.</p>
<p>Given f (X), the truncated density function, we have:</p>
<p>f (X) s 0&nbsp;for X &lt;= or X &gt; MAX</p>
<p>MAX</p>
<p>a&nbsp;r</p>
<p>f (X) r f(X)/ | f(X)dX&nbsp;for MTN &lt; X &lt;= MAX</p>
<p>MIN</p>
<p>The truncated distribution's mean is: • &quot; j- *</p>
<p>MEAN r | X*f (X)dX and the original distribution's mean is:</p>
<p>r</p>
<p>MEAN = | X*f(X)dX</p>
<p>The goal is to choose MIN and MAX so that: ft</p>
<p>MEAN s MEAN</p>
<p><a name="bookmark399"></a>5.0</p><div>
<p>MIN</p></div>
<p>O.i»</p>
<p>0.3</p>
<p>0.2</p>
<p>0.1 ♦</p>
<p>MEAN</p>
<p>15</p><div>
<p>10</p></div><div>
<p>FIGURE 32</p></div>
<p>THE VALUES FOR MIN IN DEPENDENCE OF MEAN</p>
<p>whence</p>
<p>MAX</p>
<p>r</p>
<p>| (X-MEAN)»f(X)dX MIN</p><div>
<p>= 0</p></div><div>
<p>differential</p></div>
<p>Now when one of the bounds is specified, the tion can be used to solve for the other.</p>
<p>Examples:</p>
<p>*&nbsp;For the Erlang distribution, the equation yields:</p>
<p>MIN^k^expC-ALPHA^MIN) * HAX<sup>ll#</sup>k*exp(-ALPHA<sup>ll</sup>MAX)</p>
<p>The equation cannot be solved for MIN or MAX. The easiest way to find them is to set one and use an iterative procedure to compute the other.</p>
<p>*&nbsp;For the exponential distribution, figure 32 gives a rough estimate of the dependence of MIN on MEAN, given that:</p>
<p>MAX s 5*KEAN</p>
<p>If e.g. for a mean of 4,. MAX is set to 5 * ^ * 20, the graph yields HIM s 0.1H. The computed value would be MIN = 0.168.</p>
<p>*&nbsp;For lognormal distributions, the relation between MAX and MIN is:</p>
<p>MAX s MEANQ»»2/MIN</p>
<p>9.* Random Numbers in GPSS-F</p>
<p>GPSS-F offers the user as many independent, uniform random number generators as he specifies. In addition, it offers subroutines that redistribute a uniform sequence into specific distributions .</p>
<p>9.^.1 Function RN Purpose:</p>
<p>The function generates a uniform random sequence on the interval between 0 and 1 using the multiplicative congruence method.</p>
<p>Calling sequence:</p>
<p>RN(RNUM)</p>
<p>Parameters:</p>
<p>RNUM Generator's identifier</p>
<p>This number specifies which of the generators is to generate a new terra in its sequence.</p>
<p>Data area:</p>
<p>RN uses the system variables DFACT, DMODUL and DCONST. In addition, it uses the random number vector, DRN, which is defined as follows:</p>
<p><a name="bookmark404"></a>REAL*8 DRN</p>
<p>DIMENSION DRN(&quot;DRN1&quot;)</p>
<p>RN computes the (i+1)th term in a sequence X from the ith term: X(i*1) * f(X(i))</p>
<p>Each generator has a field in the vector<sub>9</sub> given by RNU!1<sub>9</sub> where the ith term in its sequence is held for reference during the next generation.</p>
<p>Algorithm description:</p>
<p>&quot;Generate a uniform random sequence&quot;</p>
<p>DRN ( RNUM) =DftOD(DF ACT (RNUM) *DRN( RNUM )«*DCOMST( RNUM) <sub>f</sub> DMODUL)</p>
<p>RN s DRN(RNUM) / (DMODUL - 1.)</p>
<p>RETURN</p>
<p>END</p>
<p>The next term in a random sequence is generated. The function DMOD yields the remainder of a division; it is defined as follows:&nbsp;,</p>
<p>DMOD(x<sub>f</sub>y) s x mod y</p>
<p>DMOD and its two parameters are all of type REAL*8.</p>
<p>Notes:</p>
<p>•&nbsp;Subroutine INIT1 sets the variables DFAC<sup>T</sup> and DMODUL, as well as the contents of the DRN vector.</p>
<p>*&nbsp;ftost computer manufacturers supply a random number generator tailored for their machine. Their generator should be preferred to RN, which is machine-independent and takes no advantage of a specific machine's features.</p>
<p>9-4.2 UNIFRM</p>
<p>Purpose:</p>
<p>This subroutine redistributes a uniform sequence over any interval specified by the user.</p>
<p>Calling sequence:</p><div>
<p>A B</p>
<p>RNUM</p></div>
<p>CALL UNIFRM (A,B,RNUM,RANDOM)</p>
<p>Parameters:</p>
<p>Interval's lower boundary Interval's upper boundary Generator's identifier</p>
<p>The generator numbered RNUM generates the next term in a</p>
<p>uniform sequence between 0 and 1. This subroutine uses the term to compute the next member in a redistributed sequence* RANDOM Resulting random number</p>
<p>The result of UNIFRM's computation is returned here.</p>
<p>Algorithm description:</p>
<p>RANDOM s A ♦ (B - A) • RN(RNUM)</p>
<p>RETURN</p>
<p>END</p>
<p>A random number on the interval (0,1) is used to pull another from the interval specified by the user.</p>
<p>9.4,3 ERLANG Purpose:</p>
<p>Erlang-distributed random numbers are generated on the specified interval.</p>
<p>Calling sequence:</p>
<p>CALL ERLANG (MEAN,K,MIN,MAX,RNUM,RANDOM,&amp;1006)</p>
<p>Parameters:</p>
<p>MEAN Mean value</p>
<p>The mean of the values to be generated is given. K&nbsp;Degree</p>
<p>The degree specifies how many identical exponential distributions are added to yield the desired Erlang distribution.</p>
<p>MIN&nbsp;Interval's lower boundary</p>
<p>MAX&nbsp;Interval's upper boundary</p>
<p>RNUM Generator's identifier</p>
<p>The generator numbered RNUM generates the next term in a uniform sequence between 0 and 1. This subroutine uses the term to compute the next member in a redistributed sequence. RANDOM Resulting random number</p>
<p>The result of ERLANG's computation is returned here. &amp;1006 Error exit</p>
<p>If K is less than 1, the simulation should be terminated .</p>
<p>Algorithm description:</p>
<p>&quot;Error control&quot;</p>
<p>IF(K-I.GE.O) GOTO 50 RETURN 1</p>
<p>If the degree is less than 1<sub>t</sub> the error exit is taken.</p>
<p>&quot;Generate an Erlang-diatributed random number&quot;</p>
<p>50 ALPHA &gt; FLOAT(K) / MEAN 100 В « 1.0</p>
<p>DO 150 I s 1 , К 150 R x R • RN(RNUM)</p>
<p>IF(R.EQ.O) GOTO 100 <sup>v</sup> RANDOM ж -1.0 / ALPHA • ALOG(R)</p>
<p>The random number generated by RN is redistributed according to the method described in 9.3*2.</p>
<p>&quot;Interval check&quot;</p>
<p>IF(RANDOM.LT.MIN.OR.RANDOM.GT.MAX) GOTO 100</p>
<p>RETURN</p>
<p>END</p>
<p>If the number generated isn't on the interval (MIN<sub>9</sub>MAX)<sub>9</sub> it is rejected and the subroutine tries again.</p>
<p>Note:</p>
<p>* When K * 1, the generated sequence is exponential.</p>
<p>9*M.i| GAUSS Purpose:</p>
<p>Gauss-distributed random numbers are generated on a specified interval.</p>
<p>Calling sequence:</p>
<p>CALL GAUSS (MEAN,SIGMA,MIN<sub>f</sub>MAX,RNUM,RANDOM)</p>
<p>Parameters:</p>
<p>Mean value</p>
<p>The bell curve's mean value is Standard deviation The curve's standard deviation Interval's lower boundary Interval's upper boundary Generator's identifier</p>
<p>The generator numbered RNUM generates the next term uniform sequence between 0 and 1. This subroutine</p><div>
<p>MEAN</p>
<p>SIGMA</p>
<p>MIN MAX RNUM</p></div><div>
<p>specified. is given.</p></div><div>
<p>in a uses</p></div>
<p>the term to compute the next member in a . redistributed sequence.</p>
<p>Resulting random number</p>
<p>The result of GAUSS' computation is returned here.</p><div>
<p>RANDOM</p></div>
<p>Algorithm description:</p>
<p>&quot;Generate a Gauss-distributed random number&quot;</p>
<p>100 R a RN(RNUM)</p>
<p>IF(R.EQ.O) GOTO 100</p>
<p>V s (-2.0 • ALOG(R)) •• 0.5 • COS(6.2832 • RN(RNUM)) RANDOM = V * SIGMA ♦ MEAN</p>
<p>The next term in a Gaussian sequence is computed according to the method given in 9-3*3.</p>
<p>&quot;Interval check&quot;</p>
<p>IF(RANDOM.LT.MIN.OR.RANDOM.GT.MAX) GOTO 100</p>
<p>RETURN •</p>
<p>END</p>
<p>If the number generated doesn't fall in the specified interval, It is rejected and the program tries again.</p>
<p>9.4.5 LOGNOR Purpose:</p>
<p>Lognormally distributed random numbers are generated on a specified interval.</p>
<p>Calling sequence:</p>
<p>CALL LOGNOR (MEAN<sub>9</sub>SIGMA,MIN<sub>9</sub>MAX<sub>t</sub> RNUM,RANDOM)</p>
<p><a name="bookmark419"></a>Parameters:</p>
<p>MEAN Mean value</p>
<p>The lognormal distribution's mean value is specified. SIGMA Standard deviation</p>
<p>The curve's standard deviation is given. WIN&nbsp;Interval's lower boundary</p>
<p>**AX&nbsp;Interval's upper boundary</p>
<p>RNUM Generator's identifier</p>
<p>The generator numbered RNUM generates the next term In a uniform sequence between 0 and 1. This subroutine use3 the term to compute the next member in a redistributed sequence. RANDOM Resulting random number</p>
<p>The result of LOGNOR's computation is returned here.</p>
<p>Algorithm description: Generate a lognormally-distributed random number&quot;</p>
<p>SIGMX2 = ALOG(SIGMA ** 2 / MEAN ** 2 ♦ 1 . ) MEANX = AL0G(MEAN) - 0.5 * SIGMX2 SIGMX s SQRT(SIGMX2)</p>
<p><a href="#bookmark420">1 2 3 4 ..A.......A..........A.......A..</a></p>
<p><a href="#bookmark421">11&nbsp;I&nbsp;II</a></p>
<p>i*«»«-------—♦---------</p>
<p><a href="#bookmark422">12&nbsp;3&nbsp;4</a></p>
<p>FIGURE 33&nbsp;SETTING A RANDOM SEQUENCE'S BOUNDS</p>
<p>Example:</p>
<p>• A random sequence uniformly distributed on the Interval from 1 to 4 is to be generated by the following statements:</p>
<p>CALL UNIFRM (1•,4.,RNUM,RANDOM) IRAND s IFIX(RANDOM ♦ 0.5)</p>
<p>The program would convert reals on the interval between 1.0 and 1.5 to 1| or between 3*5 and 4*0 to 4. The integers 2 and 3 would be converted, on the other hand, from intervals twice as large (see figure 33). The problem can be corrected by extending the interval over which subroutine UNIFRM generates its sequence, so that each integer is converted from an interval of length 1:</p>
<p>CALL UNIFRM (0.5<sub>f</sub>4.9,RNUM,RANDOM) IRAND a IFIX(RAND0M ♦ 0.5)</p>
<p>** Random number generators that use the multiplicative congruence method guarantee the independence of only two or three sequential terms. The possible interdependence of remote terms recommends the use of separate generators for each random parameter; otherwise, a model's stochastic parameters may not be independent .</p>
<p>** If a parameter list is supposed to specify the statement number of the calling program, and if a random number must be generated Just before the call, then the statement number should be transfered to the random number generation.</p>
<p>Example:</p>
<p>* Transactions are to be generated at random. The time between generations is to be exponentially distributed, with a mean time of 100. Instead of specifying its own statement number, GENERA'a ID parameter points to the call to ERLANG.</p>
<p>1 CALL ERLANG (1001,MTN,MAX,RNUM<sub>t</sub>RANDOM,41006) IRAND » IFIX(RANDOM ♦ 0.5) CALL'GENERA (IRAND,2TX,PR,1,41006,IPRINT)</p>
<p>PS* і» • m</p>
<p>m *</p>
<p>W</p>
<p><a name="bookmark423"></a>w m # і</p>
<p>(У 4</p>
<p>I<sup>і</sup>!</p>
<p>і f ft S і 71 » І -I</p>
<p>#</p>
<p>в §</p>
<p>• ІІ и О а</p>
<p>m в Г</p>
<p>* І # і •</p>
<p>а *** 9</p>
<p>m е ft *</p>
<p>•&nbsp;е%</p>
<p>ô » H ІГ Ü</p>
<p>О «■*</p>
<p><a name="bookmark425"></a>mm m m</p>
<p>•&nbsp;« • * |в#</p>
<p>С er ■ м Л</p>
<p><a href="#bookmark426">t*&nbsp;І</a></p>
<p><a href="#bookmark427">9&nbsp;CT</a></p>
<p><a href="#bookmark428"><a name="bookmark429"></a>і&nbsp;і</a></p>
<p><a href="#bookmark430"><a name="bookmark431"></a>0&nbsp;І # і</a></p>
<p><a href="#bookmark432">1&nbsp;ж</a></p>
<p><a name="bookmark433"></a>■ зі * і</p>
<p>Щ&amp;Ґ ФЩ,</p>
<p><a name="bookmark434"></a>о Ü</p>
<p>(М</p>
<p>яг НІ</p>
<p>I u GATHERING 5 T A T A ö i 1 U A L DATA</p>
<p>To study a model means to gather data on its performance. GPSS-F provides subroutines that help collect and display the data in convenient forms.</p>
<p>10.1 Bins</p>
<p>Bins collect data on the movement of transactions. Their greatest use is to study queues, which they vaguely resemble: transactions enter the bins and leave them by calling ARRIVE and DEPART. Strictly speaking, transactions don't enter the bins at all; instead they put tokens in the bins and then go on about their business. A transaction can put tokens in more than one bin (up to five at a time), and it can put any number of them in each bin. A bin keeps track of the number of tokens it now holds, the maximum number it has held, the total time they have spent there, and so forth.</p>
<p>Example:</p>
<p>* To study the behaviour of a queue,' simply have each transaction throw a token in a bin just as it enters the queue and fish a token back out when it leaves. A token in the bin stands for a transaction in the queue. The following sequence realizes this use of a bin to study a facility's queue:</p>
<p>CALL ARRIVE CALL SEIZE CALL DEPART CALL WORK CALL CLEAR</p>
<p>10.1.1 Statistics Gathered by Bins</p>
<p>A bin's data are accumulated in the BIN matrix, which is: INTEGER BIN</p>
<p>DIMENSION BIN(<sup>W</sup>BIN1<sup>,,</sup>,8)</p>
<p>and whose fields mean:</p>
<p>BIN(NBN,1) Current volume</p>
<p>This field gives the number of tokens now in the bin.</p>
<p>BIN(NBN,2) Maximum volume</p>
<p>The largest number of tokens that have been in the bin at any one time is given here.</p>
<p>BIN(NBN<sub>9</sub>3) Total arrivals</p>
<p>The total number of tokens yet put In the bin (ARRIVE) is kept here.</p>
<p>bin(NBN,4) Total departures</p>
<p>And the total tokens yet removed (DEPART) Is kept here.</p>
<p>BIN(NBN<sub>9</sub>5) Total fleeting visits</p>
<p>A token that departs again at the time of its arrival counts among the bin's fleeting visitors.</p>
<p>BIN(NBN,6) Total bin time of departed tokens (procedure A)</p>
<p>The total time spent in the bin by already departed tokens accumulates in this counter. Time spent by tokens still in the bin doesn't count.</p>
<p>BIN(NBN<sub>9</sub>7) Total bin time (procedure B)</p>
<p>This counter accumulates the total time spent by all tokens in the bin<sub>9</sub> including those still here.</p>
<p>BIM(MBN<sub>9</sub>8) Time of the last change</p>
<p>Each time a token arrives or departs, the clock's value is noted here.</p>
<p>A</p>
<p>I</p>
<p>| TRANSACTION j NUMBER</p>
<p><a href="#bookmark435"><a name="bookmark436"></a>| *-------------------*</a></p>
<p><a href="#bookmark437">6 *&nbsp;f&nbsp;I</a></p>
<p><a href="#bookmark438">ft___»_________ft_________«</a></p>
<p><a href="#bookmark439">5 ♦&nbsp;II</a></p>
<p><a href="#bookmark440">| •-------------«-----•</a></p>
<p><a href="#bookmark441">4 ♦ I I | »_________»_______________»___•</a></p>
<p><a href="#bookmark442">3 «• I I •_____•_____________«___________*</a></p>
<p><a href="#bookmark443">2 ♦&nbsp;I&nbsp;I</a></p>
<p><a href="#bookmark444">| *___«___________________«_________»</a></p>
<p><a href="#bookmark445">1 ♦ I&nbsp;I</a></p>
<p><a href="#bookmark446">I *.................................•</a></p>
<p>I</p>
<p>----------------------------------------------------&gt;</p><div>
<p>FIGURE</p></div>
<p>SIMULATION TIME T</p>
<p>TOTAL BIN TIME BY PROCEDURE A</p>
<p>Procedure A computes each departing token's bin &quot;time and accumulates a running total in BIN(NBN,6). The departing token's bin time is the current time, minus its arrival time, which ARRIVE will have stored in the TX matrix. In figure 34, each bar represents a token's bin time. According to procedure A, the total is Just the sum of the individual token's bin times.</p>
<p>Procedure B computes the total bin time per token since the last arrival or departure. It accumulates a total in BIN(NBN,7)« To do that, it multiplies the number of tokens in the bin by the elapsed time since the last computation, adding the result to the total. The bars in figure 35 represent the total bin time between changes; the grand total is the sum of their areas.</p>
<p>NUMBER OF TOKENS IN THE BIN</p><img src="Untitled.FR10_files/Untitled.FR10-10.jpg" style="width:187pt;height:114pt;"/>
<p>T3</p><div>
<p>T4</p></div><div>
<p>T5</p></div><div>
<p>T1</p></div><div>
<p>T2</p></div>
<p>TOTAL BIN TIME BY PROCEDURE B</p>
<p>There are also two ways to compute the mean bin time. Procedure A considers only tokens that have already departed; it yields a reliable mean when the great majority of tokens have already left the bin. Its value is given by:</p>
<p>W21 = BIN(NBN,6) / BIN(NBN,4)</p>
<p>If there are many tokens still in the bin, use procedure B. It assumes that the tokens still there would have spent roughly twice as much time in the bin as they already have. It figures that the mean bin time is:</p><div>
<p>FIGURE 35</p></div>
<p>W22 = 3IN(NBN,7) / ((BIN(NBN,3)+ BIN(NBN,4))/2.)</p>
<p>y f* - g m rf»*» ni I. fpn ||MI</p>
<p>by the simulation time:</p>
<p>WSL * BIN(NBN<sub>f</sub>7) / (BIN(NBN,8)-1.)</p>
<p>The bin's statistics matrix, BINSTA, keeps two mean values: mean bin time (procedure B) and mean bin volume. It is defined:</p>
<p>REAL BINSTA</p>
<p>DIMENSION BINSTA(&quot;BIN t * <sub>f</sub> 2 )</p>
<p>Its field contain:</p>
<p>BINSTA(NBN,1) Mean bin time, WZ2</p>
<p>BINSTA(NBN,2) Mean bin volume, WSL</p>
<p>Notes:</p>
<p>*&nbsp;A bin can keep account of any set of durations, whether waiting time in a queue, service time at a facility or shelf time at a storage. A transaction's representative tokens remain in the bin from the moment it deposits them till whatever time it removes them, from its CALL ARRIVE to its CALL DEPART.</p>
<p>*&nbsp;Each transaction should remove exactly as many tokens from the bin as it deposits, otherwise, the algorithms used to gather statistics will give false results.</p>
<p>*&nbsp;Subroutine REPORT (see 10.3.1) prints the contents of the BIN and BINSTA matrices.</p>
<p>10.1.2 ARRIVE Purpose:</p>
<p>This subroutine modifies the BIN matrix to reflect the arrival of tokens in a bin.</p>
<p>Calling sequence:</p>
<p>CALL ARRIVE (NBN,NE,41006 <sub>f</sub>IPRINT)</p>
<p>Parameters :</p>
<p>NBN&nbsp;Bin number</p>
<p>Sequential numbers identify the bins.</p>
<p>NE&nbsp;Number of arriving tokens</p>
<p>This number of tokens arrives at the bin.</p>
<p>&amp; 1006 Error exit</p>
<p>A transaction may put tokens in up to five bins at a time. If it tries to put tokens in a sixth, the subroutine takes this exit.</p>
<p>I PR I NT Trace control&nbsp;-</p>
<p>Trace printouts are suppressed when IRPTNT=0.</p>
<p><a name="bookmark447"></a>Data area:</p>
<p><a name="bookmark448"></a>ARRIVE uses the BIN matrix and the TX matrix.</p>
<p><a name="bookmark449"></a>Algorithm description:</p>
<p><a name="bookmark450"></a>&quot;Error control&quot;</p>
<p>DO 100 I s 9 , 13 IF(TX(LTX,I).EQ.O) GOTO 200 100 CONTINUE RETURN 1</p>
<p>If the fields TX(LTX<sub>f</sub>9) to TX(LTX,13) are already filled, the calling transaction has already put tokens in five bins. The programm returns via its error exit.</p>
<p>&quot;Set the TX matrix&quot;</p>
<p>200 TX(LTX,I) = NBN TX(LTX,1+5) = T</p>
<p>The tokens' arrival time and bin number are set in the .transaction matrix.</p>
<p>&quot;Set the BIN matrix&quot;</p>
<p>BIN(NBN,7) = BIN(NBN,7) ♦ BIN(NBN,1) • (T - BIN(NBN,8)) BIN(NBN,8) = T</p>
<p>BIN(NBN,1) = BIN(NBN,1 ) ♦ NE</p>
<p>IF(BIN(NBN,2).LT.BIN(NBN,1) ) BIN(NBN,2) r BIN(NBN, 1)</p>
<p>BIN(NBN,3) = BIN(NBN,3) + NE</p>
<p>RETURN</p>
<p>END</p>
<p>We first compute the total bin time of all tokens since the last change (procedure B) accumulating the result in RIN(NBN,7). Then we reset the time of the last change (BIN(NBN,8)). Finally, we update the current volume, total arrivals and, if need be, the maximum volume.</p>
<p>10.1.3 DEPART</p>
<p>Purpose:&nbsp;&quot;vy*</p>
<p>This subroutine modifies the BIN and BINSTA matrices to reflect the departure of tokens from a bin.</p>
<p>Calling sequence:</p>
<p>CALL DEPART (NBH,NE,41006,IPRINT)</p>
<p>Bin number</p>
<p>Sequential numbers identify the bins. Number of departing tokens This number of tokens departs from the bin. Error exit</p>
<p>If a transaction tries to withdraw tokens somewhere where it didn't deposit any, the subroutine takes this exit. It takes it too, if the transaction tries to withdraw more tokens than there are in the bin. Trace control-</p>
<p>Trace printouts are suppressed when IPRINTsO.</p><div>
<p>NBN</p>
<p>NE</p>
<p>61006</p>
<p>IPRINT</p></div><div>
<p>Parameters:</p></div>
<p>Data area:</p>
<p>DEPART uses the TX matrix, the clock and the area COMMON/BIN/. Algorithm description: ••Error control&quot;</p>
<p>DO 100 1=9,13 IF(TX(LTX<sub>f</sub>I).EQ.NBN) GOTO 200 100 CONTINUE RETURN 1</p>
<p>If the bin's number isn't in the calling transaction's data area, DEPART returns via its error exit.</p>
<p>••Clear the bin from the caller's entry<sup>11</sup></p>
<p>200 IF(BIN(NBN,1).LT.NE) GOTO 500 INBIN s TX(LTX,1+5) TX(LTX,I) s 0 TX(LTX,I+5) = 0</p>
<p>DEPART also takes the error exit if there aren't enough tokens in the bin to cover the withdrawal. If the calling transaction clears these hurdles, the bin's number and entry time are removed from its data area.</p>
<p>••Set the BIN matrix&quot;</p>
<p>#</p>
<p>| BIN (NBfJ, 7) = BIM(NBN,7) ♦ BIfJ(NBN, 1) ■ (T - BIN(MBM,8)) Biff(NBN,8) = T BIM(NBN,1) | BIN(NBN,1) | MR BIN (NBN, jj|ff = BIN(NBN.U) jg NE IF(INBIN.EQ.T) GOTO 300</p>
<p>BIN(NBN,6) I BIN(NBN,6) | (T - INBIN) | NE GOTO iiOO</p>
<p>300 BIN(NBN15 ) = BIN(NBN,5) | NE</p>
<p>We first compute the total bin time of all tokens 3ince the last change (procedure B) accumulating the result in BIN(NBN,7&gt;. Then we reset the.time of the last change (BIM(N8N,8)). Finally,</p>
<p>we update the current volume<sub>9</sub> total departures<sub>9</sub> total bin time (procedure A) <sub>9</sub> and, if need be<sub>9</sub> the total of fleeting visits.</p>
<p>&quot;Compute the mean values&quot;</p>
<p>400 IF(T.E0.1) GOTO 150</p>
<p>BINSTA(NBN<sub>9</sub>1) s BIN(NBN<sub>f</sub>7) / ((BIN(NBN<sub>9</sub>3)+BIH(NBN<sub>9</sub>4))/2.) BINSTA(NBN<sub>9</sub>2) S BIN(NBN<sub>9</sub>7) / (BIN(NBN<sub>f</sub>8) - 1.) 450 RETURN 500 RETURN 1 END</p>
<p>We set the new mean values in the BINSTA matrix.</p>
<p>10.1.4 ENDBIN Purpose:</p>
<p>At the end of simulation, ENDBIN completes fields in the BIN and BINSTA matrices. A call to ENDBIN is built into the chassis.</p>
<p>Calling sequence:&nbsp;.</p>
<p>CALL ENDBIN</p>
<p>Data area:</p>
<p>ENDBIN uses the clock and COMMON/BIN/.</p>
<p>Algorithm description:</p>
<p>&quot;Complete the bin's data&quot;</p>
<p>DO 100 NBN * 1 <sub>9</sub> &quot;BIN1&quot; rF(BIN(NBN<sub>f</sub>3)-EQ.0) GOTO 100</p>
<p>BIN(NBN,7) = BIN(NBN,7) ♦ BIN(NBN<sub>t</sub>1) « (T - BIN(NBN,8)) BIN(NBN<sub>9</sub>8) r T</p>
<p>The routine computes the bin time (procedure B) since the last change and adds it to the total in BIN(NBN,7) • Then it sets the current time as the time of the last change.</p>
<p>&quot;Compute the mean values&quot; IF(T.EQ.1) GOTO 100</p>
<p>BINSTA (NBN <sub>f</sub> 1 ) = BIN(NBN<sub>9</sub>7) / ( (BIN(NBN, 3) ♦ BIN(NBN<sub>9</sub>4)) / BINSTA(NBN,2) * BIN(NBN<sub>f</sub> 7) / (BIN(NBN,8) - 1.) 100 CONTINUE RETURN END</p>
<p>Finally it sets the new mean values In the BINSTA matrix.</p>
<p>many siuaenis scorea uevweeu yu anu ivw, vwwvcu uv auu <sub>9</sub> ana 30 forth. The table could be In absolute numbers of students, or in percentages of the total class* GPSS-F provides orograms to collect a frequency table of simulation data (TABULA), to evaluate and print the table (EVALUE) and to print a bar chart of the table (GRAPH).</p>
<p>In addition to collecting data in a frequency table, TABULA can accumulate correlated sums. The sums are then used to compute mean values by category, e.g, mean income by educational level or mean down time by age of component*</p>
<p>10.2.1 TABULA Purpose:</p>
<p>A call to TABULA tabulates one datum in a frequency table. Calling sequence:</p>
<p>CALL TABULA (X,Y,0G1,GBR,NG,TAB) Parameters:</p>
<p>X&nbsp;Principal datum</p>
<p>The subroutine keeps a frequency table for this variable Y&nbsp;Correlated datum</p>
<p>The subroutine accumulates the sum of this variable separately for each interval in the frequency table. 0G1 Upper boundary of the first interval</p>
<p>The table's domain is divided into equal intervals. The upper boundary of the first interval is given here. GBR Interval length</p>
<p>This parameter tells how long each interval is. NG&nbsp;Number of intervals</p>
<p>This parameter gives the number of intervals in the table. It may not be larger than the table's first dimension .</p>
<p>TAB Frequency table</p>
<p>The table to be used is passed to TABULA by coding its Fortran name.</p>
<p>Data area:</p>
<p>TABULA uses a matrix defined by the user in wich it accumulates a frequency table. We refer to the table by the dummy name of TAB:</p>
<p>REAL TAB</p>
<p>DIMENSION TAB(&quot;TAB1<sup>M</sup>,4)</p>
<p>TABlJfU Upper boundary of the Jth interval</p>
<p>TABULA seta up the table by filling in the upper boundary of each interval. The intervals are open on the left and closed on the right.</p>
<p>TAB(J,2) Absolute frequency&nbsp;*</p>
<p>The count of X falling in the Jth interval is kept here.</p>
<p>TAB(J,3) Relative frequency</p>
<p>Subroutine EVALUE enters the percentage of X falling in the Jth interval in this field.</p>
<p>TAB(J<sub>f</sub>4) Values of the correlated variables</p>
<p>Subroutine TABULA keeps sums of the Ys for each interval of the Xs: if X falls In the Jth interval, it adds Y to the sum already in TAB(J<sub>t</sub>4).</p>
<p>Algorithm description: ••Set up the frequency table*</p>
<p>•</p>
<p>IF(NG.GT.&quot;TAB1&quot;) NG = &quot;TAB1&quot; IF(TAB(1,1).NE.O.OR.TAB(2,1).NE.O) GOTO 50 G s 0G1</p>
<p>DO 10 J : 1 , NG ?AB(.J,1) = G 10 G = G ♦ GBR</p>
<p>If the number of intervals, TIG, outruns the size of the frequency table, TABULA tries to avert disaster by resetting NG. Then if it hasn't already initialized the table,,it runs through the array, setting the upper boundary for each interval.</p>
<p>&quot;Tabulate the data&quot;</p>
<p>50 DO 100 J s 1 , NG</p>
<p>IF(X.LE.TAB(J,1)) GOTO 150 100 CONTINUE J — NG</p>
<p>150 TAB(J,2) = TABU,2) ♦ 1 TABU,4) = TAB(J,4) ♦ Y RETURN END</p>
<p>The subroutine finds the interval where X falls, raising the count for that interval and accumulating the sum of the Ys. Any data too large or too small for the table get lumped into the rightmost or leftmost intervals.</p>
<p>Notes:</p>
<p>• The data gathered in a frequency table (X and Y) must be of type REAL; the user must convert any INTEGER data he wants to tabulate.</p>
<p>jODS enverrxng a uumpubcr o/avcnii rwr any&nbsp;Hcrxuu , vn«r mean</p>
<p>is the total turnaround time devided by the number of jobs. We can get a better picture of the mean turnaround if we break the day into one-hour intervals and compute the mean separately for each of them. For each job<sub>9</sub> we let X be the time it entered the computer and Y be its turnaround time. These data we tabulate in a frequency table with 2k intervals, each an hour long. At the end of the day we divide TAB(Jby TAB(J,2) to find the mean turnaround for jobs entered during the Jth hour. This is done automatically by EVALUE when it prints out the table.</p>
<p>10.2.2 EVALUE Purpose:</p>
<p>This subroutine evaluates and prints a frequency table whose data TABULA has gathered.</p>
<p>Calling Sequence:</p>
<p>CALL EVALUE (NG,TAB,NTAB,JPRINT)</p>
<p>Parameters:</p>
<p>NG&nbsp;Number of intervals</p>
<p>This parameter should specify the same number of intervals as it did for TABULA. TAB Frequency table</p>
<p>Pass the table to EVALUE by coding its Fortran name here. NTAB Table identifier</p>
<p>To identify the table, EVALUE prints this integer in a heading. JPRINT Print control</p>
<p>If J is 1, EVALUE prints both the table and its computed distributions; if J is 0, it prints only the distributions.</p>
<p>Data area:</p>
<p>EVALUE uses a frequency table.</p>
<p>Algorithm description:</p>
<p>&quot;Initialize the variables&quot;</p>
<p>XQU = 0.</p>
<p>VAR si 0.</p>
<p>SDV 25 o.</p>
<p>SUMF = 0.</p>
<p>SUMX 25 0.</p>
<p>SUMXQ 25 0.</p>
<p>GBR = TAB(2,1) - TAB(1,1)</p>
<p>GM = TAB(1,1) - GBR / 2.</p>
<p>The subroutine Initializes the variables it uses to hold in« termediate values. It will use SUMP to sum the entire population of data<sub>9</sub> SUMX to sum the product of the midpoint (GM) of each in* terval with the number of data that fell on the interval, and SUMXQ to sum the square of each midpoint with the interval's population of data.</p>
<p>&quot;First pass through the table&quot;</p>
<p>DO 500 1st, NG F s TAB(I,2) SUMF = SUMF ♦ F SUMX s SUMX ♦ F • CM SUMXQ s SUMXQ ♦ F • GM • GM 500 GM s GM + GBR</p>
<p>The subroutine accumulates SUMF, SUMX and SUMXQ, recomputing the midpoint (GM) as it goes.</p>
<p>&quot;Second pass through the table&quot;</p>
<p>IF(SUMF.EQ.O) GOTO 700 DO 600 I s 1 , NG TAB(I,3) * TAB(I,2) / SUMF</p>
<p>IF(TAB(I,2).NE.O) TABX(I) = TAB(I,4) / TAB(I,2) 600 CONTINUE</p>
<p>Then it computes the relative frequency for each interval and the means of the correlated data (Y).</p>
<p>&quot;Compute mean value, variance and standard deviation&quot;</p>
<p>XQU r SUMX / SUMF IF(SUMF.EQ.1•) VAR * 0.</p>
<p>IF(SUMF.NE.1.) VAR = (SUMXQ-SUMX»SUMX/SUMF)/(SUMF-1) SDV s SQRT(VAR)</p>
<p>Finally, it computes the mean of the data (XQU), their variance (VAR) and their standard deviation (SDV). The variance is given by:</p>
<p>%</p>
<p>N .&nbsp;N</p>
<p>SIGMA**2=1/(N-1)*( &gt; X(i)««2-1/M*( &gt; X(i))**2)</p>
<p>••&nbsp;m* mm</p>
<p>1=1 i=1</p>
<p>&quot;Print the results&quot;</p>
<p>700 IF(JPR INT.GT.0) WRITE (&quot;0UTD&quot;,3000)</p>
<p>3000&nbsp;FORMAT(1H1)</p>
<p>WRITE(&quot;0UTD&quot;,3001) NTAB</p>
<p>3001&nbsp;FORMAT(1H0,15X , 5HTABLE,13/)&nbsp;i IF(JPRINT.E0.0) GOTO 900 WRITE(&quot;OUTD&quot;,3002)</p>
<p>3002&nbsp;FORMAT( 3X<sub>1</sub>1 HI <sub>1</sub>12X, 1hx &gt; 13X, *»HP&lt;x ) , 10X <sub>1</sub>3HF/H <sub>f </sub>♦11X<sub>9</sub>4HCUMY<sub>9</sub>11X<sub>f</sub>4HE(Y)/)</p>
<p>DO 800 I « 1 » NG IF(TAB(I,2).EQ.O) COTO 800</p>
<p>WRITE(&quot;OUTD&quot; ,3003) I<sub>f</sub> (TAB(I <sub>f</sub> J) <sub>9</sub> Js1<sub>9</sub>1|) <sub>9</sub>TABX(I)</p>
<p>3003&nbsp;F0RMATOX<sub>9</sub>I3,3(5X<sub>9</sub>F10.3)<sub>f</sub>5X<sub>9</sub>E10.3,5X<sub>f</sub>F10.3)</p>
<p>800 CONTINUE&nbsp;«</p>
<p>900 WRITE ( &quot;OUTD&quot;<sub>9</sub> 3004 ) SUMF <sub>f</sub> XQU <sub>9</sub> VAR <sub>9</sub> SDV</p>
<p>3004&nbsp;P0RMAT(/2X<sub>9</sub>6H SUMFs<sub>9</sub>F10.1<sub>t</sub>2X<sub>f</sub>5H XQUs<sub>f</sub>F10.2<sub>9</sub>2X<sub>9</sub>5H VARr<sub>t </sub>♦F10.2<sub>9</sub>2X<sub>9</sub>5H SDVs<sub>f</sub>F10.2//)</p>
<p>RETURN END</p>
<p>EVALUE prints the table, if called for<sub>t</sub> plus the means of the Ys<sub>9</sub> followed by the statistical data.</p>
<p>10.2.3 GRAPH Purpose:</p>
<p>This subroutine prints a histogram of either the absolute or relative frequencies from a table.</p>
<p>Calling sequence:</p>
<p>CALL GRAPH (TAB<sub>9</sub>NTAB<sub>9</sub>IU<sub>9</sub>I0<sub>9</sub>Y,&amp;1006)</p>
<p>Parameters:</p>
<p>Frequency table</p>
<p>Pass the table to GRAPH by coding its Fortran name here. Table identifier</p>
<p>To identify the histogram, GRAPH prints this integer in a heading.</p>
<p>Number of the leftmost interval GRAPH can print any portion of starts with this interval on the Number of the rightmost interval</p>
<p>This will be the rightmost interval in the histogram. Mode</p>
<p>This parameter chooses between a histogram in absolute or in relative frequencies.</p>
<p>Y&nbsp;s 0 relative frequency</p>
<p>Y&nbsp;s 1 absolute frequency Error exit</p>
<p>If GRAPH is asked to print fewer than 5 intervals or more than 100. it takes this exit.</p><div>
<p>TAB NTAB</p>
<p>1U</p>
<p>10 Y</p></div><div>
<p>a frequency table; left.</p></div><div>
<p>it</p></div><div>
<p>41006</p></div>
<p>a area:</p><div>
<p>Dat</p></div>
<p>GRAPH uses a frequency table.</p>
<p><a name="bookmark451"></a>Algorithm descriptions</p>
<p><a name="bookmark452"></a>&quot;Error check&quot;</p>
<p><a name="bookmark453"></a>IF(I0-IU.GT.99.0R.IO-IU.LT.*) GOTO 900</p>
<p><a name="bookmark454"></a>If the Intervals were badly chosen, GRAPH returns via its error exit.</p>
<p><a name="bookmark455"></a>&quot;Initialize the variables&quot;</p>
<p>DO 1 I s 1 , 100 M(I) s 0.</p>
<p>1&nbsp;LINE(I) r KBLANC</p>
<p>INT * 100 / (10 - IU ♦ 1) INT1 s 1</p>
<p>IF(INT.EQ.1) GOTO 2 INT1 s INT / 2 INT2 s INT1</p>
<p>IF(INTUINT2.LT.INT) INT1 = INT1 ♦ 1</p>
<p>2&nbsp;MAX = 0.&nbsp;.</p>
<p>H will show the top of each histogram column, one value for each interval on the X axis; LINE will be used to build each line of print; INT shows the width of each interval; MAX will show the height of the tallest column.</p>
<p>&quot;Find the tops of the columns&quot;</p>
<p>11 s 0</p>
<p>IP(Y.GT.O) GOTO 5 SUM = 0.</p>
<p>DO 3 I = 1 <sub>9</sub>&quot;TAB1&quot;</p>
<p>3&nbsp;SUM s SUfl ♦ TAB(I,2) 5 DO 50 I = IU , 10</p>
<p>II s IU 1</p>
<p>IF(Y.GT.O) rt(I1) s TAB( 1,2) IF(Y.EQ.O) M(ID = TAB( 1,2) / SUM • 100. IF(M(I1).GT.MAX) MAX r M(I1) IF(INT.EQ.1) GOTO 50 IF(INT1.EQ.1) GOTO 20 DO 10 12 = 2 INT1 It s It 10 M(I1) s ?!(11-1 ) 20 11 s 11 ♦ INT2 50 CONTINUE</p>
<p>The subroutine sets M for each interval and determines how wide the columns are to be and how much space to put between then.</p>
<p>&quot;Scale the frequency axis<sup>99</sup></p>
<p>IND * 0</p>
<p>If! AX = MAX</p>
<p>DO 60 1*1, 20</p>
<p><a name="bookmark456"></a>IF(IMAX.LT. 10.0R. IMAX. BQ. 10. AND. MAX. EQ. 10**(IND4-1 )) &quot; +G0T0 70</p>
<p><a name="bookmark457"></a>IND « IND ♦ 1 IMAX » IMAX / 10 60 CONTINUE</p>
<p><a name="bookmark458"></a>70 IF(MAX.GT.IMAX*10**IND) IMAX s IMAX ♦ 1 YMAX S IMAX • 10. •• IND</p>
<p><a name="bookmark459"></a>IF(IMAX.LE.5.AND.YMAX.GT.10) IMAX s IMAX • 2</p>
<p>/</p>
<p><a name="bookmark460"></a>MAX determines the scaling used on the frequency axis: the highest value on that axis is saved in YMAX.</p>
<p><a name="bookmark461"></a>&quot;Print a title for the Graph&quot;</p>
<p><a name="bookmark462"></a>100 WRITE(&quot;OUTD&quot;,3000) NTAB</p>
<p><a name="bookmark463"></a>3000&nbsp;FORMAT( ÎH1 , 15X ,6HTABLE, 13//) IF(y.EQ.O) WRITE(&quot;OUTD&quot;,3001)</p>
<p><a name="bookmark464"></a>3001&nbsp;FORMAT(4X,7HPERCENT)</p>
<p><a name="bookmark465"></a>&quot;Print the histogram columns&quot;</p>
<table border="1">
<tr><td>
<p>I NT Y =</p></td><td>
<p>50</p></td></tr>
<tr><td>
<p>MODULI</p></td><td>
<p>= MOD(50,IMAX)</p></td></tr>
<tr><td>
<p>INTY =</p></td><td>
<p>INTY - MODULI</p></td></tr>
<tr><td>
<p>YVALL :</p></td><td>
<p>: YMAX / INTY</p></td></tr>
<tr><td>
<p>YCORR =</p></td><td>
<p>: YVALL / 1000.</p></td></tr>
<tr><td>
<p>INTB =</p></td><td>
<p>INTY / IMAX</p></td></tr>
<tr><td>
<p>J = 0</p></td><td>
<p></p></td></tr>
<tr><td>
<p>DO 150</p></td><td>
<p>1=1, INTY</p></td></tr>
<tr><td>
<p>DO 120</p></td><td>
<p>11 = 1 , 100</p></td></tr>
</table>
<p>IF(LINE(I1).NE.KBLANC) GOTO 120 IF(M(11 )+YC0RR.GE.YMAX) LINE(I1) = KSTERN 120 CONTINUE J = J ♦ 1</p>
<p>IF(J.GT.1) GOTO 130 IMAX = IFIX(YMAX ♦ 0.5)</p>
<p>WRITE(&quot;OUTD&quot;,3002) IMAX,(LINECl 1) , IЫ,100)</p>
<p>3002&nbsp;FORMAT(1X,110,2H I,100A1) GOTO 140</p>
<p><a name="bookmark466"></a>130 WRITE(&quot;OUTD&quot;,3003) (LINE(II),11 = 1,100)</p>
<p>3003&nbsp;FORMAT(12X,1HI,100A 1) 140 YMAX = YMAX - YVALL</p>
<p>IF(J.EQ.INTB) J = 0 150 CONTINUE</p>
<p>The subroutine builds each line and prints It, marking the frequency axis every ten lines.</p>
<p>&quot;Print the X axis&quot;</p>
<p>IPL = INT 1 MULT = 1</p>
<p>IF(INT.GT.1.AND.INT.LT.11) MULT = 4 IF(INT.EQ.I) MULT = 9 DO 170 1=1, 100 IF(I.EQ.IPL) GOTO 160</p>
<p>LINE(I) « KSTR СОТО 170 160 LINE(I) « KPL</p>
<p>IPL x IPL ♦ MULT • INT</p>
<p>IP(MULT.EQ.4.OR.MULT.EQ.9) MULT s MULT «■ 1 170 CONTINUE</p>
<p>lfRITE(&quot;OUTD&quot;,3004) (LINE(I1),I1s1,100) 3004 FORMAT(1OX,3H0 I.100A1) IS = 16 - INT IF(INT.EQ.14) IS = 3 IF(INT.EQ.16) IS s 2 IF(INT.EQ.20) IS s 1 DO 180 I s 1 , 7 180 IFORM(I) s IF0RM1(I,IS) IB : It) 4 1 IS = 1</p>
<p>IF(INT.GT.10) GOTO 190 IF(INT.GT.1) IS s 5 IF(INT.EQ.I) IS s 10 IB s 10 + IS - 1 190 WRITE(&quot;0UTD&quot;,IF0RM) TAB( IU, 1) , (TAB( 1,1) , I = IB, 10, IS) RETURN</p>
<p>•</p>
<p>First we figure out where to mark the X axis with a&nbsp;Then</p>
<p>we use the values from TAB(I<sub>9</sub>1) to print the values of the marks.</p>
<p>&quot;Error exit&quot;</p>
<p>900 RETURN 1 END</p>
<p>Subroutine GRAPH returns via this exit when error detected erroneous parameters.</p>
<p>10.3- Report of the System's State</p>
<p>GPSS-F provides three subroutines to print out data areas: REPORT for the main ones<sub>9</sub> SMLIST for the storage's areas, and SELIST for the multifacllities'</p>
<p>10.3.1 REPORT Purpose:</p>
<p>REPORT prints the contents of the BIN matrix, the BINSTA matrix, the FAC matrix, the MFAC matrix, the STO matrix, the event list, the activation list, the TX matrix and the FAM matrix.</p>
<p>Calling sequence:</p>
<p>CALL REPORT (IBIN,IFAC,IMFAC,ISTO,IEL,IAL,ITf, IFAM)</p><div>
<p>control has</p></div><div>
<p>the system's addressible areas.</p></div>
<p>ZU!&gt;</p>
<p>Parameters:</p>
<p>The parameters specify how many lines from each area are to be printed. Free lines are neither printed, nor do they count toward the total.</p>
<p>TBIN&nbsp;bins</p>
<p>IFAC&nbsp;facilities</p>
<p>IMFAC&nbsp;multlfacilities</p>
<p>ISTO&nbsp;storages</p>
<p>ICL&nbsp;event list</p>
<p>IAL&nbsp;activation list</p>
<p>ITX&nbsp;transactions</p>
<p>IFAM&nbsp;families</p>
<p>Algorithm description:</p>
<p>(See listing in Appendix A5)</p>
<p>10.3.2 SMLIST Purpose:</p>
<p>SMLIST prints a storage's section of the segment matrix, skipping blank lines.</p>
<p>Calling sequence:</p>
<p>CALL SMLIST (NST)</p>
<p>Parameters:</p>
<p>NST Storage number</p>
<p>SMLIST prints the section of the segment matrix belonging to the addressible storage whose type number is NST.</p>
<p>Data area:</p>
<p>SMLIST uses the SBV vector, the STO matrix and the SM matrix. Algorithm description: &quot;Print the SM matrix&quot;</p>
<p>WRITE(&quot;OUTD&quot;,3000) NST</p>
<p>3000&nbsp;FORMAT(1H0 <sub>t</sub>27HS M MATRIX: STORAGE,13,/^X,29HLINE ♦ ADDRESS SEGLEN CODE)</p>
<p>I r SBV(NST) IB s I 4 ST0(NST,2) - 1 10 IADDR = I - SBV(NST) ♦ 1</p>
<p>WRITE(&quot;OUTD&quot;,3001)1,IADDR,SM(1,1),SM(1,2)</p>
<p>3001&nbsp;FORMAT(5X,14,4X,14,5X,IM,&amp;X,1*0 I s I ♦ SM(I,1)</p>
<p>IF(I.LE.IE) GOTO 10 WRITE(&quot;0UTD&quot;,3002)</p>
<p>3002 FORMAT(IHO) RETURN END</p>
<p>After it has found the first and last lines of the section, SMLIST prints each segment's address, length and code.</p>
<p>10.3.3 SELIST Purpose:</p>
<p>SELIST prints a multifacility's section of the SE matrix, skipping blank lines.</p>
<p>Calling sequence:</p>
<p>CALL SELIST (MFA)</p>
<p>Parameters:</p>
<p>MFA Multifacility number</p>
<p>The subroutine prints the section of the matrix belonging to the multifacility whose type number is MFA.</p>
<p>Data area:</p>
<p>SELIST uses the flBV vector, the MFAC matrix and the SE matrix. Algorithm description: •Print the SE matrix*</p>
<p>WRITE(&quot;OUTD&quot;,3000) MFA</p>
<p>3000&nbsp;FORMAT(1H0,24HS E MATRIX: MFAC,13,//MX, ♦30HLINE ELEM C0NT PRC PHASE)</p>
<p>11&nbsp;= MBV(MFA)</p>
<p>12&nbsp;= 11 ♦ MFAC(MFA,2) - 1</p>
<p>13&nbsp;= 1</p>
<p>DO 100 I = II , 12</p>
<p>WRITE(&quot;OUTD&quot;,3001) 1,13,(SE(I,J),Js1,3)</p>
<p>3001&nbsp;F0RMAT(6X,I3,3X,3(I3,2X),17) 100 13 « 13 ♦ 1</p>
<p>WRITE(&quot;OUTD&quot;,3002)</p>
<p>3002&nbsp;F0RMATOH0) RETURN</p>
<p>END</p>
<p>After it has found the first and last lines of the multifacil-ity's section, SELIST prints each service element's number, occupation code, preemption code and service phase.</p>
<p>.10.4 Saving the System 'a State</p>
<p>Longer simulations can be Interrupted and started up again wherever they left off. This feature lets a user check intermediate results at any stage of simulation or break a very long simulation into manageable chunks. Subroutines SAVE and C0NT implement the feature by saving and restoring (on command) GPSS-F's data areas. The user must&quot;write his own subroutines to save and restore his own variables and data areas.</p>
<p>10.1.1&nbsp;SAVE Purpose:</p>
<p>This subroutine writes all of GPSS-F's data areas on a file whose logical device number is &quot;SAVO&quot;. •</p>
<p>Calling sequence:</p>
<p>CALL SAVE</p>
<p>Data area:</p>
<p>SAVE uses every area known to GPSS-F.</p>
<p>Algorithm desctiption:</p>
<p>(See listing in Appendix A5).</p>
<p>Note:</p>
<p>* The user must write a subroutine to save his own data areas <sub>9 </sub>e.g. frequency tables.</p>
<p>10.4.2&nbsp;CONT Purpose:</p>
<p>This subroutine restores all of GPSS-F's data areas from a</p>
<p>file whose logical&nbsp;device number is &quot;SAVI*.</p>
<p>Calling sequence:</p>
<p>CALL CONT</p>
<p>Data area:</p>
<p>CONT uses every data area known to GPSS-F. Algorithm description: (See listing in Appendix A5).</p>
<p>10*5 Ending Stochastic Simulations</p>
<p>Suppose we're using a model to find the mean waiting time in a stationary system (see 1.5.We start the model and watch the queue fill up, recording waiting times as the model runs on. If at regular intervals we compute the mean waiting time, we find it fluctuates at first and then settles down. The longer the model runs, the less our computed mean changes. The value approached by the computed mean we shall call the true mean; it differs from the computed mean, which is:</p>
<p>n</p>
<p>computed mean waiting time s (&gt; ith task's waiting time)/n</p>
<p>is1</p>
<p>where n is the number of tasks that have been through the queue. The difference between the true and the computed means grows smaller with increasing simulation time and with increasing n.</p>
<p>We can break off the simulation once the fluctuations have settled down, for we can assume that they do so in proportion as the computed value approaches the true mean. GPSS-F provides a subroutine that uses this criterion to halt simulations. The subroutine is SIMEND and the mean it use^ is the mean bin time (procedure A) for some given bin.</p>
<p>SIMEND</p>
<p>Purpose:</p>
<p>When an unbroken string of 20 mean bin times differ no more than a given percentage from the most recent one, SIMEND halts simulation.</p>
<p>Calling sequence:</p>
<p>CALL SIMEND (NBN,NE,P,41006)</p>
<p>Parameters:</p>
<p>Bin number</p>
<p>The subroutine watches the mean bin time of tokens in this bin.</p>
<p>Number of withdrawn tokens between checks This number of tokens must be withdrawn before SIMEND recomputes the mean bin time and tests again whether it should call a halt. Percentage deviation</p>
<p>This parameter specifies an interval around the last computed mean. The interval is the given percentage above and below the mean's value; its width is 2*P<sup>#</sup>MEAN/100. If all of the last twenty means fall within the interval, SIMEND takes its addressed exit. Termination exit</p>
<p>SIMEND takes this exit to break off simulation.</p><div>
<p>NBN</p>
<p>NE</p>
<p>P</p></div>
<p>SIHEND uses the area COMMON/BIN/ and the veetor MEAN to save past computations of the aean bin time;</p>
<p>REAL MEAN DIMENSION MEAN(20)</p>
<p>Algorithm description:</p>
<p>&quot;Cheek for a new test&quot;</p>
<p>NT s NA + NE</p>
<p>IF(BIN(NBN,4).LT.NT) RETURN</p>
<p>If fewer than NE tokens have left the bin since the mean bin time was last computed<sub>9</sub> SIMEND returns without adieu.</p>
<p>&quot;Compute and enter the new mean&quot;</p>
<p>NA s NT</p>
<p>PM s M0D(PM,20) ♦ 1</p>
<p>MEAN(PM) s FL0AT(BIN(NBN,6)) / FLOAT(BIN(NBN,4))</p>
<p>This section enters the new mean bin time in the vector. It progresses cyclically through the vector, starting over at the beginning when it reaches the end and overwriting old values.</p>
<p>&quot;Compute the admissible interval&quot;</p>
<p>PR s (MEAN(PM) • P) / 100. MU r MEAN(PM) - PR MO s MEAN(PM) ♦ PR</p>
<p>The interval in which the mean values must fall is laid about the newly computed mean.</p>
<p>&quot;Test the mean values&quot;</p>
<p>III = PM 10 IM = M0D(IM<sub>f</sub>20) ♦ 1</p>
<p>IF(MEAN(IM).EO.O.OR.MEAN(IM).LT.MU.OR.MEAN(IM).CT.M0) ♦RETURN IF(IM.NE.PM) GOTO 10 RETURN 1 END</p>
<p>If any of the values in MEAN falls outside the interval or if any of them is zero, the subroutine returns to the caller. The check for zero insures that at least twenty mean values have been gathered.</p>
<p>Notes:</p>
<p>« A call to SIMEND can be placed anywhere in a model, but we recommend letting it test for termination Just after all condit-loned activations have been taken care of. The following sequence accomplishes just that;</p>
<p>1001 CALL SIMEND (NBN,NE<sub>f</sub>P<sub>f</sub>41006) CALL ACTIV1 (41006)</p>
<p>1003 target selector</p>
<p>model</p>
<p>1005&nbsp;CALL ACTIV2 (41001,41003)</p>
<p>1006&nbsp;termination</p>
<p>*&nbsp;GPSS-F will halt simulation automatically when:</p>
<p>1)&nbsp;the model reaches its time limit, N,</p>
<p>2)&nbsp;flow management runs out of transactions to process,</p>
<p>3)&nbsp;SIMEND finds that the bin it is watching has stabilized, or</p>
<p>4)&nbsp;a subroutine detects an error, e.g. a list overrun.</p>
<p>Flow management runs out of things to do, of course, when all of the sources have shut down and all of the transactions have run out the other end of the model.</p>
<p>•&nbsp;A good choice for the value of NE considers the results of an earlier simulation. The number of tokens it took to reach a stable mean is given by BIN(NBN,4). The first half of them should be written off to the startup phase and the last half divided into twenty test intervals for SIMEND, whence</p>
<p>NE s BIN(NBN,4) / (2»20)</p>
<p><a name="bookmark152"><sup><a href="#footnote1">1</a>&nbsp;</sup></a>&nbsp;Static and dynamic systems:</p>
<p>Static systems are not subject to change. A beam ballance in mechanical equilibrium is a static system, provided it is not</p>
<p><a name="bookmark156"><sup><a href="#footnote2">2</a>&nbsp;</sup></a> The aerodynamics of an airplane is studied on a scaled model in a wind tunnel.</p>
<p><a name="bookmark166"><sup><a href="#footnote3">3</a>&nbsp;</sup></a>&nbsp;Technology</p>
<p>Product design and development Control-systems design Communications</p>
<p><a name="bookmark170"><sup><a href="#footnote4">4</a>&nbsp;</sup></a> WORK</p>
<p>When an active transaction acquires the facility, WORK simulates its time spent there by placing it in the scheduled state. This means that the transaction<sup>#</sup>s progress through the model is intèrrupted for a specified time. During this time, it remains in the scheduled state, occupying the facility. In terms of the bank-window system, the customer spends his 6 minutes at the window. When the time has ellapsed, the transaction can proceed on</p>
<p><a name="bookmark198"><sup><a href="#footnote5">5</a>&nbsp;</sup></a>&nbsp;The transaction, whose parameters are in line LT.X s 1 of the transaction matrix and the activation list, and whose Identifying number is NTX = 2, occupies the facility. It has been there ever since time T § 7•</p>
<p><a name="bookmark268"><sup><a href="#footnote6">6</a>&nbsp;</sup></a> PREEftP does nothing more than to set a preemption in motion. I It cuts off a transaction's remaining service, but the transac- I tion leaves the facility under its own steam. How that happens depends on the service phase in which the preemption occurs:&nbsp;fl</p>
<p>Setup: PREE?4P sets the preemption code. As soon as the setup I is over, the transaction calls WORK, which notices that a preemp- I tion is under way and returns without scheduling the transaction's work phase. The next statement will be either a call to KN0CKD, which simulates the facility's knockdown phase, or a call I to CLEAR, which frees the facility and throws the preempted ff transaction back in the queue.&nbsp;ft</p>
<p>Work: PREEMP schedules the preempted transaction to call W0PK I again immediately. Then the transaction runs on as it would have, m had it been preempted in its setup phase.&nbsp;m</p>
<p>Knockdown: Nothing at all happens, since the facility's occu- I</p>
<p><a name="bookmark314"><sup><a href="#footnote7">7</a>&nbsp;</sup></a> 11</p>
</body>
</html>